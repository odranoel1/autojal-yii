{"version":3,"sources":["vendor/bower-asset/jquery-sidebar/src/jquery.sidebar.js","vendor/bower-asset/matchHeight/dist/jquery.matchHeight.js","vendor/bower-asset/owl.carousel/dist/owl.carousel.js","vendor/bower-asset/nano/nano.js","vendor/bower-asset/slider-pro/dist/js/jquery.sliderPro.js","vendor/bower-asset/magnify/dist/js/jquery.magnify.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACx3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7jMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vendor.js","sourcesContent":["/*!\n *  jQuery sidebar plugin\n *  ---------------------\n *  A stupid simple sidebar jQuery plugin.\n *\n *  Developed with <3 and JavaScript by the jillix developers.\n *  Copyright (c) 2013-15 jillix\n * */\n(function($) {\n\n    /**\n     * sidebar\n     * Initialize sidebar on selected elements.\n     *\n     * ```js\n     * $(\".my-sidebar\").sidebar({...});\n     * ```\n     *\n     * After the call above, you can programatically open/close/toggle the sidebar using:\n     *\n     * ```js\n     * $(\".my-sidebar\").trigger(\"sidebar:open\");\n     * $(\".my-sidebar\").trigger(\"sidebar:close\");\n     * $(\".my-sidebar\").trigger(\"sidebar:toggle\");\n     * $(\".my-sidebar\").trigger(\"sidebar:close\", [{ speed: 0 }]);\n     * ```\n     *\n     * After the sidebar is opened/closed, `sidebar:opened`/`sidebar:closed` event is emitted.\n     *\n     * ```js\n     * $(\".my-sidebar\").on(\"sidebar:opened\", function () {\n     *    // Do something on open\n     * });\n     *\n     * $(\".my-sidebar\").on(\"sidebar:closed\", function () {\n     *    // Do something on close\n     * });\n     * ```\n     *\n     * @name sidebar\n     * @function\n     * @param {Object} options An object that will be merged with the default options.\n     *\n     *  - `speed` (Number): animation speed (default: `200`)\n     *  - `side` (String): left|right|top|bottom (default: `\"left\"`)\n     *  - `isClosed` (Boolean): A boolean value indicating if the sidebar is closed or not (default: `false`).\n     *  - `close` (Boolean): If `true`, the sidebar will be closed by default.\n     *\n     * @return {jQuery} The jQuery elements that were selected.\n     */\n    $.fn.sidebar = function(options) {\n\n        var self = this;\n        if (self.length > 1) {\n            return self.each(function () {\n                $(this).sidebar(options);\n            });\n        }\n\n        // Width, height\n        var width = self.outerWidth();\n        var height = self.outerHeight();\n\n        // Defaults\n        var settings = $.extend({\n\n            // Animation speed\n            speed: 200,\n\n            // Side: left|right|top|bottom\n            side: \"left\",\n\n            // Is closed\n            isClosed: false,\n\n            // Should I close the sidebar?\n            close: true\n\n        }, options);\n\n        /*!\n         *  Opens the sidebar\n         *  $([jQuery selector]).trigger(\"sidebar:open\");\n         * */\n        self.on(\"sidebar:open\", function(ev, data) {\n            var properties = {};\n            properties[settings.side] = 0;\n            settings.isClosed = null;\n            self.stop().animate(properties, $.extend({}, settings, data).speed, function() {\n                settings.isClosed = false;\n                self.trigger(\"sidebar:opened\");\n            });\n        });\n\n\n        /*!\n         *  Closes the sidebar\n         *  $(\"[jQuery selector]).trigger(\"sidebar:close\");\n         * */\n        self.on(\"sidebar:close\", function(ev, data) {\n            var properties = {};\n            if (settings.side === \"left\" || settings.side === \"right\") {\n                properties[settings.side] = -self.outerWidth();\n            } else {\n                properties[settings.side] = -self.outerHeight();\n            }\n            settings.isClosed = null;\n            self.stop().animate(properties, $.extend({}, settings, data).speed, function() {\n                settings.isClosed = true;\n                self.trigger(\"sidebar:closed\");\n            });\n        });\n\n        /*!\n         *  Toggles the sidebar\n         *  $(\"[jQuery selector]).trigger(\"sidebar:toggle\");\n         * */\n        self.on(\"sidebar:toggle\", function(ev, data) {\n            if (settings.isClosed) {\n                self.trigger(\"sidebar:open\", [data]);\n            } else {\n                self.trigger(\"sidebar:close\", [data]);\n            }\n        });\n\n        function closeWithNoAnimation() {\n            self.trigger(\"sidebar:close\", [{\n                speed: 0\n            }]);\n        }\n\n        // Close the sidebar\n        if (!settings.isClosed && settings.close) {\n            closeWithNoAnimation();\n        }\n\n        $(window).on(\"resize\", function () {\n            if (!settings.isClosed) { return; }\n            closeWithNoAnimation();\n        });\n\n        self.data(\"sidebar\", settings);\n\n        return self;\n    };\n\n    // Version\n    $.fn.sidebar.version = \"3.3.2\";\n})(jQuery);\n","/**\n* jquery-match-height 0.7.2 by @liabru\n* http://brm.io/jquery-match-height/\n* License: MIT\n*/\n\n;(function(factory) { // eslint-disable-line no-extra-semi\n    'use strict';\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery'], factory);\n    } else if (typeof module !== 'undefined' && module.exports) {\n        // CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Global\n        factory(jQuery);\n    }\n})(function($) {\n    /*\n    *  internal\n    */\n\n    var _previousResizeWidth = -1,\n        _updateTimeout = -1;\n\n    /*\n    *  _parse\n    *  value parse utility function\n    */\n\n    var _parse = function(value) {\n        // parse value and convert NaN to 0\n        return parseFloat(value) || 0;\n    };\n\n    /*\n    *  _rows\n    *  utility function returns array of jQuery selections representing each row\n    *  (as displayed after float wrapping applied by browser)\n    */\n\n    var _rows = function(elements) {\n        var tolerance = 1,\n            $elements = $(elements),\n            lastTop = null,\n            rows = [];\n\n        // group elements by their top position\n        $elements.each(function(){\n            var $that = $(this),\n                top = $that.offset().top - _parse($that.css('margin-top')),\n                lastRow = rows.length > 0 ? rows[rows.length - 1] : null;\n\n            if (lastRow === null) {\n                // first item on the row, so just push it\n                rows.push($that);\n            } else {\n                // if the row top is the same, add to the row group\n                if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {\n                    rows[rows.length - 1] = lastRow.add($that);\n                } else {\n                    // otherwise start a new row group\n                    rows.push($that);\n                }\n            }\n\n            // keep track of the last row top\n            lastTop = top;\n        });\n\n        return rows;\n    };\n\n    /*\n    *  _parseOptions\n    *  handle plugin options\n    */\n\n    var _parseOptions = function(options) {\n        var opts = {\n            byRow: true,\n            property: 'height',\n            target: null,\n            remove: false\n        };\n\n        if (typeof options === 'object') {\n            return $.extend(opts, options);\n        }\n\n        if (typeof options === 'boolean') {\n            opts.byRow = options;\n        } else if (options === 'remove') {\n            opts.remove = true;\n        }\n\n        return opts;\n    };\n\n    /*\n    *  matchHeight\n    *  plugin definition\n    */\n\n    var matchHeight = $.fn.matchHeight = function(options) {\n        var opts = _parseOptions(options);\n\n        // handle remove\n        if (opts.remove) {\n            var that = this;\n\n            // remove fixed height from all selected elements\n            this.css(opts.property, '');\n\n            // remove selected elements from all groups\n            $.each(matchHeight._groups, function(key, group) {\n                group.elements = group.elements.not(that);\n            });\n\n            // TODO: cleanup empty groups\n\n            return this;\n        }\n\n        if (this.length <= 1 && !opts.target) {\n            return this;\n        }\n\n        // keep track of this group so we can re-apply later on load and resize events\n        matchHeight._groups.push({\n            elements: this,\n            options: opts\n        });\n\n        // match each element's height to the tallest element in the selection\n        matchHeight._apply(this, opts);\n\n        return this;\n    };\n\n    /*\n    *  plugin global options\n    */\n\n    matchHeight.version = '0.7.2';\n    matchHeight._groups = [];\n    matchHeight._throttle = 80;\n    matchHeight._maintainScroll = false;\n    matchHeight._beforeUpdate = null;\n    matchHeight._afterUpdate = null;\n    matchHeight._rows = _rows;\n    matchHeight._parse = _parse;\n    matchHeight._parseOptions = _parseOptions;\n\n    /*\n    *  matchHeight._apply\n    *  apply matchHeight to given elements\n    */\n\n    matchHeight._apply = function(elements, options) {\n        var opts = _parseOptions(options),\n            $elements = $(elements),\n            rows = [$elements];\n\n        // take note of scroll position\n        var scrollTop = $(window).scrollTop(),\n            htmlHeight = $('html').outerHeight(true);\n\n        // get hidden parents\n        var $hiddenParents = $elements.parents().filter(':hidden');\n\n        // cache the original inline style\n        $hiddenParents.each(function() {\n            var $that = $(this);\n            $that.data('style-cache', $that.attr('style'));\n        });\n\n        // temporarily must force hidden parents visible\n        $hiddenParents.css('display', 'block');\n\n        // get rows if using byRow, otherwise assume one row\n        if (opts.byRow && !opts.target) {\n\n            // must first force an arbitrary equal height so floating elements break evenly\n            $elements.each(function() {\n                var $that = $(this),\n                    display = $that.css('display');\n\n                // temporarily force a usable display value\n                if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {\n                    display = 'block';\n                }\n\n                // cache the original inline style\n                $that.data('style-cache', $that.attr('style'));\n\n                $that.css({\n                    'display': display,\n                    'padding-top': '0',\n                    'padding-bottom': '0',\n                    'margin-top': '0',\n                    'margin-bottom': '0',\n                    'border-top-width': '0',\n                    'border-bottom-width': '0',\n                    'height': '100px',\n                    'overflow': 'hidden'\n                });\n            });\n\n            // get the array of rows (based on element top position)\n            rows = _rows($elements);\n\n            // revert original inline styles\n            $elements.each(function() {\n                var $that = $(this);\n                $that.attr('style', $that.data('style-cache') || '');\n            });\n        }\n\n        $.each(rows, function(key, row) {\n            var $row = $(row),\n                targetHeight = 0;\n\n            if (!opts.target) {\n                // skip apply to rows with only one item\n                if (opts.byRow && $row.length <= 1) {\n                    $row.css(opts.property, '');\n                    return;\n                }\n\n                // iterate the row and find the max height\n                $row.each(function(){\n                    var $that = $(this),\n                        style = $that.attr('style'),\n                        display = $that.css('display');\n\n                    // temporarily force a usable display value\n                    if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {\n                        display = 'block';\n                    }\n\n                    // ensure we get the correct actual height (and not a previously set height value)\n                    var css = { 'display': display };\n                    css[opts.property] = '';\n                    $that.css(css);\n\n                    // find the max height (including padding, but not margin)\n                    if ($that.outerHeight(false) > targetHeight) {\n                        targetHeight = $that.outerHeight(false);\n                    }\n\n                    // revert styles\n                    if (style) {\n                        $that.attr('style', style);\n                    } else {\n                        $that.css('display', '');\n                    }\n                });\n            } else {\n                // if target set, use the height of the target element\n                targetHeight = opts.target.outerHeight(false);\n            }\n\n            // iterate the row and apply the height to all elements\n            $row.each(function(){\n                var $that = $(this),\n                    verticalPadding = 0;\n\n                // don't apply to a target\n                if (opts.target && $that.is(opts.target)) {\n                    return;\n                }\n\n                // handle padding and border correctly (required when not using border-box)\n                if ($that.css('box-sizing') !== 'border-box') {\n                    verticalPadding += _parse($that.css('border-top-width')) + _parse($that.css('border-bottom-width'));\n                    verticalPadding += _parse($that.css('padding-top')) + _parse($that.css('padding-bottom'));\n                }\n\n                // set the height (accounting for padding and border)\n                $that.css(opts.property, (targetHeight - verticalPadding) + 'px');\n            });\n        });\n\n        // revert hidden parents\n        $hiddenParents.each(function() {\n            var $that = $(this);\n            $that.attr('style', $that.data('style-cache') || null);\n        });\n\n        // restore scroll position if enabled\n        if (matchHeight._maintainScroll) {\n            $(window).scrollTop((scrollTop / htmlHeight) * $('html').outerHeight(true));\n        }\n\n        return this;\n    };\n\n    /*\n    *  matchHeight._applyDataApi\n    *  applies matchHeight to all elements with a data-match-height attribute\n    */\n\n    matchHeight._applyDataApi = function() {\n        var groups = {};\n\n        // generate groups by their groupId set by elements using data-match-height\n        $('[data-match-height], [data-mh]').each(function() {\n            var $this = $(this),\n                groupId = $this.attr('data-mh') || $this.attr('data-match-height');\n\n            if (groupId in groups) {\n                groups[groupId] = groups[groupId].add($this);\n            } else {\n                groups[groupId] = $this;\n            }\n        });\n\n        // apply matchHeight to each group\n        $.each(groups, function() {\n            this.matchHeight(true);\n        });\n    };\n\n    /*\n    *  matchHeight._update\n    *  updates matchHeight on all current groups with their correct options\n    */\n\n    var _update = function(event) {\n        if (matchHeight._beforeUpdate) {\n            matchHeight._beforeUpdate(event, matchHeight._groups);\n        }\n\n        $.each(matchHeight._groups, function() {\n            matchHeight._apply(this.elements, this.options);\n        });\n\n        if (matchHeight._afterUpdate) {\n            matchHeight._afterUpdate(event, matchHeight._groups);\n        }\n    };\n\n    matchHeight._update = function(throttle, event) {\n        // prevent update if fired from a resize event\n        // where the viewport width hasn't actually changed\n        // fixes an event looping bug in IE8\n        if (event && event.type === 'resize') {\n            var windowWidth = $(window).width();\n            if (windowWidth === _previousResizeWidth) {\n                return;\n            }\n            _previousResizeWidth = windowWidth;\n        }\n\n        // throttle updates\n        if (!throttle) {\n            _update(event);\n        } else if (_updateTimeout === -1) {\n            _updateTimeout = setTimeout(function() {\n                _update(event);\n                _updateTimeout = -1;\n            }, matchHeight._throttle);\n        }\n    };\n\n    /*\n    *  bind events\n    */\n\n    // apply on DOM ready event\n    $(matchHeight._applyDataApi);\n\n    // use on or bind where supported\n    var on = $.fn.on ? 'on' : 'bind';\n\n    // update heights on load and resize events\n    $(window)[on]('load', function(event) {\n        matchHeight._update(false, event);\n    });\n\n    // throttled update heights on resize events\n    $(window)[on]('resize orientationchange', function(event) {\n        matchHeight._update(true, event);\n    });\n\n});\n","/**\n * Owl Carousel v2.3.4\n * Copyright 2013-2018 David Deutsch\n * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE\n */\n/**\n * Owl carousel\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n * @todo Lazy Load Icon\n * @todo prevent animationend bubling\n * @todo itemsScaleUp\n * @todo Test Zepto\n * @todo stagePadding calculate wrong active classes\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates a carousel.\n\t * @class The Owl Carousel.\n\t * @public\n\t * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n\t * @param {Object} [options] - The options\n\t */\n\tfunction Owl(element, options) {\n\n\t\t/**\n\t\t * Current settings for the carousel.\n\t\t * @public\n\t\t */\n\t\tthis.settings = null;\n\n\t\t/**\n\t\t * Current options set by the caller including defaults.\n\t\t * @public\n\t\t */\n\t\tthis.options = $.extend({}, Owl.Defaults, options);\n\n\t\t/**\n\t\t * Plugin element.\n\t\t * @public\n\t\t */\n\t\tthis.$element = $(element);\n\n\t\t/**\n\t\t * Proxied event handlers.\n\t\t * @protected\n\t\t */\n\t\tthis._handlers = {};\n\n\t\t/**\n\t\t * References to the running plugins of this carousel.\n\t\t * @protected\n\t\t */\n\t\tthis._plugins = {};\n\n\t\t/**\n\t\t * Currently suppressed events to prevent them from being retriggered.\n\t\t * @protected\n\t\t */\n\t\tthis._supress = {};\n\n\t\t/**\n\t\t * Absolute current position.\n\t\t * @protected\n\t\t */\n\t\tthis._current = null;\n\n\t\t/**\n\t\t * Animation speed in milliseconds.\n\t\t * @protected\n\t\t */\n\t\tthis._speed = null;\n\n\t\t/**\n\t\t * Coordinates of all items in pixel.\n\t\t * @todo The name of this member is missleading.\n\t\t * @protected\n\t\t */\n\t\tthis._coordinates = [];\n\n\t\t/**\n\t\t * Current breakpoint.\n\t\t * @todo Real media queries would be nice.\n\t\t * @protected\n\t\t */\n\t\tthis._breakpoint = null;\n\n\t\t/**\n\t\t * Current width of the plugin element.\n\t\t */\n\t\tthis._width = null;\n\n\t\t/**\n\t\t * All real items.\n\t\t * @protected\n\t\t */\n\t\tthis._items = [];\n\n\t\t/**\n\t\t * All cloned items.\n\t\t * @protected\n\t\t */\n\t\tthis._clones = [];\n\n\t\t/**\n\t\t * Merge values of all items.\n\t\t * @todo Maybe this could be part of a plugin.\n\t\t * @protected\n\t\t */\n\t\tthis._mergers = [];\n\n\t\t/**\n\t\t * Widths of all items.\n\t\t */\n\t\tthis._widths = [];\n\n\t\t/**\n\t\t * Invalidated parts within the update process.\n\t\t * @protected\n\t\t */\n\t\tthis._invalidated = {};\n\n\t\t/**\n\t\t * Ordered list of workers for the update process.\n\t\t * @protected\n\t\t */\n\t\tthis._pipe = [];\n\n\t\t/**\n\t\t * Current state information for the drag operation.\n\t\t * @todo #261\n\t\t * @protected\n\t\t */\n\t\tthis._drag = {\n\t\t\ttime: null,\n\t\t\ttarget: null,\n\t\t\tpointer: null,\n\t\t\tstage: {\n\t\t\t\tstart: null,\n\t\t\t\tcurrent: null\n\t\t\t},\n\t\t\tdirection: null\n\t\t};\n\n\t\t/**\n\t\t * Current state information and their tags.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._states = {\n\t\t\tcurrent: {},\n\t\t\ttags: {\n\t\t\t\t'initializing': [ 'busy' ],\n\t\t\t\t'animating': [ 'busy' ],\n\t\t\t\t'dragging': [ 'interacting' ]\n\t\t\t}\n\t\t};\n\n\t\t$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {\n\t\t\tthis._handlers[handler] = $.proxy(this[handler], this);\n\t\t}, this));\n\n\t\t$.each(Owl.Plugins, $.proxy(function(key, plugin) {\n\t\t\tthis._plugins[key.charAt(0).toLowerCase() + key.slice(1)]\n\t\t\t\t= new plugin(this);\n\t\t}, this));\n\n\t\t$.each(Owl.Workers, $.proxy(function(priority, worker) {\n\t\t\tthis._pipe.push({\n\t\t\t\t'filter': worker.filter,\n\t\t\t\t'run': $.proxy(worker.run, this)\n\t\t\t});\n\t\t}, this));\n\n\t\tthis.setup();\n\t\tthis.initialize();\n\t}\n\n\t/**\n\t * Default options for the carousel.\n\t * @public\n\t */\n\tOwl.Defaults = {\n\t\titems: 3,\n\t\tloop: false,\n\t\tcenter: false,\n\t\trewind: false,\n\t\tcheckVisibility: true,\n\n\t\tmouseDrag: true,\n\t\ttouchDrag: true,\n\t\tpullDrag: true,\n\t\tfreeDrag: false,\n\n\t\tmargin: 0,\n\t\tstagePadding: 0,\n\n\t\tmerge: false,\n\t\tmergeFit: true,\n\t\tautoWidth: false,\n\n\t\tstartPosition: 0,\n\t\trtl: false,\n\n\t\tsmartSpeed: 250,\n\t\tfluidSpeed: false,\n\t\tdragEndSpeed: false,\n\n\t\tresponsive: {},\n\t\tresponsiveRefreshRate: 200,\n\t\tresponsiveBaseElement: window,\n\n\t\tfallbackEasing: 'swing',\n\t\tslideTransition: '',\n\n\t\tinfo: false,\n\n\t\tnestedItemSelector: false,\n\t\titemElement: 'div',\n\t\tstageElement: 'div',\n\n\t\trefreshClass: 'owl-refresh',\n\t\tloadedClass: 'owl-loaded',\n\t\tloadingClass: 'owl-loading',\n\t\trtlClass: 'owl-rtl',\n\t\tresponsiveClass: 'owl-responsive',\n\t\tdragClass: 'owl-drag',\n\t\titemClass: 'owl-item',\n\t\tstageClass: 'owl-stage',\n\t\tstageOuterClass: 'owl-stage-outer',\n\t\tgrabClass: 'owl-grab'\n\t};\n\n\t/**\n\t * Enumeration for width.\n\t * @public\n\t * @readonly\n\t * @enum {String}\n\t */\n\tOwl.Width = {\n\t\tDefault: 'default',\n\t\tInner: 'inner',\n\t\tOuter: 'outer'\n\t};\n\n\t/**\n\t * Enumeration for types.\n\t * @public\n\t * @readonly\n\t * @enum {String}\n\t */\n\tOwl.Type = {\n\t\tEvent: 'event',\n\t\tState: 'state'\n\t};\n\n\t/**\n\t * Contains all registered plugins.\n\t * @public\n\t */\n\tOwl.Plugins = {};\n\n\t/**\n\t * List of workers involved in the update process.\n\t */\n\tOwl.Workers = [ {\n\t\tfilter: [ 'width', 'settings' ],\n\t\trun: function() {\n\t\t\tthis._width = this.$element.width();\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tcache.current = this._items && this._items[this.relative(this._current)];\n\t\t}\n\t}, {\n\t\tfilter: [ 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tthis.$stage.children('.cloned').remove();\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tvar margin = this.settings.margin || '',\n\t\t\t\tgrid = !this.settings.autoWidth,\n\t\t\t\trtl = this.settings.rtl,\n\t\t\t\tcss = {\n\t\t\t\t\t'width': 'auto',\n\t\t\t\t\t'margin-left': rtl ? margin : '',\n\t\t\t\t\t'margin-right': rtl ? '' : margin\n\t\t\t\t};\n\n\t\t\t!grid && this.$stage.children().css(css);\n\n\t\t\tcache.css = css;\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tvar width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n\t\t\t\tmerge = null,\n\t\t\t\titerator = this._items.length,\n\t\t\t\tgrid = !this.settings.autoWidth,\n\t\t\t\twidths = [];\n\n\t\t\tcache.items = {\n\t\t\t\tmerge: false,\n\t\t\t\twidth: width\n\t\t\t};\n\n\t\t\twhile (iterator--) {\n\t\t\t\tmerge = this._mergers[iterator];\n\t\t\t\tmerge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\n\n\t\t\t\tcache.items.merge = merge > 1 || cache.items.merge;\n\n\t\t\t\twidths[iterator] = !grid ? this._items[iterator].width() : width * merge;\n\t\t\t}\n\n\t\t\tthis._widths = widths;\n\t\t}\n\t}, {\n\t\tfilter: [ 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar clones = [],\n\t\t\t\titems = this._items,\n\t\t\t\tsettings = this.settings,\n\t\t\t\t// TODO: Should be computed from number of min width items in stage\n\t\t\t\tview = Math.max(settings.items * 2, 4),\n\t\t\t\tsize = Math.ceil(items.length / 2) * 2,\n\t\t\t\trepeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\n\t\t\t\tappend = '',\n\t\t\t\tprepend = '';\n\n\t\t\trepeat /= 2;\n\n\t\t\twhile (repeat > 0) {\n\t\t\t\t// Switch to only using appended clones\n\t\t\t\tclones.push(this.normalize(clones.length / 2, true));\n\t\t\t\tappend = append + items[clones[clones.length - 1]][0].outerHTML;\n\t\t\t\tclones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\n\t\t\t\tprepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\n\t\t\t\trepeat -= 1;\n\t\t\t}\n\n\t\t\tthis._clones = clones;\n\n\t\t\t$(append).addClass('cloned').appendTo(this.$stage);\n\t\t\t$(prepend).addClass('cloned').prependTo(this.$stage);\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t\tsize = this._clones.length + this._items.length,\n\t\t\t\titerator = -1,\n\t\t\t\tprevious = 0,\n\t\t\t\tcurrent = 0,\n\t\t\t\tcoordinates = [];\n\n\t\t\twhile (++iterator < size) {\n\t\t\t\tprevious = coordinates[iterator - 1] || 0;\n\t\t\t\tcurrent = this._widths[this.relative(iterator)] + this.settings.margin;\n\t\t\t\tcoordinates.push(previous + current * rtl);\n\t\t\t}\n\n\t\t\tthis._coordinates = coordinates;\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar padding = this.settings.stagePadding,\n\t\t\t\tcoordinates = this._coordinates,\n\t\t\t\tcss = {\n\t\t\t\t\t'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\n\t\t\t\t\t'padding-left': padding || '',\n\t\t\t\t\t'padding-right': padding || ''\n\t\t\t\t};\n\n\t\t\tthis.$stage.css(css);\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tvar iterator = this._coordinates.length,\n\t\t\t\tgrid = !this.settings.autoWidth,\n\t\t\t\titems = this.$stage.children();\n\n\t\t\tif (grid && cache.items.merge) {\n\t\t\t\twhile (iterator--) {\n\t\t\t\t\tcache.css.width = this._widths[this.relative(iterator)];\n\t\t\t\t\titems.eq(iterator).css(cache.css);\n\t\t\t\t}\n\t\t\t} else if (grid) {\n\t\t\t\tcache.css.width = cache.items.width;\n\t\t\t\titems.css(cache.css);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tfilter: [ 'items' ],\n\t\trun: function() {\n\t\t\tthis._coordinates.length < 1 && this.$stage.removeAttr('style');\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tcache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\n\t\t\tcache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\n\t\t\tthis.reset(cache.current);\n\t\t}\n\t}, {\n\t\tfilter: [ 'position' ],\n\t\trun: function() {\n\t\t\tthis.animate(this.coordinates(this._current));\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'position', 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t\tpadding = this.settings.stagePadding * 2,\n\t\t\t\tbegin = this.coordinates(this.current()) + padding,\n\t\t\t\tend = begin + this.width() * rtl,\n\t\t\t\tinner, outer, matches = [], i, n;\n\n\t\t\tfor (i = 0, n = this._coordinates.length; i < n; i++) {\n\t\t\t\tinner = this._coordinates[i - 1] || 0;\n\t\t\t\touter = Math.abs(this._coordinates[i]) + padding * rtl;\n\n\t\t\t\tif ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\n\t\t\t\t\t|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\n\t\t\t\t\tmatches.push(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.$stage.children('.active').removeClass('active');\n\t\t\tthis.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\n\n\t\t\tthis.$stage.children('.center').removeClass('center');\n\t\t\tif (this.settings.center) {\n\t\t\t\tthis.$stage.children().eq(this.current()).addClass('center');\n\t\t\t}\n\t\t}\n\t} ];\n\n\t/**\n\t * Create the stage DOM element\n\t */\n\tOwl.prototype.initializeStage = function() {\n\t\tthis.$stage = this.$element.find('.' + this.settings.stageClass);\n\n\t\t// if the stage is already in the DOM, grab it and skip stage initialization\n\t\tif (this.$stage.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.$element.addClass(this.options.loadingClass);\n\n\t\t// create stage\n\t\tthis.$stage = $('<' + this.settings.stageElement + '>', {\n\t\t\t\"class\": this.settings.stageClass\n\t\t}).wrap( $( '<div/>', {\n\t\t\t\"class\": this.settings.stageOuterClass\n\t\t}));\n\n\t\t// append stage\n\t\tthis.$element.append(this.$stage.parent());\n\t};\n\n\t/**\n\t * Create item DOM elements\n\t */\n\tOwl.prototype.initializeItems = function() {\n\t\tvar $items = this.$element.find('.owl-item');\n\n\t\t// if the items are already in the DOM, grab them and skip item initialization\n\t\tif ($items.length) {\n\t\t\tthis._items = $items.get().map(function(item) {\n\t\t\t\treturn $(item);\n\t\t\t});\n\n\t\t\tthis._mergers = this._items.map(function() {\n\t\t\t\treturn 1;\n\t\t\t});\n\n\t\t\tthis.refresh();\n\n\t\t\treturn;\n\t\t}\n\n\t\t// append content\n\t\tthis.replace(this.$element.children().not(this.$stage.parent()));\n\n\t\t// check visibility\n\t\tif (this.isVisible()) {\n\t\t\t// update view\n\t\t\tthis.refresh();\n\t\t} else {\n\t\t\t// invalidate width\n\t\t\tthis.invalidate('width');\n\t\t}\n\n\t\tthis.$element\n\t\t\t.removeClass(this.options.loadingClass)\n\t\t\t.addClass(this.options.loadedClass);\n\t};\n\n\t/**\n\t * Initializes the carousel.\n\t * @protected\n\t */\n\tOwl.prototype.initialize = function() {\n\t\tthis.enter('initializing');\n\t\tthis.trigger('initialize');\n\n\t\tthis.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n\t\tif (this.settings.autoWidth && !this.is('pre-loading')) {\n\t\t\tvar imgs, nestedSelector, width;\n\t\t\timgs = this.$element.find('img');\n\t\t\tnestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n\t\t\twidth = this.$element.children(nestedSelector).width();\n\n\t\t\tif (imgs.length && width <= 0) {\n\t\t\t\tthis.preloadAutoWidthImages(imgs);\n\t\t\t}\n\t\t}\n\n\t\tthis.initializeStage();\n\t\tthis.initializeItems();\n\n\t\t// register event handlers\n\t\tthis.registerEventHandlers();\n\n\t\tthis.leave('initializing');\n\t\tthis.trigger('initialized');\n\t};\n\n\t/**\n\t * @returns {Boolean} visibility of $element\n\t *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to\n\t *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does\n\t */\n\tOwl.prototype.isVisible = function() {\n\t\treturn this.settings.checkVisibility\n\t\t\t? this.$element.is(':visible')\n\t\t\t: true;\n\t};\n\n\t/**\n\t * Setups the current settings.\n\t * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n\t * @todo Support for media queries by using `matchMedia` would be nice.\n\t * @public\n\t */\n\tOwl.prototype.setup = function() {\n\t\tvar viewport = this.viewport(),\n\t\t\toverwrites = this.options.responsive,\n\t\t\tmatch = -1,\n\t\t\tsettings = null;\n\n\t\tif (!overwrites) {\n\t\t\tsettings = $.extend({}, this.options);\n\t\t} else {\n\t\t\t$.each(overwrites, function(breakpoint) {\n\t\t\t\tif (breakpoint <= viewport && breakpoint > match) {\n\t\t\t\t\tmatch = Number(breakpoint);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tsettings = $.extend({}, this.options, overwrites[match]);\n\t\t\tif (typeof settings.stagePadding === 'function') {\n\t\t\t\tsettings.stagePadding = settings.stagePadding();\n\t\t\t}\n\t\t\tdelete settings.responsive;\n\n\t\t\t// responsive class\n\t\t\tif (settings.responsiveClass) {\n\t\t\t\tthis.$element.attr('class',\n\t\t\t\t\tthis.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis.trigger('change', { property: { name: 'settings', value: settings } });\n\t\tthis._breakpoint = match;\n\t\tthis.settings = settings;\n\t\tthis.invalidate('settings');\n\t\tthis.trigger('changed', { property: { name: 'settings', value: this.settings } });\n\t};\n\n\t/**\n\t * Updates option logic if necessery.\n\t * @protected\n\t */\n\tOwl.prototype.optionsLogic = function() {\n\t\tif (this.settings.autoWidth) {\n\t\t\tthis.settings.stagePadding = false;\n\t\t\tthis.settings.merge = false;\n\t\t}\n\t};\n\n\t/**\n\t * Prepares an item before add.\n\t * @todo Rename event parameter `content` to `item`.\n\t * @protected\n\t * @returns {jQuery|HTMLElement} - The item container.\n\t */\n\tOwl.prototype.prepare = function(item) {\n\t\tvar event = this.trigger('prepare', { content: item });\n\n\t\tif (!event.data) {\n\t\t\tevent.data = $('<' + this.settings.itemElement + '/>')\n\t\t\t\t.addClass(this.options.itemClass).append(item)\n\t\t}\n\n\t\tthis.trigger('prepared', { content: event.data });\n\n\t\treturn event.data;\n\t};\n\n\t/**\n\t * Updates the view.\n\t * @public\n\t */\n\tOwl.prototype.update = function() {\n\t\tvar i = 0,\n\t\t\tn = this._pipe.length,\n\t\t\tfilter = $.proxy(function(p) { return this[p] }, this._invalidated),\n\t\t\tcache = {};\n\n\t\twhile (i < n) {\n\t\t\tif (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n\t\t\t\tthis._pipe[i].run(cache);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tthis._invalidated = {};\n\n\t\t!this.is('valid') && this.enter('valid');\n\t};\n\n\t/**\n\t * Gets the width of the view.\n\t * @public\n\t * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n\t * @returns {Number} - The width of the view in pixel.\n\t */\n\tOwl.prototype.width = function(dimension) {\n\t\tdimension = dimension || Owl.Width.Default;\n\t\tswitch (dimension) {\n\t\t\tcase Owl.Width.Inner:\n\t\t\tcase Owl.Width.Outer:\n\t\t\t\treturn this._width;\n\t\t\tdefault:\n\t\t\t\treturn this._width - this.settings.stagePadding * 2 + this.settings.margin;\n\t\t}\n\t};\n\n\t/**\n\t * Refreshes the carousel primarily for adaptive purposes.\n\t * @public\n\t */\n\tOwl.prototype.refresh = function() {\n\t\tthis.enter('refreshing');\n\t\tthis.trigger('refresh');\n\n\t\tthis.setup();\n\n\t\tthis.optionsLogic();\n\n\t\tthis.$element.addClass(this.options.refreshClass);\n\n\t\tthis.update();\n\n\t\tthis.$element.removeClass(this.options.refreshClass);\n\n\t\tthis.leave('refreshing');\n\t\tthis.trigger('refreshed');\n\t};\n\n\t/**\n\t * Checks window `resize` event.\n\t * @protected\n\t */\n\tOwl.prototype.onThrottledResize = function() {\n\t\twindow.clearTimeout(this.resizeTimer);\n\t\tthis.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n\t};\n\n\t/**\n\t * Checks window `resize` event.\n\t * @protected\n\t */\n\tOwl.prototype.onResize = function() {\n\t\tif (!this._items.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._width === this.$element.width()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.isVisible()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.enter('resizing');\n\n\t\tif (this.trigger('resize').isDefaultPrevented()) {\n\t\t\tthis.leave('resizing');\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.invalidate('width');\n\n\t\tthis.refresh();\n\n\t\tthis.leave('resizing');\n\t\tthis.trigger('resized');\n\t};\n\n\t/**\n\t * Registers event handlers.\n\t * @todo Check `msPointerEnabled`\n\t * @todo #261\n\t * @protected\n\t */\n\tOwl.prototype.registerEventHandlers = function() {\n\t\tif ($.support.transition) {\n\t\t\tthis.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\n\t\t}\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\tthis.on(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tif (this.settings.mouseDrag) {\n\t\t\tthis.$element.addClass(this.options.dragClass);\n\t\t\tthis.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });\n\t\t}\n\n\t\tif (this.settings.touchDrag){\n\t\t\tthis.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\n\t\t}\n\t};\n\n\t/**\n\t * Handles `touchstart` and `mousedown` events.\n\t * @todo Horizontal swipe threshold as option\n\t * @todo #261\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onDragStart = function(event) {\n\t\tvar stage = null;\n\n\t\tif (event.which === 3) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ($.support.transform) {\n\t\t\tstage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');\n\t\t\tstage = {\n\t\t\t\tx: stage[stage.length === 16 ? 12 : 4],\n\t\t\t\ty: stage[stage.length === 16 ? 13 : 5]\n\t\t\t};\n\t\t} else {\n\t\t\tstage = this.$stage.position();\n\t\t\tstage = {\n\t\t\t\tx: this.settings.rtl ?\n\t\t\t\t\tstage.left + this.$stage.width() - this.width() + this.settings.margin :\n\t\t\t\t\tstage.left,\n\t\t\t\ty: stage.top\n\t\t\t};\n\t\t}\n\n\t\tif (this.is('animating')) {\n\t\t\t$.support.transform ? this.animate(stage.x) : this.$stage.stop()\n\t\t\tthis.invalidate('position');\n\t\t}\n\n\t\tthis.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\n\n\t\tthis.speed(0);\n\n\t\tthis._drag.time = new Date().getTime();\n\t\tthis._drag.target = $(event.target);\n\t\tthis._drag.stage.start = stage;\n\t\tthis._drag.stage.current = stage;\n\t\tthis._drag.pointer = this.pointer(event);\n\n\t\t$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\n\n\t\t$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {\n\t\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event));\n\n\t\t\t$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\n\n\t\t\tif (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\n\t\t\tthis.enter('dragging');\n\t\t\tthis.trigger('drag');\n\t\t}, this));\n\t};\n\n\t/**\n\t * Handles the `touchmove` and `mousemove` events.\n\t * @todo #261\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onDragMove = function(event) {\n\t\tvar minimum = null,\n\t\t\tmaximum = null,\n\t\t\tpull = null,\n\t\t\tdelta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t\tstage = this.difference(this._drag.stage.start, delta);\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tevent.preventDefault();\n\n\t\tif (this.settings.loop) {\n\t\t\tminimum = this.coordinates(this.minimum());\n\t\t\tmaximum = this.coordinates(this.maximum() + 1) - minimum;\n\t\t\tstage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;\n\t\t} else {\n\t\t\tminimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n\t\t\tmaximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n\t\t\tpull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\n\t\t\tstage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\n\t\t}\n\n\t\tthis._drag.stage.current = stage;\n\n\t\tthis.animate(stage.x);\n\t};\n\n\t/**\n\t * Handles the `touchend` and `mouseup` events.\n\t * @todo #261\n\t * @todo Threshold for click event\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onDragEnd = function(event) {\n\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t\tstage = this._drag.stage.current,\n\t\t\tdirection = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\n\n\t\t$(document).off('.owl.core');\n\n\t\tthis.$element.removeClass(this.options.grabClass);\n\n\t\tif (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\n\t\t\tthis.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n\t\t\tthis.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\n\t\t\tthis.invalidate('position');\n\t\t\tthis.update();\n\n\t\t\tthis._drag.direction = direction;\n\n\t\t\tif (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\n\t\t\t\tthis._drag.target.one('click.owl.core', function() { return false; });\n\t\t\t}\n\t\t}\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.leave('dragging');\n\t\tthis.trigger('dragged');\n\t};\n\n\t/**\n\t * Gets absolute position of the closest item for a coordinate.\n\t * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n\t * @protected\n\t * @param {Number} coordinate - The coordinate in pixel.\n\t * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n\t * @return {Number} - The absolute position of the closest item.\n\t */\n\tOwl.prototype.closest = function(coordinate, direction) {\n\t\tvar position = -1,\n\t\t\tpull = 30,\n\t\t\twidth = this.width(),\n\t\t\tcoordinates = this.coordinates();\n\n\t\tif (!this.settings.freeDrag) {\n\t\t\t// check closest item\n\t\t\t$.each(coordinates, $.proxy(function(index, value) {\n\t\t\t\t// on a left pull, check on current index\n\t\t\t\tif (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\n\t\t\t\t\tposition = index;\n\t\t\t\t// on a right pull, check on previous index\n\t\t\t\t// to do so, subtract width from value and set position = index + 1\n\t\t\t\t} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\n\t\t\t\t\tposition = index + 1;\n\t\t\t\t} else if (this.op(coordinate, '<', value)\n\t\t\t\t\t&& this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {\n\t\t\t\t\tposition = direction === 'left' ? index + 1 : index;\n\t\t\t\t}\n\t\t\t\treturn position === -1;\n\t\t\t}, this));\n\t\t}\n\n\t\tif (!this.settings.loop) {\n\t\t\t// non loop boundries\n\t\t\tif (this.op(coordinate, '>', coordinates[this.minimum()])) {\n\t\t\t\tposition = coordinate = this.minimum();\n\t\t\t} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n\t\t\t\tposition = coordinate = this.maximum();\n\t\t\t}\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n\t * Animates the stage.\n\t * @todo #270\n\t * @public\n\t * @param {Number} coordinate - The coordinate in pixels.\n\t */\n\tOwl.prototype.animate = function(coordinate) {\n\t\tvar animate = this.speed() > 0;\n\n\t\tthis.is('animating') && this.onTransitionEnd();\n\n\t\tif (animate) {\n\t\t\tthis.enter('animating');\n\t\t\tthis.trigger('translate');\n\t\t}\n\n\t\tif ($.support.transform3d && $.support.transition) {\n\t\t\tthis.$stage.css({\n\t\t\t\ttransform: 'translate3d(' + coordinate + 'px,0px,0px)',\n\t\t\t\ttransition: (this.speed() / 1000) + 's' + (\n\t\t\t\t\tthis.settings.slideTransition ? ' ' + this.settings.slideTransition : ''\n\t\t\t\t)\n\t\t\t});\n\t\t} else if (animate) {\n\t\t\tthis.$stage.animate({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\n\t\t} else {\n\t\t\tthis.$stage.css({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Checks whether the carousel is in a specific state or not.\n\t * @param {String} state - The state to check.\n\t * @returns {Boolean} - The flag which indicates if the carousel is busy.\n\t */\n\tOwl.prototype.is = function(state) {\n\t\treturn this._states.current[state] && this._states.current[state] > 0;\n\t};\n\n\t/**\n\t * Sets the absolute position of the current item.\n\t * @public\n\t * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n\t * @returns {Number} - The absolute position of the current item.\n\t */\n\tOwl.prototype.current = function(position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._current;\n\t\t}\n\n\t\tif (this._items.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tposition = this.normalize(position);\n\n\t\tif (this._current !== position) {\n\t\t\tvar event = this.trigger('change', { property: { name: 'position', value: position } });\n\n\t\t\tif (event.data !== undefined) {\n\t\t\t\tposition = this.normalize(event.data);\n\t\t\t}\n\n\t\t\tthis._current = position;\n\n\t\t\tthis.invalidate('position');\n\n\t\t\tthis.trigger('changed', { property: { name: 'position', value: this._current } });\n\t\t}\n\n\t\treturn this._current;\n\t};\n\n\t/**\n\t * Invalidates the given part of the update routine.\n\t * @param {String} [part] - The part to invalidate.\n\t * @returns {Array.<String>} - The invalidated parts.\n\t */\n\tOwl.prototype.invalidate = function(part) {\n\t\tif ($.type(part) === 'string') {\n\t\t\tthis._invalidated[part] = true;\n\t\t\tthis.is('valid') && this.leave('valid');\n\t\t}\n\t\treturn $.map(this._invalidated, function(v, i) { return i });\n\t};\n\n\t/**\n\t * Resets the absolute position of the current item.\n\t * @public\n\t * @param {Number} position - The absolute position of the new item.\n\t */\n\tOwl.prototype.reset = function(position) {\n\t\tposition = this.normalize(position);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._speed = 0;\n\t\tthis._current = position;\n\n\t\tthis.suppress([ 'translate', 'translated' ]);\n\n\t\tthis.animate(this.coordinates(position));\n\n\t\tthis.release([ 'translate', 'translated' ]);\n\t};\n\n\t/**\n\t * Normalizes an absolute or a relative position of an item.\n\t * @public\n\t * @param {Number} position - The absolute or relative position to normalize.\n\t * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n\t * @returns {Number} - The normalized position.\n\t */\n\tOwl.prototype.normalize = function(position, relative) {\n\t\tvar n = this._items.length,\n\t\t\tm = relative ? 0 : this._clones.length;\n\n\t\tif (!this.isNumeric(position) || n < 1) {\n\t\t\tposition = undefined;\n\t\t} else if (position < 0 || position >= n + m) {\n\t\t\tposition = ((position - m / 2) % n + n) % n + m / 2;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n\t * Converts an absolute position of an item into a relative one.\n\t * @public\n\t * @param {Number} position - The absolute position to convert.\n\t * @returns {Number} - The converted position.\n\t */\n\tOwl.prototype.relative = function(position) {\n\t\tposition -= this._clones.length / 2;\n\t\treturn this.normalize(position, true);\n\t};\n\n\t/**\n\t * Gets the maximum position for the current item.\n\t * @public\n\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n\t * @returns {Number}\n\t */\n\tOwl.prototype.maximum = function(relative) {\n\t\tvar settings = this.settings,\n\t\t\tmaximum = this._coordinates.length,\n\t\t\titerator,\n\t\t\treciprocalItemsWidth,\n\t\t\telementWidth;\n\n\t\tif (settings.loop) {\n\t\t\tmaximum = this._clones.length / 2 + this._items.length - 1;\n\t\t} else if (settings.autoWidth || settings.merge) {\n\t\t\titerator = this._items.length;\n\t\t\tif (iterator) {\n\t\t\t\treciprocalItemsWidth = this._items[--iterator].width();\n\t\t\t\telementWidth = this.$element.width();\n\t\t\t\twhile (iterator--) {\n\t\t\t\t\treciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\n\t\t\t\t\tif (reciprocalItemsWidth > elementWidth) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaximum = iterator + 1;\n\t\t} else if (settings.center) {\n\t\t\tmaximum = this._items.length - 1;\n\t\t} else {\n\t\t\tmaximum = this._items.length - settings.items;\n\t\t}\n\n\t\tif (relative) {\n\t\t\tmaximum -= this._clones.length / 2;\n\t\t}\n\n\t\treturn Math.max(maximum, 0);\n\t};\n\n\t/**\n\t * Gets the minimum position for the current item.\n\t * @public\n\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n\t * @returns {Number}\n\t */\n\tOwl.prototype.minimum = function(relative) {\n\t\treturn relative ? 0 : this._clones.length / 2;\n\t};\n\n\t/**\n\t * Gets an item at the specified relative position.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n\t */\n\tOwl.prototype.items = function(position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._items.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._items[position];\n\t};\n\n\t/**\n\t * Gets an item at the specified relative position.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n\t */\n\tOwl.prototype.mergers = function(position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._mergers.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._mergers[position];\n\t};\n\n\t/**\n\t * Gets the absolute positions of clones for an item.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n\t */\n\tOwl.prototype.clones = function(position) {\n\t\tvar odd = this._clones.length / 2,\n\t\t\teven = odd + this._items.length,\n\t\t\tmap = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._clones, function(v, i) { return map(i) });\n\t\t}\n\n\t\treturn $.map(this._clones, function(v, i) { return v === position ? map(i) : null });\n\t};\n\n\t/**\n\t * Sets the current animation speed.\n\t * @public\n\t * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n\t * @returns {Number} - The current animation speed in milliseconds.\n\t */\n\tOwl.prototype.speed = function(speed) {\n\t\tif (speed !== undefined) {\n\t\t\tthis._speed = speed;\n\t\t}\n\n\t\treturn this._speed;\n\t};\n\n\t/**\n\t * Gets the coordinate of an item.\n\t * @todo The name of this method is missleanding.\n\t * @public\n\t * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n\t * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n\t */\n\tOwl.prototype.coordinates = function(position) {\n\t\tvar multiplier = 1,\n\t\t\tnewPosition = position - 1,\n\t\t\tcoordinate;\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._coordinates, $.proxy(function(coordinate, index) {\n\t\t\t\treturn this.coordinates(index);\n\t\t\t}, this));\n\t\t}\n\n\t\tif (this.settings.center) {\n\t\t\tif (this.settings.rtl) {\n\t\t\t\tmultiplier = -1;\n\t\t\t\tnewPosition = position + 1;\n\t\t\t}\n\n\t\t\tcoordinate = this._coordinates[position];\n\t\t\tcoordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\n\t\t} else {\n\t\t\tcoordinate = this._coordinates[newPosition] || 0;\n\t\t}\n\n\t\tcoordinate = Math.ceil(coordinate);\n\n\t\treturn coordinate;\n\t};\n\n\t/**\n\t * Calculates the speed for a translation.\n\t * @protected\n\t * @param {Number} from - The absolute position of the start item.\n\t * @param {Number} to - The absolute position of the target item.\n\t * @param {Number} [factor=undefined] - The time factor in milliseconds.\n\t * @returns {Number} - The time in milliseconds for the translation.\n\t */\n\tOwl.prototype.duration = function(from, to, factor) {\n\t\tif (factor === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\n\t};\n\n\t/**\n\t * Slides to the specified item.\n\t * @public\n\t * @param {Number} position - The position of the item.\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n\tOwl.prototype.to = function(position, speed) {\n\t\tvar current = this.current(),\n\t\t\trevert = null,\n\t\t\tdistance = position - this.relative(current),\n\t\t\tdirection = (distance > 0) - (distance < 0),\n\t\t\titems = this._items.length,\n\t\t\tminimum = this.minimum(),\n\t\t\tmaximum = this.maximum();\n\n\t\tif (this.settings.loop) {\n\t\t\tif (!this.settings.rewind && Math.abs(distance) > items / 2) {\n\t\t\t\tdistance += direction * -1 * items;\n\t\t\t}\n\n\t\t\tposition = current + distance;\n\t\t\trevert = ((position - minimum) % items + items) % items + minimum;\n\n\t\t\tif (revert !== position && revert - distance <= maximum && revert - distance > 0) {\n\t\t\t\tcurrent = revert - distance;\n\t\t\t\tposition = revert;\n\t\t\t\tthis.reset(current);\n\t\t\t}\n\t\t} else if (this.settings.rewind) {\n\t\t\tmaximum += 1;\n\t\t\tposition = (position % maximum + maximum) % maximum;\n\t\t} else {\n\t\t\tposition = Math.max(minimum, Math.min(maximum, position));\n\t\t}\n\n\t\tthis.speed(this.duration(current, position, speed));\n\t\tthis.current(position);\n\n\t\tif (this.isVisible()) {\n\t\t\tthis.update();\n\t\t}\n\t};\n\n\t/**\n\t * Slides to the next item.\n\t * @public\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n\tOwl.prototype.next = function(speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) + 1, speed);\n\t};\n\n\t/**\n\t * Slides to the previous item.\n\t * @public\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n\tOwl.prototype.prev = function(speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) - 1, speed);\n\t};\n\n\t/**\n\t * Handles the end of an animation.\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onTransitionEnd = function(event) {\n\n\t\t// if css2 animation then event object is undefined\n\t\tif (event !== undefined) {\n\t\t\tevent.stopPropagation();\n\n\t\t\t// Catch only owl-stage transitionEnd event\n\t\t\tif ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.leave('animating');\n\t\tthis.trigger('translated');\n\t};\n\n\t/**\n\t * Gets viewport width.\n\t * @protected\n\t * @return {Number} - The width in pixel.\n\t */\n\tOwl.prototype.viewport = function() {\n\t\tvar width;\n\t\tif (this.options.responsiveBaseElement !== window) {\n\t\t\twidth = $(this.options.responsiveBaseElement).width();\n\t\t} else if (window.innerWidth) {\n\t\t\twidth = window.innerWidth;\n\t\t} else if (document.documentElement && document.documentElement.clientWidth) {\n\t\t\twidth = document.documentElement.clientWidth;\n\t\t} else {\n\t\t\tconsole.warn('Can not detect viewport width.');\n\t\t}\n\t\treturn width;\n\t};\n\n\t/**\n\t * Replaces the current content.\n\t * @public\n\t * @param {HTMLElement|jQuery|String} content - The new content.\n\t */\n\tOwl.prototype.replace = function(content) {\n\t\tthis.$stage.empty();\n\t\tthis._items = [];\n\n\t\tif (content) {\n\t\t\tcontent = (content instanceof jQuery) ? content : $(content);\n\t\t}\n\n\t\tif (this.settings.nestedItemSelector) {\n\t\t\tcontent = content.find('.' + this.settings.nestedItemSelector);\n\t\t}\n\n\t\tcontent.filter(function() {\n\t\t\treturn this.nodeType === 1;\n\t\t}).each($.proxy(function(index, item) {\n\t\t\titem = this.prepare(item);\n\t\t\tthis.$stage.append(item);\n\t\t\tthis._items.push(item);\n\t\t\tthis._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}, this));\n\n\t\tthis.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n\t\tthis.invalidate('items');\n\t};\n\n\t/**\n\t * Adds an item.\n\t * @todo Use `item` instead of `content` for the event arguments.\n\t * @public\n\t * @param {HTMLElement|jQuery|String} content - The item content to add.\n\t * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n\t */\n\tOwl.prototype.add = function(content, position) {\n\t\tvar current = this.relative(this._current);\n\n\t\tposition = position === undefined ? this._items.length : this.normalize(position, true);\n\t\tcontent = content instanceof jQuery ? content : $(content);\n\n\t\tthis.trigger('add', { content: content, position: position });\n\n\t\tcontent = this.prepare(content);\n\n\t\tif (this._items.length === 0 || position === this._items.length) {\n\t\t\tthis._items.length === 0 && this.$stage.append(content);\n\t\t\tthis._items.length !== 0 && this._items[position - 1].after(content);\n\t\t\tthis._items.push(content);\n\t\t\tthis._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t} else {\n\t\t\tthis._items[position].before(content);\n\t\t\tthis._items.splice(position, 0, content);\n\t\t\tthis._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}\n\n\t\tthis._items[current] && this.reset(this._items[current].index());\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('added', { content: content, position: position });\n\t};\n\n\t/**\n\t * Removes an item by its position.\n\t * @todo Use `item` instead of `content` for the event arguments.\n\t * @public\n\t * @param {Number} position - The relative position of the item to remove.\n\t */\n\tOwl.prototype.remove = function(position) {\n\t\tposition = this.normalize(position, true);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trigger('remove', { content: this._items[position], position: position });\n\n\t\tthis._items[position].remove();\n\t\tthis._items.splice(position, 1);\n\t\tthis._mergers.splice(position, 1);\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('removed', { content: null, position: position });\n\t};\n\n\t/**\n\t * Preloads images with auto width.\n\t * @todo Replace by a more generic approach\n\t * @protected\n\t */\n\tOwl.prototype.preloadAutoWidthImages = function(images) {\n\t\timages.each($.proxy(function(i, element) {\n\t\t\tthis.enter('pre-loading');\n\t\t\telement = $(element);\n\t\t\t$(new Image()).one('load', $.proxy(function(e) {\n\t\t\t\telement.attr('src', e.target.src);\n\t\t\t\telement.css('opacity', 1);\n\t\t\t\tthis.leave('pre-loading');\n\t\t\t\t!this.is('pre-loading') && !this.is('initializing') && this.refresh();\n\t\t\t}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\n\t\t}, this));\n\t};\n\n\t/**\n\t * Destroys the carousel.\n\t * @public\n\t */\n\tOwl.prototype.destroy = function() {\n\n\t\tthis.$element.off('.owl.core');\n\t\tthis.$stage.off('.owl.core');\n\t\t$(document).off('.owl.core');\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\twindow.clearTimeout(this.resizeTimer);\n\t\t\tthis.off(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tfor (var i in this._plugins) {\n\t\t\tthis._plugins[i].destroy();\n\t\t}\n\n\t\tthis.$stage.children('.cloned').remove();\n\n\t\tthis.$stage.unwrap();\n\t\tthis.$stage.children().contents().unwrap();\n\t\tthis.$stage.children().unwrap();\n\t\tthis.$stage.remove();\n\t\tthis.$element\n\t\t\t.removeClass(this.options.refreshClass)\n\t\t\t.removeClass(this.options.loadingClass)\n\t\t\t.removeClass(this.options.loadedClass)\n\t\t\t.removeClass(this.options.rtlClass)\n\t\t\t.removeClass(this.options.dragClass)\n\t\t\t.removeClass(this.options.grabClass)\n\t\t\t.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), ''))\n\t\t\t.removeData('owl.carousel');\n\t};\n\n\t/**\n\t * Operators to calculate right-to-left and left-to-right.\n\t * @protected\n\t * @param {Number} [a] - The left side operand.\n\t * @param {String} [o] - The operator.\n\t * @param {Number} [b] - The right side operand.\n\t */\n\tOwl.prototype.op = function(a, o, b) {\n\t\tvar rtl = this.settings.rtl;\n\t\tswitch (o) {\n\t\t\tcase '<':\n\t\t\t\treturn rtl ? a > b : a < b;\n\t\t\tcase '>':\n\t\t\t\treturn rtl ? a < b : a > b;\n\t\t\tcase '>=':\n\t\t\t\treturn rtl ? a <= b : a >= b;\n\t\t\tcase '<=':\n\t\t\t\treturn rtl ? a >= b : a <= b;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * Attaches to an internal event.\n\t * @protected\n\t * @param {HTMLElement} element - The event source.\n\t * @param {String} event - The event name.\n\t * @param {Function} listener - The event handler to attach.\n\t * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n\t */\n\tOwl.prototype.on = function(element, event, listener, capture) {\n\t\tif (element.addEventListener) {\n\t\t\telement.addEventListener(event, listener, capture);\n\t\t} else if (element.attachEvent) {\n\t\t\telement.attachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n\t * Detaches from an internal event.\n\t * @protected\n\t * @param {HTMLElement} element - The event source.\n\t * @param {String} event - The event name.\n\t * @param {Function} listener - The attached event handler to detach.\n\t * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n\t */\n\tOwl.prototype.off = function(element, event, listener, capture) {\n\t\tif (element.removeEventListener) {\n\t\t\telement.removeEventListener(event, listener, capture);\n\t\t} else if (element.detachEvent) {\n\t\t\telement.detachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n\t * Triggers a public event.\n\t * @todo Remove `status`, `relatedTarget` should be used instead.\n\t * @protected\n\t * @param {String} name - The event name.\n\t * @param {*} [data=null] - The event data.\n\t * @param {String} [namespace=carousel] - The event namespace.\n\t * @param {String} [state] - The state which is associated with the event.\n\t * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n\t * @returns {Event} - The event arguments.\n\t */\n\tOwl.prototype.trigger = function(name, data, namespace, state, enter) {\n\t\tvar status = {\n\t\t\titem: { count: this._items.length, index: this.current() }\n\t\t}, handler = $.camelCase(\n\t\t\t$.grep([ 'on', name, namespace ], function(v) { return v })\n\t\t\t\t.join('-').toLowerCase()\n\t\t), event = $.Event(\n\t\t\t[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),\n\t\t\t$.extend({ relatedTarget: this }, status, data)\n\t\t);\n\n\t\tif (!this._supress[name]) {\n\t\t\t$.each(this._plugins, function(name, plugin) {\n\t\t\t\tif (plugin.onTrigger) {\n\t\t\t\t\tplugin.onTrigger(event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.register({ type: Owl.Type.Event, name: name });\n\t\t\tthis.$element.trigger(event);\n\n\t\t\tif (this.settings && typeof this.settings[handler] === 'function') {\n\t\t\t\tthis.settings[handler].call(this, event);\n\t\t\t}\n\t\t}\n\n\t\treturn event;\n\t};\n\n\t/**\n\t * Enters a state.\n\t * @param name - The state name.\n\t */\n\tOwl.prototype.enter = function(name) {\n\t\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n\t\t\tif (this._states.current[name] === undefined) {\n\t\t\t\tthis._states.current[name] = 0;\n\t\t\t}\n\n\t\t\tthis._states.current[name]++;\n\t\t}, this));\n\t};\n\n\t/**\n\t * Leaves a state.\n\t * @param name - The state name.\n\t */\n\tOwl.prototype.leave = function(name) {\n\t\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n\t\t\tthis._states.current[name]--;\n\t\t}, this));\n\t};\n\n\t/**\n\t * Registers an event or state.\n\t * @public\n\t * @param {Object} object - The event or state to register.\n\t */\n\tOwl.prototype.register = function(object) {\n\t\tif (object.type === Owl.Type.Event) {\n\t\t\tif (!$.event.special[object.name]) {\n\t\t\t\t$.event.special[object.name] = {};\n\t\t\t}\n\n\t\t\tif (!$.event.special[object.name].owl) {\n\t\t\t\tvar _default = $.event.special[object.name]._default;\n\t\t\t\t$.event.special[object.name]._default = function(e) {\n\t\t\t\t\tif (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\n\t\t\t\t\t\treturn _default.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t\treturn e.namespace && e.namespace.indexOf('owl') > -1;\n\t\t\t\t};\n\t\t\t\t$.event.special[object.name].owl = true;\n\t\t\t}\n\t\t} else if (object.type === Owl.Type.State) {\n\t\t\tif (!this._states.tags[object.name]) {\n\t\t\t\tthis._states.tags[object.name] = object.tags;\n\t\t\t} else {\n\t\t\t\tthis._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\n\t\t\t}\n\n\t\t\tthis._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {\n\t\t\t\treturn $.inArray(tag, this._states.tags[object.name]) === i;\n\t\t\t}, this));\n\t\t}\n\t};\n\n\t/**\n\t * Suppresses events.\n\t * @protected\n\t * @param {Array.<String>} events - The events to suppress.\n\t */\n\tOwl.prototype.suppress = function(events) {\n\t\t$.each(events, $.proxy(function(index, event) {\n\t\t\tthis._supress[event] = true;\n\t\t}, this));\n\t};\n\n\t/**\n\t * Releases suppressed events.\n\t * @protected\n\t * @param {Array.<String>} events - The events to release.\n\t */\n\tOwl.prototype.release = function(events) {\n\t\t$.each(events, $.proxy(function(index, event) {\n\t\t\tdelete this._supress[event];\n\t\t}, this));\n\t};\n\n\t/**\n\t * Gets unified pointer coordinates from event.\n\t * @todo #261\n\t * @protected\n\t * @param {Event} - The `mousedown` or `touchstart` event.\n\t * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n\t */\n\tOwl.prototype.pointer = function(event) {\n\t\tvar result = { x: null, y: null };\n\n\t\tevent = event.originalEvent || event || window.event;\n\n\t\tevent = event.touches && event.touches.length ?\n\t\t\tevent.touches[0] : event.changedTouches && event.changedTouches.length ?\n\t\t\t\tevent.changedTouches[0] : event;\n\n\t\tif (event.pageX) {\n\t\t\tresult.x = event.pageX;\n\t\t\tresult.y = event.pageY;\n\t\t} else {\n\t\t\tresult.x = event.clientX;\n\t\t\tresult.y = event.clientY;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * Determines if the input is a Number or something that can be coerced to a Number\n\t * @protected\n\t * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n\t * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n\t */\n\tOwl.prototype.isNumeric = function(number) {\n\t\treturn !isNaN(parseFloat(number));\n\t};\n\n\t/**\n\t * Gets the difference of two vectors.\n\t * @todo #261\n\t * @protected\n\t * @param {Object} - The first vector.\n\t * @param {Object} - The second vector.\n\t * @returns {Object} - The difference.\n\t */\n\tOwl.prototype.difference = function(first, second) {\n\t\treturn {\n\t\t\tx: first.x - second.x,\n\t\t\ty: first.y - second.y\n\t\t};\n\t};\n\n\t/**\n\t * The jQuery Plugin for the Owl Carousel\n\t * @todo Navigation plugin `next` and `prev`\n\t * @public\n\t */\n\t$.fn.owlCarousel = function(option) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\t\treturn this.each(function() {\n\t\t\tvar $this = $(this),\n\t\t\t\tdata = $this.data('owl.carousel');\n\n\t\t\tif (!data) {\n\t\t\t\tdata = new Owl(this, typeof option == 'object' && option);\n\t\t\t\t$this.data('owl.carousel', data);\n\n\t\t\t\t$.each([\n\t\t\t\t\t'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'\n\t\t\t\t], function(i, event) {\n\t\t\t\t\tdata.register({ type: Owl.Type.Event, name: event });\n\t\t\t\t\tdata.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {\n\t\t\t\t\t\tif (e.namespace && e.relatedTarget !== this) {\n\t\t\t\t\t\t\tthis.suppress([ event ]);\n\t\t\t\t\t\t\tdata[event].apply(this, [].slice.call(arguments, 1));\n\t\t\t\t\t\t\tthis.release([ event ]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, data));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof option == 'string' && option.charAt(0) !== '_') {\n\t\t\t\tdata[option].apply(data, args);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * The constructor for the jQuery Plugin\n\t * @public\n\t */\n\t$.fn.owlCarousel.Constructor = Owl;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoRefresh Plugin\n * @version 2.3.4\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the auto refresh plugin.\n\t * @class The Auto Refresh Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar AutoRefresh = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Refresh interval.\n\t\t * @protected\n\t\t * @type {number}\n\t\t */\n\t\tthis._interval = null;\n\n\t\t/**\n\t\t * Whether the element is currently visible or not.\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._visible = null;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoRefresh) {\n\t\t\t\t\tthis.watch();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAutoRefresh.Defaults = {\n\t\tautoRefresh: true,\n\t\tautoRefreshInterval: 500\n\t};\n\n\t/**\n\t * Watches the element.\n\t */\n\tAutoRefresh.prototype.watch = function() {\n\t\tif (this._interval) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = this._core.isVisible();\n\t\tthis._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\n\t};\n\n\t/**\n\t * Refreshes the element.\n\t */\n\tAutoRefresh.prototype.refresh = function() {\n\t\tif (this._core.isVisible() === this._visible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = !this._visible;\n\n\t\tthis._core.$element.toggleClass('owl-hidden', !this._visible);\n\n\t\tthis._visible && (this._core.invalidate('width') && this._core.refresh());\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t */\n\tAutoRefresh.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\twindow.clearInterval(this._interval);\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Lazy Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the lazy plugin.\n\t * @class The Lazy Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar Lazy = function(carousel) {\n\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Already loaded items.\n\t\t * @protected\n\t\t * @type {Array.<jQuery>}\n\t\t */\n\t\tthis._loaded = [];\n\n\t\t/**\n\t\t * Event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this._core.settings || !this._core.settings.lazyLoad) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ((e.property && e.property.name == 'position') || e.type == 'initialized') {\n\t\t\t\t\tvar settings = this._core.settings,\n\t\t\t\t\t\tn = (settings.center && Math.ceil(settings.items / 2) || settings.items),\n\t\t\t\t\t\ti = ((settings.center && n * -1) || 0),\n\t\t\t\t\t\tposition = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\n\t\t\t\t\t\tclones = this._core.clones().length,\n\t\t\t\t\t\tload = $.proxy(function(i, v) { this.load(v) }, this);\n\t\t\t\t\t//TODO: Need documentation for this new option\n\t\t\t\t\tif (settings.lazyLoadEager > 0) {\n\t\t\t\t\t\tn += settings.lazyLoadEager;\n\t\t\t\t\t\t// If the carousel is looping also preload images that are to the \"left\"\n\t\t\t\t\t\tif (settings.loop) {\n              position -= settings.lazyLoadEager;\n              n++;\n            }\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (i++ < n) {\n\t\t\t\t\t\tthis.load(clones / 2 + this._core.relative(position));\n\t\t\t\t\t\tclones && $.each(this._core.clones(this._core.relative(position)), load);\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set the default options\n\t\tthis._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n\t\t// register event handler\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tLazy.Defaults = {\n\t\tlazyLoad: false,\n\t\tlazyLoadEager: 0\n\t};\n\n\t/**\n\t * Loads all resources of an item at the specified position.\n\t * @param {Number} position - The absolute position of the item.\n\t * @protected\n\t */\n\tLazy.prototype.load = function(position) {\n\t\tvar $item = this._core.$stage.children().eq(position),\n\t\t\t$elements = $item && $item.find('.owl-lazy');\n\n\t\tif (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n\t\t\treturn;\n\t\t}\n\n\t\t$elements.each($.proxy(function(index, element) {\n\t\t\tvar $element = $(element), image,\n                url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');\n\n\t\t\tthis._core.trigger('load', { element: $element, url: url }, 'lazy');\n\n\t\t\tif ($element.is('img')) {\n\t\t\t\t$element.one('load.owl.lazy', $.proxy(function() {\n\t\t\t\t\t$element.css('opacity', 1);\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this)).attr('src', url);\n            } else if ($element.is('source')) {\n                $element.one('load.owl.lazy', $.proxy(function() {\n                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n                }, this)).attr('srcset', url);\n\t\t\t} else {\n\t\t\t\timage = new Image();\n\t\t\t\timage.onload = $.proxy(function() {\n\t\t\t\t\t$element.css({\n\t\t\t\t\t\t'background-image': 'url(\"' + url + '\")',\n\t\t\t\t\t\t'opacity': '1'\n\t\t\t\t\t});\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this);\n\t\t\t\timage.src = url;\n\t\t\t}\n\t\t}, this));\n\n\t\tthis._loaded.push($item.get(0));\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @public\n\t */\n\tLazy.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis._core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoHeight Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the auto height plugin.\n\t * @class The Auto Height Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar AutoHeight = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\tthis._previousHeight = null;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight && e.property.name === 'position'){\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'loaded.owl.lazy': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight\n\t\t\t\t\t&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t\tthis._intervalId = null;\n\t\tvar refThis = this;\n\n\t\t// These changes have been taken from a PR by gavrochelegnou proposed in #1575\n\t\t// and have been made compatible with the latest jQuery version\n\t\t$(window).on('load', function() {\n\t\t\tif (refThis._core.settings.autoHeight) {\n\t\t\t\trefThis.update();\n\t\t\t}\n\t\t});\n\n\t\t// Autoresize the height of the carousel when window is resized\n\t\t// When carousel has images, the height is dependent on the width\n\t\t// and should also change on resize\n\t\t$(window).resize(function() {\n\t\t\tif (refThis._core.settings.autoHeight) {\n\t\t\t\tif (refThis._intervalId != null) {\n\t\t\t\t\tclearTimeout(refThis._intervalId);\n\t\t\t\t}\n\n\t\t\t\trefThis._intervalId = setTimeout(function() {\n\t\t\t\t\trefThis.update();\n\t\t\t\t}, 250);\n\t\t\t}\n\t\t});\n\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAutoHeight.Defaults = {\n\t\tautoHeight: false,\n\t\tautoHeightClass: 'owl-height'\n\t};\n\n\t/**\n\t * Updates the view.\n\t */\n\tAutoHeight.prototype.update = function() {\n\t\tvar start = this._core._current,\n\t\t\tend = start + this._core.settings.items,\n\t\t\tlazyLoadEnabled = this._core.settings.lazyLoad,\n\t\t\tvisible = this._core.$stage.children().toArray().slice(start, end),\n\t\t\theights = [],\n\t\t\tmaxheight = 0;\n\n\t\t$.each(visible, function(index, item) {\n\t\t\theights.push($(item).height());\n\t\t});\n\n\t\tmaxheight = Math.max.apply(null, heights);\n\n\t\tif (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {\n\t\t\tmaxheight = this._previousHeight;\n\t\t}\n\n\t\tthis._previousHeight = maxheight;\n\n\t\tthis._core.$stage.parent()\n\t\t\t.height(maxheight)\n\t\t\t.addClass(this._core.settings.autoHeightClass);\n\t};\n\n\tAutoHeight.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] !== 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Video Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the video plugin.\n\t * @class The Video Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar Video = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Cache all video URLs.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._videos = {};\n\n\t\t/**\n\t\t * Current playing item.\n\t\t * @protected\n\t\t * @type {jQuery}\n\t\t */\n\t\tthis._playing = null;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @todo The cloned content removale is too late\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'resize.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.video && this.isInFullScreen()) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.is('resizing')) {\n\t\t\t\t\tthis._core.$stage.find('.cloned .owl-video-frame').remove();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position' && this._playing) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar $element = $(e.content).find('.owl-video');\n\n\t\t\t\tif ($element.length) {\n\t\t\t\t\t$element.css('display', 'none');\n\t\t\t\t\tthis.fetch($element, $(e.content));\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\tthis._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {\n\t\t\tthis.play(e);\n\t\t}, this));\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tVideo.Defaults = {\n\t\tvideo: false,\n\t\tvideoHeight: false,\n\t\tvideoWidth: false\n\t};\n\n\t/**\n\t * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n\t * @protected\n\t * @param {jQuery} target - The target containing the video data.\n\t * @param {jQuery} item - The item containing the video.\n\t */\n\tVideo.prototype.fetch = function(target, item) {\n\t\t\tvar type = (function() {\n\t\t\t\t\tif (target.attr('data-vimeo-id')) {\n\t\t\t\t\t\treturn 'vimeo';\n\t\t\t\t\t} else if (target.attr('data-vzaar-id')) {\n\t\t\t\t\t\treturn 'vzaar'\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 'youtube';\n\t\t\t\t\t}\n\t\t\t\t})(),\n\t\t\t\tid = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\n\t\t\t\twidth = target.attr('data-width') || this._core.settings.videoWidth,\n\t\t\t\theight = target.attr('data-height') || this._core.settings.videoHeight,\n\t\t\t\turl = target.attr('href');\n\n\t\tif (url) {\n\n\t\t\t/*\n\t\t\t\t\tParses the id's out of the following urls (and probably more):\n\t\t\t\t\thttps://www.youtube.com/watch?v=:id\n\t\t\t\t\thttps://youtu.be/:id\n\t\t\t\t\thttps://vimeo.com/:id\n\t\t\t\t\thttps://vimeo.com/channels/:channel/:id\n\t\t\t\t\thttps://vimeo.com/groups/:group/videos/:id\n\t\t\t\t\thttps://app.vzaar.com/videos/:id\n\n\t\t\t\t\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n\t\t\t*/\n\n\t\t\tid = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com|be\\-nocookie\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n\t\t\tif (id[3].indexOf('youtu') > -1) {\n\t\t\t\ttype = 'youtube';\n\t\t\t} else if (id[3].indexOf('vimeo') > -1) {\n\t\t\t\ttype = 'vimeo';\n\t\t\t} else if (id[3].indexOf('vzaar') > -1) {\n\t\t\t\ttype = 'vzaar';\n\t\t\t} else {\n\t\t\t\tthrow new Error('Video URL not supported.');\n\t\t\t}\n\t\t\tid = id[6];\n\t\t} else {\n\t\t\tthrow new Error('Missing video URL.');\n\t\t}\n\n\t\tthis._videos[url] = {\n\t\t\ttype: type,\n\t\t\tid: id,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\titem.attr('data-video', url);\n\n\t\tthis.thumbnail(target, this._videos[url]);\n\t};\n\n\t/**\n\t * Creates video thumbnail.\n\t * @protected\n\t * @param {jQuery} target - The target containing the video data.\n\t * @param {Object} info - The video info object.\n\t * @see `fetch`\n\t */\n\tVideo.prototype.thumbnail = function(target, video) {\n\t\tvar tnLink,\n\t\t\ticon,\n\t\t\tpath,\n\t\t\tdimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',\n\t\t\tcustomTn = target.find('img'),\n\t\t\tsrcType = 'src',\n\t\t\tlazyClass = '',\n\t\t\tsettings = this._core.settings,\n\t\t\tcreate = function(path) {\n\t\t\t\ticon = '<div class=\"owl-video-play-icon\"></div>';\n\n\t\t\t\tif (settings.lazyLoad) {\n\t\t\t\t\ttnLink = $('<div/>',{\n\t\t\t\t\t\t\"class\": 'owl-video-tn ' + lazyClass,\n\t\t\t\t\t\t\"srcType\": path\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttnLink = $( '<div/>', {\n\t\t\t\t\t\t\"class\": \"owl-video-tn\",\n\t\t\t\t\t\t\"style\": 'opacity:1;background-image:url(' + path + ')'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\ttarget.after(tnLink);\n\t\t\t\ttarget.after(icon);\n\t\t\t};\n\n\t\t// wrap video content into owl-video-wrapper div\n\t\ttarget.wrap( $( '<div/>', {\n\t\t\t\"class\": \"owl-video-wrapper\",\n\t\t\t\"style\": dimensions\n\t\t}));\n\n\t\tif (this._core.settings.lazyLoad) {\n\t\t\tsrcType = 'data-src';\n\t\t\tlazyClass = 'owl-lazy';\n\t\t}\n\n\t\t// custom thumbnail\n\t\tif (customTn.length) {\n\t\t\tcreate(customTn.attr(srcType));\n\t\t\tcustomTn.remove();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (video.type === 'youtube') {\n\t\t\tpath = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n\t\t\tcreate(path);\n\t\t} else if (video.type === 'vimeo') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vimeo.com/api/v2/video/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function(data) {\n\t\t\t\t\tpath = data[0].thumbnail_large;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (video.type === 'vzaar') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vzaar.com/api/videos/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function(data) {\n\t\t\t\t\tpath = data.framegrab_url;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Stops the current video.\n\t * @public\n\t */\n\tVideo.prototype.stop = function() {\n\t\tthis._core.trigger('stop', null, 'video');\n\t\tthis._playing.find('.owl-video-frame').remove();\n\t\tthis._playing.removeClass('owl-video-playing');\n\t\tthis._playing = null;\n\t\tthis._core.leave('playing');\n\t\tthis._core.trigger('stopped', null, 'video');\n\t};\n\n\t/**\n\t * Starts the current video.\n\t * @public\n\t * @param {Event} event - The event arguments.\n\t */\n\tVideo.prototype.play = function(event) {\n\t\tvar target = $(event.target),\n\t\t\titem = target.closest('.' + this._core.settings.itemClass),\n\t\t\tvideo = this._videos[item.attr('data-video')],\n\t\t\twidth = video.width || '100%',\n\t\t\theight = video.height || this._core.$stage.height(),\n\t\t\thtml,\n\t\t\tiframe;\n\n\t\tif (this._playing) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._core.enter('playing');\n\t\tthis._core.trigger('play', null, 'video');\n\n\t\titem = this._core.items(this._core.relative(item.index()));\n\n\t\tthis._core.reset(item.index());\n\n\t\thtml = $( '<iframe frameborder=\"0\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>' );\n\t\thtml.attr( 'height', height );\n\t\thtml.attr( 'width', width );\n\t\tif (video.type === 'youtube') {\n\t\t\thtml.attr( 'src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id );\n\t\t} else if (video.type === 'vimeo') {\n\t\t\thtml.attr( 'src', '//player.vimeo.com/video/' + video.id + '?autoplay=1' );\n\t\t} else if (video.type === 'vzaar') {\n\t\t\thtml.attr( 'src', '//view.vzaar.com/' + video.id + '/player?autoplay=true' );\n\t\t}\n\n\t\tiframe = $(html).wrap( '<div class=\"owl-video-frame\" />' ).insertAfter(item.find('.owl-video'));\n\n\t\tthis._playing = item.addClass('owl-video-playing');\n\t};\n\n\t/**\n\t * Checks whether an video is currently in full screen mode or not.\n\t * @todo Bad style because looks like a readonly method but changes members.\n\t * @protected\n\t * @returns {Boolean}\n\t */\n\tVideo.prototype.isInFullScreen = function() {\n\t\tvar element = document.fullscreenElement || document.mozFullScreenElement ||\n\t\t\t\tdocument.webkitFullscreenElement;\n\n\t\treturn element && $(element).parent().hasClass('owl-video-frame');\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t */\n\tVideo.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tthis._core.$element.off('click.owl.video');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Video = Video;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Animate Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the animate plugin.\n\t * @class The Navigation Plugin\n\t * @param {Owl} scope - The Owl Carousel\n\t */\n\tvar Animate = function(scope) {\n\t\tthis.core = scope;\n\t\tthis.core.options = $.extend({}, Animate.Defaults, this.core.options);\n\t\tthis.swapping = true;\n\t\tthis.previous = undefined;\n\t\tthis.next = undefined;\n\n\t\tthis.handlers = {\n\t\t\t'change.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.previous = this.core.current();\n\t\t\t\t\tthis.next = e.property.value;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.swapping = e.type == 'translated';\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'translate.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n\t\t\t\t\tthis.swap();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\tthis.core.$element.on(this.handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAnimate.Defaults = {\n\t\tanimateOut: false,\n\t\tanimateIn: false\n\t};\n\n\t/**\n\t * Toggles the animation classes whenever an translations starts.\n\t * @protected\n\t * @returns {Boolean|undefined}\n\t */\n\tAnimate.prototype.swap = function() {\n\n\t\tif (this.core.settings.items !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!$.support.animation || !$.support.transition) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.core.speed(0);\n\n\t\tvar left,\n\t\t\tclear = $.proxy(this.clear, this),\n\t\t\tprevious = this.core.$stage.children().eq(this.previous),\n\t\t\tnext = this.core.$stage.children().eq(this.next),\n\t\t\tincoming = this.core.settings.animateIn,\n\t\t\toutgoing = this.core.settings.animateOut;\n\n\t\tif (this.core.current() === this.previous) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (outgoing) {\n\t\t\tleft = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n\t\t\tprevious.one($.support.animation.end, clear)\n\t\t\t\t.css( { 'left': left + 'px' } )\n\t\t\t\t.addClass('animated owl-animated-out')\n\t\t\t\t.addClass(outgoing);\n\t\t}\n\n\t\tif (incoming) {\n\t\t\tnext.one($.support.animation.end, clear)\n\t\t\t\t.addClass('animated owl-animated-in')\n\t\t\t\t.addClass(incoming);\n\t\t}\n\t};\n\n\tAnimate.prototype.clear = function(e) {\n\t\t$(e.target).css( { 'left': '' } )\n\t\t\t.removeClass('animated owl-animated-out owl-animated-in')\n\t\t\t.removeClass(this.core.settings.animateIn)\n\t\t\t.removeClass(this.core.settings.animateOut);\n\t\tthis.core.onTransitionEnd();\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @public\n\t */\n\tAnimate.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis.core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Autoplay Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author Artus Kolanowski\n * @author David Deutsch\n * @author Tom De Caluw\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the autoplay plugin.\n\t * @class The Autoplay Plugin\n\t * @param {Owl} scope - The Owl Carousel\n\t */\n\tvar Autoplay = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * The autoplay timeout id.\n\t\t * @type {Number}\n\t\t */\n\t\tthis._call = null;\n\n\t\t/**\n\t\t * Depending on the state of the plugin, this variable contains either\n\t\t * the start time of the timer or the current timer value if it's\n\t\t * paused. Since we start in a paused state we initialize the timer\n\t\t * value.\n\t\t * @type {Number}\n\t\t */\n\t\tthis._time = 0;\n\n\t\t/**\n\t\t * Stores the timeout currently used.\n\t\t * @type {Number}\n\t\t */\n\t\tthis._timeout = 0;\n\n\t\t/**\n\t\t * Indicates whenever the autoplay is paused.\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._paused = true;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name === 'settings') {\n\t\t\t\t\tif (this._core.settings.autoplay) {\n\t\t\t\t\t\tthis.play();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t}\n\t\t\t\t} else if (e.namespace && e.property.name === 'position' && this._paused) {\n\t\t\t\t\t// Reset the timer. This code is triggered when the position\n\t\t\t\t\t// of the carousel was changed through user interaction.\n\t\t\t\t\tthis._time = 0;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoplay) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'play.owl.autoplay': $.proxy(function(e, t, s) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.play(t, s);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'stop.owl.autoplay': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseover.owl.autoplay': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseleave.owl.autoplay': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchstart.owl.core': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchend.owl.core': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAutoplay.Defaults = {\n\t\tautoplay: false,\n\t\tautoplayTimeout: 5000,\n\t\tautoplayHoverPause: false,\n\t\tautoplaySpeed: false\n\t};\n\n\t/**\n\t * Transition to the next slide and set a timeout for the next transition.\n\t * @private\n\t * @param {Number} [speed] - The animation speed for the animations.\n\t */\n\tAutoplay.prototype._next = function(speed) {\n\t\tthis._call = window.setTimeout(\n\t\t\t$.proxy(this._next, this, speed),\n\t\t\tthis._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()\n\t\t);\n\n\t\tif (this._core.is('interacting') || document.hidden) {\n\t\t\treturn;\n\t\t}\n\t\tthis._core.next(speed || this._core.settings.autoplaySpeed);\n\t}\n\n\t/**\n\t * Reads the current timer value when the timer is playing.\n\t * @public\n\t */\n\tAutoplay.prototype.read = function() {\n\t\treturn new Date().getTime() - this._time;\n\t};\n\n\t/**\n\t * Starts the autoplay.\n\t * @public\n\t * @param {Number} [timeout] - The interval before the next animation starts.\n\t * @param {Number} [speed] - The animation speed for the animations.\n\t */\n\tAutoplay.prototype.play = function(timeout, speed) {\n\t\tvar elapsed;\n\n\t\tif (!this._core.is('rotating')) {\n\t\t\tthis._core.enter('rotating');\n\t\t}\n\n\t\ttimeout = timeout || this._core.settings.autoplayTimeout;\n\n\t\t// Calculate the elapsed time since the last transition. If the carousel\n\t\t// wasn't playing this calculation will yield zero.\n\t\telapsed = Math.min(this._time % (this._timeout || timeout), timeout);\n\n\t\tif (this._paused) {\n\t\t\t// Start the clock.\n\t\t\tthis._time = this.read();\n\t\t\tthis._paused = false;\n\t\t} else {\n\t\t\t// Clear the active timeout to allow replacement.\n\t\t\twindow.clearTimeout(this._call);\n\t\t}\n\n\t\t// Adjust the origin of the timer to match the new timeout value.\n\t\tthis._time += this.read() % timeout - elapsed;\n\n\t\tthis._timeout = timeout;\n\t\tthis._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);\n\t};\n\n\t/**\n\t * Stops the autoplay.\n\t * @public\n\t */\n\tAutoplay.prototype.stop = function() {\n\t\tif (this._core.is('rotating')) {\n\t\t\t// Reset the clock.\n\t\t\tthis._time = 0;\n\t\t\tthis._paused = true;\n\n\t\t\twindow.clearTimeout(this._call);\n\t\t\tthis._core.leave('rotating');\n\t\t}\n\t};\n\n\t/**\n\t * Pauses the autoplay.\n\t * @public\n\t */\n\tAutoplay.prototype.pause = function() {\n\t\tif (this._core.is('rotating') && !this._paused) {\n\t\t\t// Pause the clock.\n\t\t\tthis._time = this.read();\n\t\t\tthis._paused = true;\n\n\t\t\twindow.clearTimeout(this._call);\n\t\t}\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t */\n\tAutoplay.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tthis.stop();\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Navigation Plugin\n * @version 2.3.4\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n\t * Creates the navigation plugin.\n\t * @class The Navigation Plugin\n\t * @param {Owl} carousel - The Owl Carousel.\n\t */\n\tvar Navigation = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Indicates whether the plugin is initialized or not.\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._initialized = false;\n\n\t\t/**\n\t\t * The current paging indexes.\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._pages = [];\n\n\t\t/**\n\t\t * All DOM elements of the user interface.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._controls = {};\n\n\t\t/**\n\t\t * Markup for an indicator.\n\t\t * @protected\n\t\t * @type {Array.<String>}\n\t\t */\n\t\tthis._templates = [];\n\n\t\t/**\n\t\t * The carousel element.\n\t\t * @type {jQuery}\n\t\t */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n\t\t * Overridden methods of the carousel.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._overrides = {\n\t\t\tnext: this._core.next,\n\t\t\tprev: this._core.prev,\n\t\t\tto: this._core.to\n\t\t};\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' +\n\t\t\t\t\t\t$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'added.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 0, this._templates.pop());\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'remove.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 1);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.draw();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && !this._initialized) {\n\t\t\t\t\tthis._core.trigger('initialize', null, 'navigation');\n\t\t\t\t\tthis.initialize();\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._initialized = true;\n\t\t\t\t\tthis._core.trigger('initialized', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._initialized) {\n\t\t\t\t\tthis._core.trigger('refresh', null, 'navigation');\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._core.trigger('refreshed', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t * @todo Rename `slideBy` to `navBy`\n\t */\n\tNavigation.Defaults = {\n\t\tnav: false,\n\t\tnavText: [\n\t\t\t'<span aria-label=\"' + 'Previous' + '\">&#x2039;</span>',\n\t\t\t'<span aria-label=\"' + 'Next' + '\">&#x203a;</span>'\n\t\t],\n\t\tnavSpeed: false,\n\t\tnavElement: 'button type=\"button\" role=\"presentation\"',\n\t\tnavContainer: false,\n\t\tnavContainerClass: 'owl-nav',\n\t\tnavClass: [\n\t\t\t'owl-prev',\n\t\t\t'owl-next'\n\t\t],\n\t\tslideBy: 1,\n\t\tdotClass: 'owl-dot',\n\t\tdotsClass: 'owl-dots',\n\t\tdots: true,\n\t\tdotsEach: false,\n\t\tdotsData: false,\n\t\tdotsSpeed: false,\n\t\tdotsContainer: false\n\t};\n\n\t/**\n\t * Initializes the layout of the plugin and extends the carousel.\n\t * @protected\n\t */\n\tNavigation.prototype.initialize = function() {\n\t\tvar override,\n\t\t\tsettings = this._core.settings;\n\n\t\t// create DOM structure for relative navigation\n\t\tthis._controls.$relative = (settings.navContainer ? $(settings.navContainer)\n\t\t\t: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$previous = $('<' + settings.navElement + '>')\n\t\t\t.addClass(settings.navClass[0])\n\t\t\t.html(settings.navText[0])\n\t\t\t.prependTo(this._controls.$relative)\n\t\t\t.on('click', $.proxy(function(e) {\n\t\t\t\tthis.prev(settings.navSpeed);\n\t\t\t}, this));\n\t\tthis._controls.$next = $('<' + settings.navElement + '>')\n\t\t\t.addClass(settings.navClass[1])\n\t\t\t.html(settings.navText[1])\n\t\t\t.appendTo(this._controls.$relative)\n\t\t\t.on('click', $.proxy(function(e) {\n\t\t\t\tthis.next(settings.navSpeed);\n\t\t\t}, this));\n\n\t\t// create DOM structure for absolute navigation\n\t\tif (!settings.dotsData) {\n\t\t\tthis._templates = [ $('<button role=\"button\">')\n\t\t\t\t.addClass(settings.dotClass)\n\t\t\t\t.append($('<span>'))\n\t\t\t\t.prop('outerHTML') ];\n\t\t}\n\n\t\tthis._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)\n\t\t\t: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$absolute.on('click', 'button', $.proxy(function(e) {\n\t\t\tvar index = $(e.target).parent().is(this._controls.$absolute)\n\t\t\t\t? $(e.target).index() : $(e.target).parent().index();\n\n\t\t\te.preventDefault();\n\n\t\t\tthis.to(index, settings.dotsSpeed);\n\t\t}, this));\n\n\t\t/*$el.on('focusin', function() {\n\t\t\t$(document).off(\".carousel\");\n\n\t\t\t$(document).on('keydown.carousel', function(e) {\n\t\t\t\tif(e.keyCode == 37) {\n\t\t\t\t\t$el.trigger('prev.owl')\n\t\t\t\t}\n\t\t\t\tif(e.keyCode == 39) {\n\t\t\t\t\t$el.trigger('next.owl')\n\t\t\t\t}\n\t\t\t});\n\t\t});*/\n\n\t\t// override public methods of the carousel\n\t\tfor (override in this._overrides) {\n\t\t\tthis._core[override] = $.proxy(this[override], this);\n\t\t}\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @protected\n\t */\n\tNavigation.prototype.destroy = function() {\n\t\tvar handler, control, property, override, settings;\n\t\tsettings = this._core.settings;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (control in this._controls) {\n\t\t\tif (control === '$relative' && settings.navContainer) {\n\t\t\t\tthis._controls[control].html('');\n\t\t\t} else {\n\t\t\t\tthis._controls[control].remove();\n\t\t\t}\n\t\t}\n\t\tfor (override in this.overides) {\n\t\t\tthis._core[override] = this._overrides[override];\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t/**\n\t * Updates the internal state.\n\t * @protected\n\t */\n\tNavigation.prototype.update = function() {\n\t\tvar i, j, k,\n\t\t\tlower = this._core.clones().length / 2,\n\t\t\tupper = lower + this._core.items().length,\n\t\t\tmaximum = this._core.maximum(true),\n\t\t\tsettings = this._core.settings,\n\t\t\tsize = settings.center || settings.autoWidth || settings.dotsData\n\t\t\t\t? 1 : settings.dotsEach || settings.items;\n\n\t\tif (settings.slideBy !== 'page') {\n\t\t\tsettings.slideBy = Math.min(settings.slideBy, settings.items);\n\t\t}\n\n\t\tif (settings.dots || settings.slideBy == 'page') {\n\t\t\tthis._pages = [];\n\n\t\t\tfor (i = lower, j = 0, k = 0; i < upper; i++) {\n\t\t\t\tif (j >= size || j === 0) {\n\t\t\t\t\tthis._pages.push({\n\t\t\t\t\t\tstart: Math.min(maximum, i - lower),\n\t\t\t\t\t\tend: i - lower + size - 1\n\t\t\t\t\t});\n\t\t\t\t\tif (Math.min(maximum, i - lower) === maximum) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj = 0, ++k;\n\t\t\t\t}\n\t\t\t\tj += this._core.mergers(this._core.relative(i));\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Draws the user interface.\n\t * @todo The option `dotsData` wont work.\n\t * @protected\n\t */\n\tNavigation.prototype.draw = function() {\n\t\tvar difference,\n\t\t\tsettings = this._core.settings,\n\t\t\tdisabled = this._core.items().length <= settings.items,\n\t\t\tindex = this._core.relative(this._core.current()),\n\t\t\tloop = settings.loop || settings.rewind;\n\n\t\tthis._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\n\n\t\tif (settings.nav) {\n\t\t\tthis._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\n\t\t\tthis._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\n\t\t}\n\n\t\tthis._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\n\n\t\tif (settings.dots) {\n\t\t\tdifference = this._pages.length - this._controls.$absolute.children().length;\n\n\t\t\tif (settings.dotsData && difference !== 0) {\n\t\t\t\tthis._controls.$absolute.html(this._templates.join(''));\n\t\t\t} else if (difference > 0) {\n\t\t\t\tthis._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\n\t\t\t} else if (difference < 0) {\n\t\t\t\tthis._controls.$absolute.children().slice(difference).remove();\n\t\t\t}\n\n\t\t\tthis._controls.$absolute.find('.active').removeClass('active');\n\t\t\tthis._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n\t\t}\n\t};\n\n\t/**\n\t * Extends event data.\n\t * @protected\n\t * @param {Event} event - The event object which gets thrown.\n\t */\n\tNavigation.prototype.onTrigger = function(event) {\n\t\tvar settings = this._core.settings;\n\n\t\tevent.page = {\n\t\t\tindex: $.inArray(this.current(), this._pages),\n\t\t\tcount: this._pages.length,\n\t\t\tsize: settings && (settings.center || settings.autoWidth || settings.dotsData\n\t\t\t\t? 1 : settings.dotsEach || settings.items)\n\t\t};\n\t};\n\n\t/**\n\t * Gets the current page position of the carousel.\n\t * @protected\n\t * @returns {Number}\n\t */\n\tNavigation.prototype.current = function() {\n\t\tvar current = this._core.relative(this._core.current());\n\t\treturn $.grep(this._pages, $.proxy(function(page, index) {\n\t\t\treturn page.start <= current && page.end >= current;\n\t\t}, this)).pop();\n\t};\n\n\t/**\n\t * Gets the current succesor/predecessor position.\n\t * @protected\n\t * @returns {Number}\n\t */\n\tNavigation.prototype.getPosition = function(successor) {\n\t\tvar position, length,\n\t\t\tsettings = this._core.settings;\n\n\t\tif (settings.slideBy == 'page') {\n\t\t\tposition = $.inArray(this.current(), this._pages);\n\t\t\tlength = this._pages.length;\n\t\t\tsuccessor ? ++position : --position;\n\t\t\tposition = this._pages[((position % length) + length) % length].start;\n\t\t} else {\n\t\t\tposition = this._core.relative(this._core.current());\n\t\t\tlength = this._core.items().length;\n\t\t\tsuccessor ? position += settings.slideBy : position -= settings.slideBy;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n\t * Slides to the next item or page.\n\t * @public\n\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n\t */\n\tNavigation.prototype.next = function(speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n\t};\n\n\t/**\n\t * Slides to the previous item or page.\n\t * @public\n\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n\t */\n\tNavigation.prototype.prev = function(speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n\t};\n\n\t/**\n\t * Slides to the specified item or page.\n\t * @public\n\t * @param {Number} position - The position of the item or page.\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n\t */\n\tNavigation.prototype.to = function(position, speed, standard) {\n\t\tvar length;\n\n\t\tif (!standard && this._pages.length) {\n\t\t\tlength = this._pages.length;\n\t\t\t$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\n\t\t} else {\n\t\t\t$.proxy(this._overrides.to, this._core)(position, speed);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Hash Plugin\n * @version 2.3.4\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n\t * Creates the hash plugin.\n\t * @class The Hash Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar Hash = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Hash index for the items.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._hashes = {};\n\n\t\t/**\n\t\t * The carousel element.\n\t\t * @type {jQuery}\n\t\t */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.startPosition === 'URLHash') {\n\t\t\t\t\t$(window).trigger('hashchange.owl.navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tvar hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n\n\t\t\t\t\tif (!hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._hashes[hash] = e.content;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position') {\n\t\t\t\t\tvar current = this._core.items(this._core.relative(this._core.current())),\n\t\t\t\t\t\thash = $.map(this._hashes, function(item, hash) {\n\t\t\t\t\t\t\treturn item === current ? hash : null;\n\t\t\t\t\t\t}).join();\n\n\t\t\t\t\tif (!hash || window.location.hash.slice(1) === hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\twindow.location.hash = hash;\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n\t\t// register the event handlers\n\t\tthis.$element.on(this._handlers);\n\n\t\t// register event listener for hash navigation\n\t\t$(window).on('hashchange.owl.navigation', $.proxy(function(e) {\n\t\t\tvar hash = window.location.hash.substring(1),\n\t\t\t\titems = this._core.$stage.children(),\n\t\t\t\tposition = this._hashes[hash] && items.index(this._hashes[hash]);\n\n\t\t\tif (position === undefined || position === this._core.current()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._core.to(this._core.relative(position), false, true);\n\t\t}, this));\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tHash.Defaults = {\n\t\tURLhashListener: false\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @public\n\t */\n\tHash.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\t$(window).off('hashchange.owl.navigation');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Support Plugin\n *\n * @version 2.3.4\n * @author Vivid Planet Software GmbH\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\tvar style = $('<support>').get(0).style,\n\t\tprefixes = 'Webkit Moz O ms'.split(' '),\n\t\tevents = {\n\t\t\ttransition: {\n\t\t\t\tend: {\n\t\t\t\t\tWebkitTransition: 'webkitTransitionEnd',\n\t\t\t\t\tMozTransition: 'transitionend',\n\t\t\t\t\tOTransition: 'oTransitionEnd',\n\t\t\t\t\ttransition: 'transitionend'\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation: {\n\t\t\t\tend: {\n\t\t\t\t\tWebkitAnimation: 'webkitAnimationEnd',\n\t\t\t\t\tMozAnimation: 'animationend',\n\t\t\t\t\tOAnimation: 'oAnimationEnd',\n\t\t\t\t\tanimation: 'animationend'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttests = {\n\t\t\tcsstransforms: function() {\n\t\t\t\treturn !!test('transform');\n\t\t\t},\n\t\t\tcsstransforms3d: function() {\n\t\t\t\treturn !!test('perspective');\n\t\t\t},\n\t\t\tcsstransitions: function() {\n\t\t\t\treturn !!test('transition');\n\t\t\t},\n\t\t\tcssanimations: function() {\n\t\t\t\treturn !!test('animation');\n\t\t\t}\n\t\t};\n\n\tfunction test(property, prefixed) {\n\t\tvar result = false,\n\t\t\tupper = property.charAt(0).toUpperCase() + property.slice(1);\n\n\t\t$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {\n\t\t\tif (style[property] !== undefined) {\n\t\t\t\tresult = prefixed ? property : true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tfunction prefixed(property) {\n\t\treturn test(property, true);\n\t}\n\n\tif (tests.csstransitions()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transition = new String(prefixed('transition'))\n\t\t$.support.transition.end = events.transition.end[ $.support.transition ];\n\t}\n\n\tif (tests.cssanimations()) {\n\t\t/* jshint -W053 */\n\t\t$.support.animation = new String(prefixed('animation'))\n\t\t$.support.animation.end = events.animation.end[ $.support.animation ];\n\t}\n\n\tif (tests.csstransforms()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transform = new String(prefixed('transform'));\n\t\t$.support.transform3d = tests.csstransforms3d();\n\t}\n\n})(window.Zepto || window.jQuery, window, document);\n","/* Nano Templates - https://github.com/trix/nano */\n\nfunction nano(template, data) {\n  return template.replace(/\\{([\\w\\.]*)\\}/g, function(str, key) {\n    var keys = key.split(\".\"), v = data[keys.shift()];\n    for (var i = 0, l = keys.length; i < l; i++) v = v[keys[i]];\n    return (typeof v !== \"undefined\" && v !== null) ? v : \"\";\n  });\n}\n","/*!\n*  - v1.5.0\n* Homepage: http://bqworks.com/slider-pro/\n* Author: bqworks\n* Author URL: http://bqworks.com/\n*/\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\t// Static methods for Slider Pro\n\t$.SliderPro = {\n\n\t\t// List of added modules\n\t\tmodules: [],\n\n\t\t// Add a module by extending the core prototype\n\t\taddModule: function( name, module ) {\n\t\t\tthis.modules.push( name );\n\t\t\t$.extend( SliderPro.prototype, module );\n\t\t}\n\t};\n\n\t// namespace\n\tvar NS = $.SliderPro.namespace = 'SliderPro';\n\n\tvar SliderPro = function( instance, options ) {\n\n\t\t// Reference to the slider instance\n\t\tthis.instance = instance;\n\n\t\t// Reference to the slider jQuery element\n\t\tthis.$slider = $( this.instance );\n\n\t\t// Reference to the slides (sp-slides) jQuery element\n\t\tthis.$slides = null;\n\n\t\t// Reference to the mask (sp-mask) jQuery element\n\t\tthis.$slidesMask = null;\n\n\t\t// Reference to the slides (sp-slides-container) jQuery element\n\t\tthis.$slidesContainer = null;\n\n\t\t// Array of SliderProSlide objects, ordered by their DOM index\n\t\tthis.slides = [];\n\n\t\t// Array of SliderProSlide objects, ordered by their left/top position in the slider.\n\t\t// This will be updated continuously if the slider is loopable.\n\t\tthis.slidesOrder = [];\n\n\t\t// Holds the options passed to the slider when it was instantiated\n\t\tthis.options = options;\n\n\t\t// Holds the final settings of the slider after merging the specified\n\t\t// ones with the default ones.\n\t\tthis.settings = {};\n\n\t\t// Another reference to the settings which will not be altered by breakpoints or by other means\n\t\tthis.originalSettings = {};\n\n\t\t// Reference to the original 'gotoSlide' method\n\t\tthis.originalGotoSlide = null;\n\n\t\t// The index of the currently selected slide (starts with 0)\n\t\tthis.selectedSlideIndex = 0;\n\n\t\t// The index of the previously selected slide\n\t\tthis.previousSlideIndex = 0;\n\n\t\t// Indicates the position of the slide considered to be in the middle.\n\t\t// If there are 5 slides (0, 1, 2, 3, 4) the middle position will be 2.\n\t\t// If there are 6 slides (0, 1, 2, 3, 4, 5) the middle position will be approximated to 2.\n\t\tthis.middleSlidePosition = 0;\n\n\t\t// Indicates the type of supported transition (CSS3 2D, CSS3 3D or JavaScript)\n\t\tthis.supportedAnimation = null;\n\n\t\t// Indicates the required vendor prefix for CSS (i.e., -webkit, -moz, etc.)\n\t\tthis.vendorPrefix = null;\n\n\t\t// Indicates the name of the CSS transition's complete event (i.e., transitionend, webkitTransitionEnd, etc.)\n\t\tthis.transitionEvent = null;\n\n\t\t// Indicates the 'left' or 'top' position, depending on the orientation of the slides\n\t\tthis.positionProperty = null;\n\n\t\t// Indicates the 'width' or 'height', depending on the orientation of the slides\n\t\tthis.sizeProperty = null;\n\n\t\t// Indicates if the current browser is IE\n\t\tthis.isIE = null;\n\n\t\t// The position of the slides container\n\t\tthis.slidesPosition = 0;\n\n\t\t// The total width/height of the slides\n\t\tthis.slidesSize = 0;\n\n\t\t// The average width/height of a slide\n\t\tthis.averageSlideSize = 0;\n\n\t\t// The width of the individual slide\n\t\tthis.slideWidth = 0;\n\n\t\t// The height of the individual slide\n\t\tthis.slideHeight = 0;\n\n\t\t// Reference to the old slide width, used to check if the width has changed\n\t\tthis.previousSlideWidth = 0;\n\n\t\t// Reference to the old slide height, used to check if the height has changed\n\t\tthis.previousSlideHeight = 0;\n\t\t\n\t\t// Reference to the old window width, used to check if the window width has changed\n\t\tthis.previousWindowWidth = 0;\n\t\t\n\t\t// Reference to the old window height, used to check if the window height has changed\n\t\tthis.previousWindowHeight = 0;\n\n\t\t// Property used for deferring the resizing of the slider\n\t\tthis.allowResize = true;\n\n\t\t// Unique ID to be used for event listening\n\t\tthis.uniqueId = new Date().valueOf();\n\n\t\t// Stores size breakpoints\n\t\tthis.breakpoints = [];\n\n\t\t// Indicates the current size breakpoint\n\t\tthis.currentBreakpoint = -1;\n\n\t\t// An array of shuffled indexes, based on which the slides will be shuffled\n\t\tthis.shuffledIndexes = [];\n\n\t\t// Initialize the slider\n\t\tthis._init();\n\t};\n\n\tSliderPro.prototype = {\n\n\t\t// The starting place for the slider\n\t\t_init: function() {\n\t\t\tvar that = this;\n\n\t\t\tthis.supportedAnimation = SliderProUtils.getSupportedAnimation();\n\t\t\tthis.vendorPrefix = SliderProUtils.getVendorPrefix();\n\t\t\tthis.transitionEvent = SliderProUtils.getTransitionEvent();\n\t\t\tthis.isIE = SliderProUtils.checkIE();\n\n\t\t\t// Remove the 'sp-no-js' when the slider's JavaScript code starts running\n\t\t\tthis.$slider.removeClass( 'sp-no-js' );\n\n\t\t\t// Add the 'ios' class if it's an iOS device\n\t\t\tif ( window.navigator.userAgent.match( /(iPad|iPhone|iPod)/g ) ) {\n\t\t\t\tthis.$slider.addClass( 'ios' );\n\t\t\t}\n\n\t\t\t// Check if IE (older than 11) is used and add the version number as a class to the slider since\n\t\t\t// older IE versions might need CSS tweaks.\n\t\t\tvar rmsie = /(msie) ([\\w.]+)/,\n\t\t\t\tieVersion = rmsie.exec( window.navigator.userAgent.toLowerCase() );\n\t\t\t\n\t\t\tif ( this.isIE ) {\n\t\t\t\tthis.$slider.addClass( 'ie' );\n\t\t\t}\n\n\t\t\tif ( ieVersion !== null ) {\n\t\t\t\tthis.$slider.addClass( 'ie' + parseInt( ieVersion[2], 10 ) );\n\t\t\t}\n\n\t\t\t// Set up the slides containers\n\t\t\t// slider-pro > sp-slides-container > sp-mask > sp-slides > sp-slide\n\t\t\tthis.$slidesContainer = $( '<div class=\"sp-slides-container\"></div>' ).appendTo( this.$slider );\n\t\t\tthis.$slidesMask = $( '<div class=\"sp-mask\"></div>' ).appendTo( this.$slidesContainer );\n\t\t\tthis.$slides = this.$slider.find( '.sp-slides' ).appendTo( this.$slidesMask );\n\t\t\tthis.$slider.find( '.sp-slide' ).appendTo( this.$slides );\n\t\t\t\n\t\t\tvar modules = $.SliderPro.modules;\n\n\t\t\t// Merge the modules' default settings with the core's default settings\n\t\t\tif ( typeof modules !== 'undefined' ) {\n\t\t\t\tfor ( var i = 0; i < modules.length; i++ ) {\n\t\t\t\t\tvar defaults = modules[ i ].substring( 0, 1 ).toLowerCase() + modules[ i ].substring( 1 ) + 'Defaults';\n\n\t\t\t\t\tif ( typeof this[ defaults ] !== 'undefined' ) {\n\t\t\t\t\t\t$.extend( this.defaults, this[ defaults ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Merge the specified setting with the default ones\n\t\t\tthis.settings = $.extend( {}, this.defaults, this.options );\n\n\t\t\t// Initialize the modules\n\t\t\tif ( typeof modules !== 'undefined' ) {\n\t\t\t\tfor ( var j = 0; j < modules.length; j++ ) {\n\t\t\t\t\tif ( typeof this[ 'init' + modules[ j ] ] !== 'undefined' ) {\n\t\t\t\t\t\tthis[ 'init' + modules[ j ] ]();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Keep a reference of the original settings and use it\n\t\t\t// to restore the settings when the breakpoints are used.\n\t\t\tthis.originalSettings = $.extend( {}, this.settings );\n\n\t\t\t// Get the reference to the 'gotoSlide' method\n\t\t\tthis.originalGotoSlide = this.gotoSlide;\n\n\t\t\t// Parse the breakpoints object and store the values into an array,\n\t\t\t// sorting them in ascending order based on the specified size.\n\t\t\tif ( this.settings.breakpoints !== null ) {\n\t\t\t\tfor ( var sizes in this.settings.breakpoints ) {\n\t\t\t\t\tthis.breakpoints.push({ size: parseInt( sizes, 10 ), properties:this.settings.breakpoints[ sizes ] });\n\t\t\t\t}\n\n\t\t\t\tthis.breakpoints = this.breakpoints.sort(function( a, b ) {\n\t\t\t\t\treturn a.size >= b.size ? 1: -1;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Set which slide should be selected initially\n\t\t\tthis.selectedSlideIndex = this.settings.startSlide;\n\n\t\t\t// Shuffle/randomize the slides\n\t\t\tif ( this.settings.shuffle === true ) {\n\t\t\t\tvar slides = this.$slides.find( '.sp-slide' ),\n\t\t\t\t\tshuffledSlides = [];\n\n\t\t\t\t// Populate the 'shuffledIndexes' with index numbers\n\t\t\t\tslides.each(function( index ) {\n\t\t\t\t\tthat.shuffledIndexes.push( index );\n\t\t\t\t});\n\n\t\t\t\tfor ( var k = this.shuffledIndexes.length - 1; k > 0; k-- ) {\n\t\t\t\t\tvar l = Math.floor( Math.random() * ( k + 1 ) ),\n\t\t\t\t\t\ttemp = this.shuffledIndexes[ k ];\n\n\t\t\t\t\tthis.shuffledIndexes[ k ] = this.shuffledIndexes[ l ];\n\t\t\t\t\tthis.shuffledIndexes[ l ] = temp;\n\t\t\t\t}\n\n\t\t\t\t// Reposition the slides based on the order of the indexes in the\n\t\t\t\t// 'shuffledIndexes' array\n\t\t\t\t$.each( this.shuffledIndexes, function( index, element ) {\n\t\t\t\t\tshuffledSlides.push( slides[ element ] );\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// Append the sorted slides to the slider\n\t\t\t\tthis.$slides.empty().append( shuffledSlides ) ;\n\t\t\t}\n\t\t\t\n\t\t\t// Resize the slider when the browser window resizes.\n\t\t\t// Also, deffer the resizing in order to not allow multiple\n\t\t\t// resizes in a 200 milliseconds interval.\n\t\t\t$( window ).on( 'resize.' + this.uniqueId + '.' + NS, function() {\n\t\t\t\n\t\t\t\t// Get the current width and height of the window\n\t\t\t\tvar newWindowWidth = $( window ).width(),\n\t\t\t\t\tnewWindowHeight = $( window ).height();\n\t\t\t\t\n\t\t\t\t// If the resize is not allowed yet or if the window size hasn't changed (this needs to be verified\n\t\t\t\t// because in IE8 and lower the resize event is triggered whenever an element from the page changes\n\t\t\t\t// its size) return early.\n\t\t\t\tif ( that.allowResize === false ||\n\t\t\t\t\t( that.previousWindowWidth === newWindowWidth && that.previousWindowHeight === newWindowHeight ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Assign the new values for the window width and height\n\t\t\t\tthat.previousWindowWidth = newWindowWidth;\n\t\t\t\tthat.previousWindowHeight = newWindowHeight;\n\t\t\t\n\t\t\t\tthat.allowResize = false;\n\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tthat.resize();\n\t\t\t\t\tthat.allowResize = true;\n\t\t\t\t}, 200 );\n\t\t\t});\n\n\t\t\t// Resize the slider when the 'update' method is called.\n\t\t\tthis.on( 'update.' + NS, function() {\n\n\t\t\t\t// Reset the previous slide width\n\t\t\t\tthat.previousSlideWidth = 0;\n\n\t\t\t\t// Some updates might require a resize\n\t\t\t\tthat.resize();\n\t\t\t});\n\n\t\t\tthis.update();\n\n\t\t\t// add the 'sp-selected' class to the initially selected slide\n\t\t\tthis.$slides.find( '.sp-slide' ).eq( this.selectedSlideIndex ).addClass( 'sp-selected' );\n\n\t\t\t// Fire the 'init' event\n\t\t\tthis.trigger({ type: 'init' });\n\t\t\tif ( $.isFunction( this.settings.init ) ) {\n\t\t\t\tthis.settings.init.call( this, { type: 'init' });\n\t\t\t}\n\t\t},\n\n\t\t// Update the slider by checking for setting changes and for slides\n\t\t// that weren't initialized yet.\n\t\tupdate: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Check the current slider orientation and reset CSS that might have been\n\t\t\t// added for a different orientation, since the orientation can be changed\n\t\t\t// at runtime.\n\t\t\tif ( this.settings.orientation === 'horizontal' ) {\n\t\t\t\tthis.$slider.removeClass( 'sp-vertical' ).addClass( 'sp-horizontal' );\n\t\t\t\tthis.$slider.css({ 'height': '', 'max-height': '' });\n\t\t\t\tthis.$slides.find( '.sp-slide' ).css( 'top', '' );\n\t\t\t} else if ( this.settings.orientation === 'vertical' ) {\n\t\t\t\tthis.$slider.removeClass( 'sp-horizontal' ).addClass( 'sp-vertical' );\n\t\t\t\tthis.$slides.find( '.sp-slide' ).css( 'left', '' );\n\t\t\t}\n\n\t\t\tif ( this.settings.rightToLeft === true ) {\n\t\t\t\tthis.$slider.addClass( 'sp-rtl' );\n\t\t\t} else {\n\t\t\t\tthis.$slider.removeClass( 'sp-rtl' );\n\t\t\t}\n\n\t\t\tthis.positionProperty = this.settings.orientation === 'horizontal' ? 'left' : 'top';\n\t\t\tthis.sizeProperty = this.settings.orientation === 'horizontal' ? 'width' : 'height';\n\n\t\t\t// Reset the 'gotoSlide' method\n\t\t\tthis.gotoSlide = this.originalGotoSlide;\n\n\t\t\t// Loop through the array of SliderProSlide objects and if a stored slide is found\n\t\t\t// which is not in the DOM anymore, destroy that slide.\n\t\t\tfor ( var i = this.slides.length - 1; i >= 0; i-- ) {\n\t\t\t\tif ( this.$slider.find( '.sp-slide[data-index=\"' + i + '\"]' ).length === 0 ) {\n\t\t\t\t\tvar slide = this.slides[ i ];\n\n\t\t\t\t\tslide.off( 'imagesLoaded.' + NS );\n\t\t\t\t\tslide.destroy();\n\t\t\t\t\tthis.slides.splice( i, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.slidesOrder.length = 0;\n\n\t\t\t// Loop through the list of slides and initialize newly added slides if any,\n\t\t\t// and reset the index of each slide.\n\t\t\tthis.$slider.find( '.sp-slide' ).each(function( index ) {\n\t\t\t\tvar $slide = $( this );\n\n\t\t\t\tif ( typeof $slide.attr( 'data-init' ) === 'undefined' ) {\n\t\t\t\t\tthat._createSlide( index, $slide );\n\t\t\t\t} else {\n\t\t\t\t\tthat.slides[ index ].setIndex( index );\n\t\t\t\t}\n\n\t\t\t\tthat.slidesOrder.push( index );\n\t\t\t});\n\n\t\t\t// Calculate the position/index of the middle slide\n\t\t\tthis.middleSlidePosition = parseInt( ( that.slidesOrder.length - 1 ) / 2, 10 );\n\n\t\t\t// Arrange the slides in a loop\n\t\t\tif ( this.settings.loop === true ) {\n\t\t\t\tthis._updateSlidesOrder();\n\t\t\t}\n\n\t\t\t// Fire the 'update' event\n\t\t\tthis.trigger({ type: 'update' });\n\t\t\tif ( $.isFunction( this.settings.update ) ) {\n\t\t\t\tthis.settings.update.call( this, { type: 'update' } );\n\t\t\t}\n\t\t},\n\n\t\t// Create a SliderProSlide instance for the slide passed as a jQuery element\n\t\t_createSlide: function( index, element ) {\n\t\t\tvar that = this,\n\t\t\t\tslide = new SliderProSlide( $( element ), index, this.settings );\n\n\t\t\tthis.slides.splice( index, 0, slide );\n\n\t\t\tslide.on( 'imagesLoaded.' + NS, function( event ) {\n\t\t\t\tif ( that.settings.autoSlideSize === true ) {\n\t\t\t\t\tif ( that.$slides.hasClass( 'sp-animated' ) === false ) {\n\t\t\t\t\t\tthat._resetSlidesPosition();\n\t\t\t\t\t}\n\n\t\t\t\t\tthat._calculateSlidesSize();\n\t\t\t\t}\n\n\t\t\t\tif ( that.settings.autoHeight === true && event.index === that.selectedSlideIndex ) {\n\t\t\t\t\tthat._resizeHeightTo( slide.getSize().height);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Arrange the slide elements in a loop inside the 'slidesOrder' array\n\t\t_updateSlidesOrder: function() {\n\t\t\tvar\tslicedItems,\n\t\t\t\ti,\n\n\t\t\t\t// Calculate the distance between the selected element and the middle position\n\t\t\t\tdistance = $.inArray( this.selectedSlideIndex, this.slidesOrder ) - this.middleSlidePosition;\n\n\t\t\t// If the distance is negative it means that the selected slider is before the middle position, so\n\t\t\t// slides from the end of the array will be added at the beginning, in order to shift the selected slide\n\t\t\t// forward.\n\t\t\t// \n\t\t\t// If the distance is positive, slides from the beginning of the array will be added at the end.\n\t\t\tif ( distance < 0 ) {\n\t\t\t\tslicedItems = this.slidesOrder.splice( distance, Math.abs( distance ) );\n\n\t\t\t\tfor ( i = slicedItems.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tthis.slidesOrder.unshift( slicedItems[ i ] );\n\t\t\t\t}\n\t\t\t} else if ( distance > 0 ) {\n\t\t\t\tslicedItems = this.slidesOrder.splice( 0, distance );\n\n\t\t\t\tfor ( i = 0; i <= slicedItems.length - 1; i++ ) {\n\t\t\t\t\tthis.slidesOrder.push( slicedItems[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Set the left/top position of the slides based on their position in the 'slidesOrder' array\n\t\t_updateSlidesPosition: function() {\n\t\t\tvar selectedSlidePixelPosition = parseInt( this.$slides.find( '.sp-slide' ).eq( this.selectedSlideIndex ).css( this.positionProperty ), 10 ),\n\t\t\t\tslide,\n\t\t\t\t$slideElement,\n\t\t\t\tslideIndex,\n\t\t\t\tpreviousPosition = selectedSlidePixelPosition,\n\t\t\t\tdirectionMultiplier,\n\t\t\t\tslideSize;\n\t\t\t\n\t\t\tif ( this.settings.autoSlideSize === true ) {\n\t\t\t\tif ( this.settings.rightToLeft === true && this.settings.orientation === 'horizontal' ) {\n\t\t\t\t\tfor ( slideIndex = this.middleSlidePosition; slideIndex >= 0; slideIndex-- ) {\n\t\t\t\t\t\tslide = this.getSlideAt( this.slidesOrder[ slideIndex ] );\n\t\t\t\t\t\t$slideElement = slide.$slide;\n\t\t\t\t\t\t$slideElement.css( this.positionProperty, previousPosition );\n\t\t\t\t\t\tpreviousPosition = parseInt( $slideElement.css( this.positionProperty ), 10 ) + slide.getSize()[ this.sizeProperty ] + this.settings.slideDistance;\n\t\t\t\t\t}\n\n\t\t\t\t\tpreviousPosition = selectedSlidePixelPosition;\n\n\t\t\t\t\tfor ( slideIndex = this.middleSlidePosition + 1; slideIndex < this.slidesOrder.length; slideIndex++ ) {\n\t\t\t\t\t\tslide = this.getSlideAt( this.slidesOrder[ slideIndex ] );\n\t\t\t\t\t\t$slideElement = slide.$slide;\n\t\t\t\t\t\t$slideElement.css( this.positionProperty, previousPosition - ( slide.getSize()[ this.sizeProperty ] + this.settings.slideDistance ) );\n\t\t\t\t\t\tpreviousPosition = parseInt( $slideElement.css( this.positionProperty ), 10 );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( slideIndex = this.middleSlidePosition - 1; slideIndex >= 0; slideIndex-- ) {\n\t\t\t\t\t\tslide = this.getSlideAt( this.slidesOrder[ slideIndex ] );\n\t\t\t\t\t\t$slideElement = slide.$slide;\n\t\t\t\t\t\t$slideElement.css( this.positionProperty, previousPosition - ( slide.getSize()[ this.sizeProperty ] + this.settings.slideDistance ) );\n\t\t\t\t\t\tpreviousPosition = parseInt( $slideElement.css( this.positionProperty ), 10 );\n\t\t\t\t\t}\n\n\t\t\t\t\tpreviousPosition = selectedSlidePixelPosition;\n\n\t\t\t\t\tfor ( slideIndex = this.middleSlidePosition; slideIndex < this.slidesOrder.length; slideIndex++ ) {\n\t\t\t\t\t\tslide = this.getSlideAt( this.slidesOrder[ slideIndex ] );\n\t\t\t\t\t\t$slideElement = slide.$slide;\n\t\t\t\t\t\t$slideElement.css( this.positionProperty, previousPosition );\n\t\t\t\t\t\tpreviousPosition = parseInt( $slideElement.css( this.positionProperty ), 10 ) + slide.getSize()[ this.sizeProperty ] + this.settings.slideDistance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdirectionMultiplier = ( this.settings.rightToLeft === true && this.settings.orientation === 'horizontal' ) ? -1 : 1;\n\t\t\t\tslideSize = ( this.settings.orientation === 'horizontal' ) ? this.slideWidth : this.slideHeight;\n\n\t\t\t\tfor ( slideIndex = 0; slideIndex < this.slidesOrder.length; slideIndex++ ) {\n\t\t\t\t\t$slideElement = this.$slides.find( '.sp-slide' ).eq( this.slidesOrder[ slideIndex ] );\n\t\t\t\t\t$slideElement.css( this.positionProperty, selectedSlidePixelPosition + directionMultiplier * ( slideIndex - this.middleSlidePosition  ) * ( slideSize + this.settings.slideDistance ) );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Set the left/top position of the slides based on their position in the 'slidesOrder' array,\n\t\t// and also set the position of the slides container.\n\t\t_resetSlidesPosition: function() {\n\t\t\tvar previousPosition = 0,\n\t\t\t\tslide,\n\t\t\t\t$slideElement,\n\t\t\t\tslideIndex,\n\t\t\t\tselectedSlideSize,\n\t\t\t\tdirectionMultiplier,\n\t\t\t\tslideSize;\n\n\t\t\tif ( this.settings.autoSlideSize === true ) {\n\t\t\t\tif ( this.settings.rightToLeft === true && this.settings.orientation === 'horizontal' ) {\n\t\t\t\t\tfor ( slideIndex = 0; slideIndex < this.slidesOrder.length; slideIndex++ ) {\n\t\t\t\t\t\tslide = this.getSlideAt( this.slidesOrder[ slideIndex ] );\n\t\t\t\t\t\t$slideElement = slide.$slide;\n\t\t\t\t\t\t$slideElement.css( this.positionProperty, previousPosition - ( slide.getSize()[ this.sizeProperty ] + this.settings.slideDistance ) );\n\t\t\t\t\t\tpreviousPosition = parseInt( $slideElement.css( this.positionProperty ), 10 );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor ( slideIndex = 0; slideIndex < this.slidesOrder.length; slideIndex++ ) {\n\t\t\t\t\t\tslide = this.getSlideAt( this.slidesOrder[ slideIndex ] );\n\t\t\t\t\t\t$slideElement = slide.$slide;\n\t\t\t\t\t\t$slideElement.css( this.positionProperty, previousPosition );\n\t\t\t\t\t\tpreviousPosition = parseInt( $slideElement.css( this.positionProperty ), 10 ) + slide.getSize()[ this.sizeProperty ] + this.settings.slideDistance;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tselectedSlideSize = this.getSlideAt( this.selectedSlideIndex ).getSize()[ this.sizeProperty ];\n\t\t\t} else {\n\t\t\t\tdirectionMultiplier = ( this.settings.rightToLeft === true && this.settings.orientation === 'horizontal' ) === true ? -1 : 1;\n\t\t\t\tslideSize = ( this.settings.orientation === 'horizontal' ) ? this.slideWidth : this.slideHeight;\n \n\t\t\t\tfor ( slideIndex = 0; slideIndex < this.slidesOrder.length; slideIndex++ ) {\n\t\t\t\t\t$slideElement = this.$slides.find( '.sp-slide' ).eq( this.slidesOrder[ slideIndex ] );\n\t\t\t\t\t$slideElement.css( this.positionProperty, directionMultiplier * slideIndex * ( slideSize + this.settings.slideDistance ) );\n\t\t\t\t}\n\n\t\t\t\tselectedSlideSize = slideSize;\n\t\t\t}\n\n\t\t\tvar selectedSlideOffset = this.settings.centerSelectedSlide === true && this.settings.visibleSize !== 'auto' ? Math.round( ( parseInt( this.$slidesMask.css( this.sizeProperty ), 10 ) - selectedSlideSize ) / 2 ) : 0,\n\t\t\t\tnewSlidesPosition = - parseInt( this.$slides.find( '.sp-slide' ).eq( this.selectedSlideIndex ).css( this.positionProperty ), 10 ) + selectedSlideOffset;\n\t\t\t\n\t\t\tthis._moveTo( newSlidesPosition, true );\n\t\t},\n\n\t\t// Calculate the total size of the slides and the average size of a single slide\n\t\t_calculateSlidesSize: function() {\n\t\t\tif ( this.settings.autoSlideSize === true ) {\n\t\t\t\tvar firstSlide = this.$slides.find( '.sp-slide' ).eq( this.slidesOrder[ 0 ] ),\n\t\t\t\t\tfirstSlidePosition = parseInt( firstSlide.css( this.positionProperty ), 10 ),\n\t\t\t\t\tlastSlide = this.$slides.find( '.sp-slide' ).eq( this.slidesOrder[ this.slidesOrder.length - 1 ] ),\n\t\t\t\t\tlastSlidePosition = parseInt( lastSlide.css( this.positionProperty ), 10 ) + ( this.settings.rightToLeft === true && this.settings.orientation === 'horizontal' ? -1 : 1 ) * parseInt( lastSlide.css( this.sizeProperty ), 10 );\n\t\t\t\t\n\t\t\t\tthis.slidesSize = Math.abs( lastSlidePosition - firstSlidePosition );\n\t\t\t\tthis.averageSlideSize = Math.round( this.slidesSize / this.slides.length );\n\t\t\t} else {\n\t\t\t\tthis.slidesSize = ( ( this.settings.orientation === 'horizontal' ? this.slideWidth : this.slideHeight ) + this.settings.slideDistance ) * this.slides.length - this.settings.slideDistance;\n\t\t\t\tthis.averageSlideSize = this.settings.orientation === 'horizontal' ? this.slideWidth : this.slideHeight;\n\t\t\t}\n\t\t},\n\n\t\t// Called when the slider needs to resize\n\t\tresize: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Check if the current window width is bigger than the biggest breakpoint\n\t\t\t// and if necessary reset the properties to the original settings.\n\t\t\t// \n\t\t\t// If the window width is smaller than a certain breakpoint, apply the settings specified\n\t\t\t// for that breakpoint but only after merging them with the original settings\n\t\t\t// in order to make sure that only the specified settings for the breakpoint are applied\n\t\t\tif ( this.settings.breakpoints !== null && this.breakpoints.length > 0 ) {\n\t\t\t\tif ( $( window ).width() > this.breakpoints[ this.breakpoints.length - 1 ].size && this.currentBreakpoint !== -1 ) {\n\t\t\t\t\tthis.currentBreakpoint = -1;\n\t\t\t\t\tthis._setProperties( this.originalSettings, false );\n\t\t\t\t} else {\n\t\t\t\t\tfor ( var i = 0, n = this.breakpoints.length; i < n; i++ ) {\n\t\t\t\t\t\tif ( $( window ).width() <= this.breakpoints[ i ].size ) {\n\t\t\t\t\t\t\tif ( this.currentBreakpoint !== this.breakpoints[ i ].size ) {\n\t\t\t\t\t\t\t\tvar eventObject = { type: 'breakpointReach', size: this.breakpoints[ i ].size, settings: this.breakpoints[ i ].properties };\n\t\t\t\t\t\t\t\tthis.trigger( eventObject );\n\t\t\t\t\t\t\t\tif ( $.isFunction( this.settings.breakpointReach ) )\n\t\t\t\t\t\t\t\t\tthis.settings.breakpointReach.call( this, eventObject );\n\n\t\t\t\t\t\t\t\tthis.currentBreakpoint = this.breakpoints[ i ].size;\n\t\t\t\t\t\t\t\tvar settings = $.extend( {}, this.originalSettings, this.breakpoints[ i ].properties );\n\t\t\t\t\t\t\t\tthis._setProperties( settings, false );\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the width of the main slider container based on whether or not the slider is responsive,\n\t\t\t// full width or full size\n\t\t\tif ( this.settings.responsive === true ) {\n\t\t\t\tif ( ( this.settings.forceSize === 'fullWidth' || this.settings.forceSize === 'fullWindow' ) &&\n\t\t\t\t\t( this.settings.visibleSize === 'auto' || this.settings.visibleSize !== 'auto' && this.settings.orientation === 'vertical' )\n\t\t\t\t) {\n\t\t\t\t\tthis.$slider.css( 'margin', 0 );\n\t\t\t\t\tthis.$slider.css({ 'width': $( window ).width(), 'max-width': '', 'marginLeft': - this.$slider.offset().left });\n\t\t\t\t} else {\n\t\t\t\t\tthis.$slider.css({ 'width': '100%', 'max-width': this.settings.width, 'marginLeft': '' });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.$slider.css({ 'width': this.settings.width });\n\t\t\t}\n\n\t\t\t// Calculate the aspect ratio of the slider\n\t\t\tif ( this.settings.aspectRatio === -1 ) {\n\t\t\t\tthis.settings.aspectRatio = this.settings.width / this.settings.height;\n\t\t\t}\n\t\t\t\n\t\t\t// Initially set the slide width to the size of the slider.\n\t\t\t// Later, this will be set to less if there are multiple visible slides.\n\t\t\tthis.slideWidth = this.$slider.width();\n\n\t\t\t// Set the height to the same size as the browser window if the slider is set to be 'fullWindow',\n\t\t\t// or calculate the height based on the width and the aspect ratio.\n\t\t\tif ( this.settings.forceSize === 'fullWindow' ) {\n\t\t\t\tthis.slideHeight = $( window ).height();\n\t\t\t} else {\n\t\t\t\tthis.slideHeight = isNaN( this.settings.aspectRatio ) ? this.settings.height : this.slideWidth / this.settings.aspectRatio;\n\t\t\t}\n\n\t\t\t// Resize the slider only if the size of the slider has changed\n\t\t\t// If it hasn't, return.\n\t\t\tif ( this.previousSlideWidth !== this.slideWidth ||\n\t\t\t\tthis.previousSlideHeight !== this.slideHeight ||\n\t\t\t\tthis.settings.visibleSize !== 'auto' ||\n\t\t\t\tthis.$slider.outerWidth() > this.$slider.parent().width() ||\n\t\t\t\tthis.$slider.width() !== this.$slidesMask.width()\n\t\t\t) {\n\t\t\t\tthis.previousSlideWidth = this.slideWidth;\n\t\t\t\tthis.previousSlideHeight = this.slideHeight;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._resizeSlides();\n\n\t\t\t// Set the initial size of the mask container to the size of an individual slide\n\t\t\tthis.$slidesMask.css({ 'width': this.slideWidth, 'height': this.slideHeight });\n\n\t\t\t// Adjust the height if it's set to 'auto'\n\t\t\tif ( this.settings.autoHeight === true ) {\n\n\t\t\t\t// Delay the resizing of the height to allow for other resize handlers\n\t\t\t\t// to execute first before calculating the final height of the slide\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\tthat._resizeHeight();\n\t\t\t\t}, 1 );\n\t\t\t} else {\n\t\t\t\tthis.$slidesMask.css( this.vendorPrefix + 'transition', '' );\n\t\t\t}\n\n\t\t\t// The 'visibleSize' option can be set to fixed or percentage size to make more slides\n\t\t\t// visible at a time.\n\t\t\t// By default it's set to 'auto'.\n\t\t\tif ( this.settings.visibleSize !== 'auto' ) {\n\t\t\t\tif ( this.settings.orientation === 'horizontal' ) {\n\n\t\t\t\t\t// If the size is forced to full width or full window, the 'visibleSize' option will be\n\t\t\t\t\t// ignored and the slider will become as wide as the browser window.\n\t\t\t\t\tif ( this.settings.forceSize === 'fullWidth' || this.settings.forceSize === 'fullWindow' ) {\n\t\t\t\t\t\tthis.$slider.css( 'margin', 0 );\n\t\t\t\t\t\tthis.$slider.css({ 'width': $( window ).width(), 'max-width': '', 'marginLeft': - this.$slider.offset().left });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.$slider.css({ 'width': this.settings.visibleSize, 'max-width': '100%', 'marginLeft': 0 });\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.$slidesMask.css( 'width', this.$slider.width() );\n\t\t\t\t} else {\n\n\t\t\t\t\t// If the size is forced to full window, the 'visibleSize' option will be\n\t\t\t\t\t// ignored and the slider will become as high as the browser window.\n\t\t\t\t\tif ( this.settings.forceSize === 'fullWindow' ) {\n\t\t\t\t\t\tthis.$slider.css({ 'height': $( window ).height(), 'max-height': '' });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.$slider.css({ 'height': this.settings.visibleSize, 'max-height': '100%' });\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.$slidesMask.css( 'height', this.$slider.height() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._resetSlidesPosition();\n\t\t\tthis._calculateSlidesSize();\n\n\t\t\t// Fire the 'sliderResize' event\n\t\t\tthis.trigger({ type: 'sliderResize' });\n\t\t\tif ( $.isFunction( this.settings.sliderResize ) ) {\n\t\t\t\tthis.settings.sliderResize.call( this, { type: 'sliderResize' });\n\t\t\t}\n\t\t},\n\n\t\t// Resize each individual slide\n\t\t_resizeSlides: function() {\n\t\t\tvar slideWidth = this.slideWidth,\n\t\t\t\tslideHeight = this.slideHeight;\n\n\t\t\tif ( this.settings.autoSlideSize === true ) {\n\t\t\t\tif ( this.settings.orientation === 'horizontal' ) {\n\t\t\t\t\tslideWidth = 'auto';\n\t\t\t\t} else if ( this.settings.orientation === 'vertical' ) {\n\t\t\t\t\tslideHeight = 'auto';\n\t\t\t\t}\n\t\t\t} else if ( this.settings.autoHeight === true ) {\n\t\t\t\tslideHeight = 'auto';\n\t\t\t}\n\n\t\t\t// Loop through the existing slides and reset their size.\n\t\t\t$.each( this.slides, function( index, element ) {\n\t\t\t\telement.setSize( slideWidth, slideHeight );\n\t\t\t});\n\t\t},\n\n\t\t// Resize the height of the slider to the height of the selected slide.\n\t\t// It's used when the 'autoHeight' option is set to 'true'.\n\t\t_resizeHeight: function() {\n\t\t\tvar that = this,\n\t\t\t\tselectedSlide = this.getSlideAt( this.selectedSlideIndex );\n\n\t\t\tthis._resizeHeightTo( selectedSlide.getSize().height );\n\t\t},\n\n\t\t// Open the slide at the specified index\n\t\tgotoSlide: function( index ) {\n\t\t\tif ( index === this.selectedSlideIndex || typeof this.slides[ index ] === 'undefined' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar that = this;\n\n\t\t\tthis.previousSlideIndex = this.selectedSlideIndex;\n\t\t\tthis.selectedSlideIndex = index;\n\n\t\t\t// Re-assign the 'sp-selected' class to the currently selected slide\n\t\t\tthis.$slides.find( '.sp-selected' ).removeClass( 'sp-selected' );\n\t\t\tthis.$slides.find( '.sp-slide' ).eq( this.selectedSlideIndex ).addClass( 'sp-selected' );\n\n\t\t\t// If the slider is loopable reorder the slides to have the selected slide in the middle\n\t\t\t// and update the slides' position.\n\t\t\tif ( this.settings.loop === true ) {\n\t\t\t\tthis._updateSlidesOrder();\n\t\t\t\tthis._updateSlidesPosition();\n\t\t\t}\n\n\t\t\t// Adjust the height of the slider\n\t\t\tif ( this.settings.autoHeight === true ) {\n\t\t\t\tthis._resizeHeight();\n\t\t\t}\n\n\t\t\tvar selectedSlideOffset = this.settings.centerSelectedSlide === true && this.settings.visibleSize !== 'auto' ? Math.round( ( parseInt( this.$slidesMask.css( this.sizeProperty ), 10 ) - this.getSlideAt( this.selectedSlideIndex ).getSize()[ this.sizeProperty ] ) / 2 ) : 0,\n\t\t\t\tnewSlidesPosition = - parseInt( this.$slides.find( '.sp-slide' ).eq( this.selectedSlideIndex ).css( this.positionProperty ), 10 ) + selectedSlideOffset;\n\n\t\t\t// Move the slides container to the new position\n\t\t\tthis._moveTo( newSlidesPosition, false, function() {\n\t\t\t\tthat._resetSlidesPosition();\n\n\t\t\t\t// Fire the 'gotoSlideComplete' event\n\t\t\t\tthat.trigger({ type: 'gotoSlideComplete', index: index, previousIndex: that.previousSlideIndex });\n\t\t\t\tif ( $.isFunction( that.settings.gotoSlideComplete ) ) {\n\t\t\t\t\tthat.settings.gotoSlideComplete.call( that, { type: 'gotoSlideComplete', index: index, previousIndex: that.previousSlideIndex } );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Fire the 'gotoSlide' event\n\t\t\tthis.trigger({ type: 'gotoSlide', index: index, previousIndex: this.previousSlideIndex });\n\t\t\tif ( $.isFunction( this.settings.gotoSlide ) ) {\n\t\t\t\tthis.settings.gotoSlide.call( this, { type: 'gotoSlide', index: index, previousIndex: this.previousSlideIndex } );\n\t\t\t}\n\t\t},\n\n\t\t// Open the next slide\n\t\tnextSlide: function() {\n\t\t\tvar index = ( this.selectedSlideIndex >= this.getTotalSlides() - 1 ) ? 0 : ( this.selectedSlideIndex + 1 );\n\t\t\tthis.gotoSlide( index );\n\t\t},\n\n\t\t// Open the previous slide\n\t\tpreviousSlide: function() {\n\t\t\tvar index = this.selectedSlideIndex <= 0 ? ( this.getTotalSlides() - 1 ) : ( this.selectedSlideIndex - 1 );\n\t\t\tthis.gotoSlide( index );\n\t\t},\n\n\t\t// Move the slides container to the specified position.\n\t\t// The movement can be instant or animated.\n\t\t_moveTo: function( position, instant, callback ) {\n\t\t\tvar that = this,\n\t\t\t\tcss = {};\n\n\t\t\tif ( position === this.slidesPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tthis.slidesPosition = position;\n\t\t\t\n\t\t\tif ( ( this.supportedAnimation === 'css-3d' || this.supportedAnimation === 'css-2d' ) && this.isIE === false ) {\n\t\t\t\tvar transition,\n\t\t\t\t\tleft = this.settings.orientation === 'horizontal' ? position : 0,\n\t\t\t\t\ttop = this.settings.orientation === 'horizontal' ? 0 : position;\n\n\t\t\t\tif ( this.supportedAnimation === 'css-3d' ) {\n\t\t\t\t\tcss[ this.vendorPrefix + 'transform' ] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n\t\t\t\t} else {\n\t\t\t\t\tcss[ this.vendorPrefix + 'transform' ] = 'translate(' + left + 'px, ' + top + 'px)';\n\t\t\t\t}\n\n\t\t\t\tif ( typeof instant !== 'undefined' && instant === true ) {\n\t\t\t\t\ttransition = '';\n\t\t\t\t} else {\n\t\t\t\t\tthis.$slides.addClass( 'sp-animated' );\n\t\t\t\t\ttransition = this.vendorPrefix + 'transform ' + this.settings.slideAnimationDuration / 1000 + 's';\n\n\t\t\t\t\tthis.$slides.on( this.transitionEvent, function( event ) {\n\t\t\t\t\t\tif ( event.target !== event.currentTarget ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthat.$slides.off( that.transitionEvent );\n\t\t\t\t\t\tthat.$slides.removeClass( 'sp-animated' );\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tcss[ this.vendorPrefix + 'transition' ] = transition;\n\n\t\t\t\tthis.$slides.css( css );\n\t\t\t} else {\n\t\t\t\tcss[ 'margin-' + this.positionProperty ] = position;\n\n\t\t\t\tif ( typeof instant !== 'undefined' && instant === true ) {\n\t\t\t\t\tthis.$slides.css( css );\n\t\t\t\t} else {\n\t\t\t\t\tthis.$slides.addClass( 'sp-animated' );\n\t\t\t\t\tthis.$slides.animate( css, this.settings.slideAnimationDuration, function() {\n\t\t\t\t\t\tthat.$slides.removeClass( 'sp-animated' );\n\n\t\t\t\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Stop the movement of the slides\n\t\t_stopMovement: function() {\n\t\t\tvar css = {};\n\n\t\t\tif ( ( this.supportedAnimation === 'css-3d' || this.supportedAnimation === 'css-2d' ) && this.isIE === false) {\n\n\t\t\t\t// Get the current position of the slides by parsing the 'transform' property\n\t\t\t\tvar\tmatrixString = this.$slides.css( this.vendorPrefix + 'transform' ),\n\t\t\t\t\tmatrixType = matrixString.indexOf( 'matrix3d' ) !== -1 ? 'matrix3d' : 'matrix',\n\t\t\t\t\tmatrixArray = matrixString.replace( matrixType, '' ).match( /-?[0-9\\.]+/g ),\n\t\t\t\t\tleft = matrixType === 'matrix3d' ? parseInt( matrixArray[ 12 ], 10 ) : parseInt( matrixArray[ 4 ], 10 ),\n\t\t\t\t\ttop = matrixType === 'matrix3d' ? parseInt( matrixArray[ 13 ], 10 ) : parseInt( matrixArray[ 5 ], 10 );\n\t\t\t\t\t\n\t\t\t\t// Set the transform property to the value that the transform had when the function was called\n\t\t\t\tif ( this.supportedAnimation === 'css-3d' ) {\n\t\t\t\t\tcss[ this.vendorPrefix + 'transform' ] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n\t\t\t\t} else {\n\t\t\t\t\tcss[ this.vendorPrefix + 'transform' ] = 'translate(' + left + 'px, ' + top + 'px)';\n\t\t\t\t}\n\n\t\t\t\tcss[ this.vendorPrefix + 'transition' ] = '';\n\n\t\t\t\tthis.$slides.css( css );\n\t\t\t\tthis.$slides.off( this.transitionEvent );\n\t\t\t\tthis.slidesPosition = this.settings.orientation === 'horizontal' ? left : top;\n\t\t\t} else {\n\t\t\t\tthis.$slides.stop();\n\t\t\t\tthis.slidesPosition = parseInt( this.$slides.css( 'margin-' + this.positionProperty ), 10 );\n\t\t\t}\n\n\t\t\tthis.$slides.removeClass( 'sp-animated' );\n\t\t},\n\n\t\t// Resize the height of the slider to the specified value\n\t\t_resizeHeightTo: function( height ) {\n\t\t\tvar that = this,\n\t\t\t\tcss = { 'height': height };\n\n\t\t\tif ( this.supportedAnimation === 'css-3d' || this.supportedAnimation === 'css-2d' ) {\n\t\t\t\tcss[ this.vendorPrefix + 'transition' ] = 'height ' + this.settings.heightAnimationDuration / 1000 + 's';\n\n\t\t\t\tthis.$slidesMask.off( this.transitionEvent );\n\t\t\t\tthis.$slidesMask.on( this.transitionEvent, function( event ) {\n\t\t\t\t\tif ( event.target !== event.currentTarget ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthat.$slidesMask.off( that.transitionEvent );\n\n\t\t\t\t\t// Fire the 'resizeHeightComplete' event\n\t\t\t\t\tthat.trigger({ type: 'resizeHeightComplete' });\n\t\t\t\t\tif ( $.isFunction( that.settings.resizeHeightComplete ) ) {\n\t\t\t\t\t\tthat.settings.resizeHeightComplete.call( that, { type: 'resizeHeightComplete' } );\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthis.$slidesMask.css( css );\n\t\t\t} else {\n\t\t\t\tthis.$slidesMask.stop().animate( css, this.settings.heightAnimationDuration, function( event ) {\n\t\t\t\t\t// Fire the 'resizeHeightComplete' event\n\t\t\t\t\tthat.trigger({ type: 'resizeHeightComplete' });\n\t\t\t\t\tif ( $.isFunction( that.settings.resizeHeightComplete ) ) {\n\t\t\t\t\t\tthat.settings.resizeHeightComplete.call( that, { type: 'resizeHeightComplete' } );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the slider instance\n\t\tdestroy: function() {\n\t\t\t// Remove the stored reference to this instance\n\t\t\tthis.$slider.removeData( 'sliderPro' );\n\t\t\t\n\t\t\t// Clean the CSS\n\t\t\tthis.$slider.removeAttr( 'style' );\n\t\t\tthis.$slides.removeAttr( 'style' );\n\n\t\t\t// Remove event listeners\n\t\t\tthis.off( 'update.' + NS );\n\t\t\t$( window ).off( 'resize.' + this.uniqueId + '.' + NS );\n\n\t\t\t// Destroy modules\n\t\t\tvar modules = $.SliderPro.modules;\n\n\t\t\tif ( typeof modules !== 'undefined' ) {\n\t\t\t\tfor ( var i = 0; i < modules.length; i++ ) {\n\t\t\t\t\tif ( typeof this[ 'destroy' + modules[ i ] ] !== 'undefined' ) {\n\t\t\t\t\t\tthis[ 'destroy' + modules[ i ] ]();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Destroy all slides\n\t\t\t$.each( this.slides, function( index, element ) {\n\t\t\t\telement.destroy();\n\t\t\t});\n\n\t\t\tthis.slides.length = 0;\n\n\t\t\t// Move the slides to their initial position in the DOM and \n\t\t\t// remove the container elements created dynamically.\n\t\t\tthis.$slides.prependTo( this.$slider );\n\t\t\tthis.$slidesContainer.remove();\n\t\t},\n\n\t\t// Set properties on runtime\n\t\t_setProperties: function( properties, store ) {\n\t\t\t// Parse the properties passed as an object\n\t\t\tfor ( var prop in properties ) {\n\t\t\t\tthis.settings[ prop ] = properties[ prop ];\n\n\t\t\t\t// Alter the original settings as well unless 'false' is passed to the 'store' parameter\n\t\t\t\tif ( store !== false ) {\n\t\t\t\t\tthis.originalSettings[ prop ] = properties[ prop ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.update();\n\t\t},\n\n\t\t// Attach an event handler to the slider\n\t\ton: function( type, callback ) {\n\t\t\treturn this.$slider.on( type, callback );\n\t\t},\n\n\t\t// Detach an event handler\n\t\toff: function( type ) {\n\t\t\treturn this.$slider.off( type );\n\t\t},\n\n\t\t// Trigger an event on the slider\n\t\ttrigger: function( data ) {\n\t\t\treturn this.$slider.triggerHandler( data );\n\t\t},\n\n\t\t// Return the slide at the specified index\n\t\tgetSlideAt: function( index ) {\n\t\t\treturn this.slides[ index ];\n\t\t},\n\n\t\t// Return the index of the currently opened slide\n\t\tgetSelectedSlide: function() {\n\t\t\treturn this.selectedSlideIndex;\n\t\t},\n\n\t\t// Return the total amount of slides\n\t\tgetTotalSlides: function() {\n\t\t\treturn this.slides.length;\n\t\t},\n\n\t\t// The default options of the slider\n\t\tdefaults: {\n\t\t\t// Width of the slide\n\t\t\twidth: 500,\n\n\t\t\t// Height of the slide\n\t\t\theight: 300,\n\n\t\t\t// Indicates if the slider is responsive\n\t\t\tresponsive: true,\n\n\t\t\t// The aspect ratio of the slider (width/height)\n\t\t\taspectRatio: -1,\n\n\t\t\t// The scale mode for images (cover, contain, exact and none)\n\t\t\timageScaleMode: 'cover',\n\n\t\t\t// Indicates if the image will be centered\n\t\t\tcenterImage: true,\n\n\t\t\t// Indicates if the image can be scaled up more than its original size\n\t\t\tallowScaleUp: true,\n\n\t\t\t// Indicates if height of the slider will be adjusted to the\n\t\t\t// height of the selected slide\n\t\t\tautoHeight: false,\n\n\t\t\t// Will maintain all the slides at the same height, but will allow the width\n\t\t\t// of the slides to be variable if the orientation of the slides is horizontal\n\t\t\t// and vice-versa if the orientation is vertical\n\t\t\tautoSlideSize: false,\n\n\t\t\t// Indicates the initially selected slide\n\t\t\tstartSlide: 0,\n\n\t\t\t// Indicates if the slides will be shuffled\n\t\t\tshuffle: false,\n\n\t\t\t// Indicates whether the slides will be arranged horizontally\n\t\t\t// or vertically. Can be set to 'horizontal' or 'vertical'.\n\t\t\torientation: 'horizontal',\n\n\t\t\t// Indicates if the size of the slider will be forced to 'fullWidth' or 'fullWindow'\n\t\t\tforceSize: 'none',\n\n\t\t\t// Indicates if the slider will be loopable\n\t\t\tloop: true,\n\n\t\t\t// The distance between slides\n\t\t\tslideDistance: 10,\n\n\t\t\t// The duration of the slide animation\n\t\t\tslideAnimationDuration: 700,\n\n\t\t\t// The duration of the height animation\n\t\t\theightAnimationDuration: 700,\n\n\t\t\t// Sets the size of the visible area, allowing the increase of it in order\n\t\t\t// to make more slides visible.\n\t\t\t// By default, only the selected slide will be visible. \n\t\t\tvisibleSize: 'auto',\n\n\t\t\t// Indicates whether the selected slide will be in the center of the slider, when there\n\t\t\t// are more slides visible at a time. If set to false, the selected slide will be in the\n\t\t\t// left side of the slider.\n\t\t\tcenterSelectedSlide: true,\n\n\t\t\t// Indicates if the direction of the slider will be from right to left,\n\t\t\t// instead of the default left to right\n\t\t\trightToLeft: false,\n\n\t\t\t// Breakpoints for allowing the slider's options to be changed\n\t\t\t// based on the size of the window.\n\t\t\tbreakpoints: null,\n\n\t\t\t// Called when the slider is initialized\n\t\t\tinit: function() {},\n\n\t\t\t// Called when the slider is updates\n\t\t\tupdate: function() {},\n\n\t\t\t// Called when the slider is resized\n\t\t\tsliderResize: function() {},\n\n\t\t\t// Called when a new slide is selected\n\t\t\tgotoSlide: function() {},\n\n\t\t\t// Called when the navigation to the newly selected slide is complete\n\t\t\tgotoSlideComplete: function() {},\n\n\t\t\t// Called when the height animation of the slider is complete\n\t\t\tresizeHeightComplete: function() {},\n\n\t\t\t// Called when a breakpoint is reached\n\t\t\tbreakpointReach: function() {}\n\t\t}\n\t};\n\n\tvar SliderProSlide = function( slide, index, settings ) {\n\n\t\t// Reference to the slide jQuery element\n\t\tthis.$slide = slide;\n\n\t\t// Reference to the main slide image\n\t\tthis.$mainImage = null;\n\n\t\t// Reference to the container that will hold the main image\n\t\tthis.$imageContainer = null;\n\n\t\t// Indicates whether the slide has a main image\n\t\tthis.hasMainImage = false;\n\n\t\t// Indicates whether the main image is loaded\n\t\tthis.isMainImageLoaded = false;\n\n\t\t// Indicates whether the main image is in the process of being loaded\n\t\tthis.isMainImageLoading = false;\n\n\t\t// Indicates whether the slide has any image. There could be other images (i.e., in layers)\n\t\t// besides the main slide image.\n\t\tthis.hasImages = false;\n\n\t\t// Indicates if all the images in the slide are loaded\n\t\tthis.areImagesLoaded = false;\n\n\t\t// Indicates if the images inside the slide are in the process of being loaded\n\t\tthis.areImagesLoading = false;\n\n\t\t// The width and height of the slide\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\n\t\t// Reference to the global settings of the slider\n\t\tthis.settings = settings;\n\n\t\t// Set the index of the slide\n\t\tthis.setIndex( index );\n\n\t\t// Initialize the slide\n\t\tthis._init();\n\t};\n\n\tSliderProSlide.prototype = {\n\n\t\t// The starting point for the slide\n\t\t_init: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Mark the slide as initialized\n\t\t\tthis.$slide.attr( 'data-init', true );\n\n\t\t\t// Get the main slide image if there is one\n\t\t\tthis.$mainImage = this.$slide.find( '.sp-image' ).length !== 0 ? this.$slide.find( '.sp-image' ) : null;\n\n\t\t\t// If there is a main slide image, create a container for it and add the image to this container.\n\t\t\t// The container will allow the isolation of the image from the rest of the slide's content. This is\n\t\t\t// helpful when you want to show some content below the image and not cover it.\n\t\t\tif ( this.$mainImage !== null ) {\n\t\t\t\tthis.hasMainImage = true;\n\n\t\t\t\tthis.$imageContainer = $( '<div class=\"sp-image-container\"></div>' ).prependTo( this.$slide );\n\n\t\t\t\tif ( this.$mainImage.parent( 'a' ).length !== 0 ) {\n\t\t\t\t\tthis.$mainImage.parent( 'a' ).appendTo( this.$imageContainer );\n\t\t\t\t} else {\n\t\t\t\t\tthis.$mainImage.appendTo( this.$imageContainer );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.hasImages = this.$slide.find( 'img' ).length !== 0 ? true : false;\n\t\t},\n\n\t\t// Set the size of the slide\n\t\tsetSize: function( width, height ) {\n\t\t\tvar that = this;\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.$slide.css({\n\t\t\t\t'width': this.width,\n\t\t\t\t'height': this.height\n\t\t\t});\n\n\t\t\tif ( this.hasMainImage === true ) {\n\n\t\t\t\t// Initially set the width and height of the container to the width and height\n\t\t\t\t// specified in the settings. This will prevent content overflowing if the width or height\n\t\t\t\t// are 'auto'. The 'auto' value will be passed only after the image is loaded.\n\t\t\t\tthis.$imageContainer.css({\n\t\t\t\t\t'width': this.settings.width,\n\t\t\t\t\t'height': this.settings.height\n\t\t\t\t});\n\n\t\t\t\t// Resize the main image if it's loaded. If the 'data-src' attribute is present it means\n\t\t\t\t// that the image will be lazy-loaded\n\t\t\t\tif ( typeof this.$mainImage.attr( 'data-src' ) === 'undefined' ) {\n\t\t\t\t\tthis.resizeMainImage();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Get the size (width and height) of the slide\n\t\tgetSize: function() {\n\t\t\tvar that = this,\n\t\t\t\tsize;\n\n\t\t\t// Check if all images have loaded, and if they have, return the size, else, return\n\t\t\t// the original width and height of the slide\n\t\t\tif ( this.hasImages === true && this.areImagesLoaded === false && this.areImagesLoading === false ) {\n\t\t\t\tthis.areImagesLoading = true;\n\t\t\t\t\n\t\t\t\tvar status = SliderProUtils.checkImagesStatus( this.$slide );\n\n\t\t\t\tif ( status !== 'complete' ) {\n\t\t\t\t\tSliderProUtils.checkImagesComplete( this.$slide, function() {\n\t\t\t\t\t\tthat.areImagesLoaded = true;\n\t\t\t\t\t\tthat.areImagesLoading = false;\n\t\t\t\t\t\tthat.trigger({ type: 'imagesLoaded.' + NS, index: that.index });\n\t\t\t\t\t});\n\n\t\t\t\t\t// if the image is not loaded yet, return the original width and height of the slider\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'width': this.settings.width,\n\t\t\t\t\t\t'height': this.settings.height\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsize = this.calculateSize();\n\n\t\t\treturn {\n\t\t\t\t'width': size.width,\n\t\t\t\t'height': size.height\n\t\t\t};\n\t\t},\n\n\t\t// Calculate the width and height of the slide by going\n\t\t// through all the child elements and measuring their 'bottom'\n\t\t// and 'right' properties. The element with the biggest\n\t\t// 'right'/'bottom' property will determine the slide's\n\t\t// width/height.\n\t\tcalculateSize: function() {\n\t\t\tvar width = this.$slide.width(),\n\t\t\t\theight = this.$slide.height();\n\n\t\t\tthis.$slide.children().each(function( index, element ) {\n\t\t\t\tvar child = $( element );\n\n\t\t\t\tif ( child.is( ':hidden' ) === true ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar\trect = element.getBoundingClientRect(),\n\t\t\t\t\tbottom = child.position().top + ( rect.bottom - rect.top ),\n\t\t\t\t\tright = child.position().left + ( rect.right - rect.left );\n\n\t\t\t\tif ( bottom > height ) {\n\t\t\t\t\theight = bottom;\n\t\t\t\t}\n\n\t\t\t\tif ( right > width ) {\n\t\t\t\t\twidth = right;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\t},\n\n\t\t// Resize the main image.\n\t\t// \n\t\t// Call this when the slide resizes or when the main image has changed to a different image.\n\t\tresizeMainImage: function( isNewImage ) {\n\t\t\tvar that = this;\n\n\t\t\t// If the main image has changed, reset the 'flags'\n\t\t\tif ( isNewImage === true ) {\n\t\t\t\tthis.isMainImageLoaded = false;\n\t\t\t\tthis.isMainImageLoading = false;\n\t\t\t}\n\n\t\t\t// If the image was not loaded yet and it's not in the process of being loaded, load it\n\t\t\tif ( this.isMainImageLoaded === false && this.isMainImageLoading === false ) {\n\t\t\t\tthis.isMainImageLoading = true;\n\n\t\t\t\tSliderProUtils.checkImagesComplete( this.$mainImage, function() {\n\t\t\t\t\tthat.isMainImageLoaded = true;\n\t\t\t\t\tthat.isMainImageLoading = false;\n\t\t\t\t\tthat.resizeMainImage();\n\t\t\t\t\tthat.trigger({ type: 'imagesLoaded.' + NS, index: that.index });\n\t\t\t\t});\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the size of the image container element to the proper 'width' and 'height'\n\t\t\t// values, as they were calculated. Previous values were the 'width' and 'height'\n\t\t\t// from the settings. \n\t\t\tthis.$imageContainer.css({\n\t\t\t\t'width': this.width,\n\t\t\t\t'height': this.height\n\t\t\t});\n\n\t\t\tif ( this.settings.allowScaleUp === false ) {\n\t\t\t\t// reset the image to its natural size\n\t\t\t\tthis.$mainImage.css({ 'width': '', 'height': '', 'maxWidth': '', 'maxHeight': '' });\n\n\t\t\t\t// set the boundaries\n\t\t\t\tthis.$mainImage.css({ 'maxWidth': this.$mainImage.width(), 'maxHeight': this.$mainImage.height() });\n\t\t\t}\n\n\t\t\t// After the main image has loaded, resize it\n\t\t\tif ( this.settings.autoSlideSize === true ) {\n\t\t\t\tif ( this.settings.orientation === 'horizontal' ) {\n\t\t\t\t\tthis.$mainImage.css({ width: 'auto', height: '100%' });\n\n\t\t\t\t\t// resize the slide's width to a fixed value instead of 'auto', to\n\t\t\t\t\t// prevent incorrect sizing caused by links added to the main image\n\t\t\t\t\tthis.$slide.css( 'width', this.$mainImage.width() );\n\t\t\t\t} else if ( this.settings.orientation === 'vertical' ) {\n\t\t\t\t\tthis.$mainImage.css({ width: '100%', height: 'auto' });\n\n\t\t\t\t\t// resize the slide's height to a fixed value instead of 'auto', to\n\t\t\t\t\t// prevent incorrect sizing caused by links added to the main image\n\t\t\t\t\tthis.$slide.css( 'height', this.$mainImage.height() );\n\t\t\t\t}\n\t\t\t} else if ( this.settings.autoHeight === true ) {\n\t\t\t\tthis.$mainImage.css({ width: '100%', height: 'auto' });\n\t\t\t} else {\n\t\t\t\tif ( this.settings.imageScaleMode === 'cover' ) {\n\t\t\t\t\tif ( this.$mainImage.width() / this.$mainImage.height() <= this.$slide.width() / this.$slide.height() ) {\n\t\t\t\t\t\tthis.$mainImage.css({ width: '100%', height: 'auto' });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.$mainImage.css({ width: 'auto', height: '100%' });\n\t\t\t\t\t}\n\t\t\t\t} else if ( this.settings.imageScaleMode === 'contain' ) {\n\t\t\t\t\tif ( this.$mainImage.width() / this.$mainImage.height() >= this.$slide.width() / this.$slide.height() ) {\n\t\t\t\t\t\tthis.$mainImage.css({ width: '100%', height: 'auto' });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.$mainImage.css({ width: 'auto', height: '100%' });\n\t\t\t\t\t}\n\t\t\t\t} else if ( this.settings.imageScaleMode === 'exact' ) {\n\t\t\t\t\tthis.$mainImage.css({ width: '100%', height: '100%' });\n\t\t\t\t}\n\n\t\t\t\tif ( this.settings.centerImage === true ) {\n\t\t\t\t\tthis.$mainImage.css({ 'marginLeft': ( this.$imageContainer.width() - this.$mainImage.width() ) * 0.5, 'marginTop': ( this.$imageContainer.height() - this.$mainImage.height() ) * 0.5 });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the slide\n\t\tdestroy: function() {\n\t\t\t// Clean the slide element from attached styles and data\n\t\t\tthis.$slide.removeAttr( 'style' );\n\t\t\tthis.$slide.removeAttr( 'data-init' );\n\t\t\tthis.$slide.removeAttr( 'data-index' );\n\t\t\tthis.$slide.removeAttr( 'data-loaded' );\n\n\t\t\t// If there is a main image, remove its container\n\t\t\tif ( this.hasMainImage === true ) {\n\t\t\t\tthis.$slide.find( '.sp-image' )\n\t\t\t\t\t.removeAttr( 'style' )\n\t\t\t\t\t.appendTo( this.$slide );\n\n\t\t\t\tthis.$slide.find( '.sp-image-container' ).remove();\n\t\t\t}\n\t\t},\n\n\t\t// Return the index of the slide\n\t\tgetIndex: function() {\n\t\t\treturn this.index;\n\t\t},\n\n\t\t// Set the index of the slide\n\t\tsetIndex: function( index ) {\n\t\t\tthis.index = index;\n\t\t\tthis.$slide.attr( 'data-index', this.index );\n\t\t},\n\n\t\t// Attach an event handler to the slide\n\t\ton: function( type, callback ) {\n\t\t\treturn this.$slide.on( type, callback );\n\t\t},\n\n\t\t// Detach an event handler to the slide\n\t\toff: function( type ) {\n\t\t\treturn this.$slide.off( type );\n\t\t},\n\n\t\t// Trigger an event on the slide\n\t\ttrigger: function( data ) {\n\t\t\treturn this.$slide.triggerHandler( data );\n\t\t}\n\t};\n\n\twindow.SliderPro = SliderPro;\n\twindow.SliderProSlide = SliderProSlide;\n\n\t$.fn.sliderPro = function( options ) {\n\t\tvar args = Array.prototype.slice.call( arguments, 1 );\n\n\t\treturn this.each(function() {\n\t\t\t// Instantiate the slider or alter it\n\t\t\tif ( typeof $( this ).data( 'sliderPro' ) === 'undefined' ) {\n\t\t\t\tvar newInstance = new SliderPro( this, options );\n\n\t\t\t\t// Store a reference to the instance created\n\t\t\t\t$( this ).data( 'sliderPro', newInstance );\n\t\t\t} else if ( typeof options !== 'undefined' ) {\n\t\t\t\tvar\tcurrentInstance = $( this ).data( 'sliderPro' );\n\n\t\t\t\t// Check the type of argument passed\n\t\t\t\tif ( typeof currentInstance[ options ] === 'function' ) {\n\t\t\t\t\tcurrentInstance[ options ].apply( currentInstance, args );\n\t\t\t\t} else if ( typeof currentInstance.settings[ options ] !== 'undefined' ) {\n\t\t\t\t\tvar obj = {};\n\t\t\t\t\tobj[ options ] = args[ 0 ];\n\t\t\t\t\tcurrentInstance._setProperties( obj );\n\t\t\t\t} else if ( typeof options === 'object' ) {\n\t\t\t\t\tcurrentInstance._setProperties( options );\n\t\t\t\t} else {\n\t\t\t\t\t$.error( options + ' does not exist in sliderPro.' );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t// Contains useful utility functions\n\tvar SliderProUtils = {\n\n\t\t// Indicates what type of animations are supported in the current browser\n\t\t// Can be CSS 3D, CSS 2D or JavaScript\n\t\tsupportedAnimation: null,\n\n\t\t// Indicates the required vendor prefix for the current browser\n\t\tvendorPrefix: null,\n\n\t\t// Indicates the name of the transition's complete event for the current browser\n\t\ttransitionEvent: null,\n\n\t\t// Indicates if the current browser is Internet Explorer (any version)\n\t\tisIE: null,\n\n\t\t// Check whether CSS3 3D or 2D transforms are supported. If they aren't, use JavaScript animations\n\t\tgetSupportedAnimation: function() {\n\t\t\tif ( this.supportedAnimation !== null ) {\n\t\t\t\treturn this.supportedAnimation;\n\t\t\t}\n\n\t\t\tvar element = document.body || document.documentElement,\n\t\t\t\telementStyle = element.style,\n\t\t\t\tisCSSTransitions = typeof elementStyle.transition !== 'undefined' ||\n\t\t\t\t\t\t\t\t\ttypeof elementStyle.WebkitTransition !== 'undefined' ||\n\t\t\t\t\t\t\t\t\ttypeof elementStyle.MozTransition !== 'undefined' ||\n\t\t\t\t\t\t\t\t\ttypeof elementStyle.OTransition !== 'undefined';\n\n\t\t\tif ( isCSSTransitions === true ) {\n\t\t\t\tvar div = document.createElement( 'div' );\n\n\t\t\t\t// Check if 3D transforms are supported\n\t\t\t\tif ( typeof div.style.WebkitPerspective !== 'undefined' || typeof div.style.perspective !== 'undefined' ) {\n\t\t\t\t\tthis.supportedAnimation = 'css-3d';\n\t\t\t\t}\n\n\t\t\t\t// Additional checks for Webkit\n\t\t\t\tif ( this.supportedAnimation === 'css-3d' && typeof div.styleWebkitPerspective !== 'undefined' ) {\n\t\t\t\t\tvar style = document.createElement( 'style' );\n\t\t\t\t\tstyle.textContent = '@media (transform-3d),(-webkit-transform-3d){#test-3d{left:9px;position:absolute;height:5px;margin:0;padding:0;border:0;}}';\n\t\t\t\t\tdocument.getElementsByTagName( 'head' )[0].appendChild( style );\n\n\t\t\t\t\tdiv.id = 'test-3d';\n\t\t\t\t\tdocument.body.appendChild( div );\n\n\t\t\t\t\tif ( ! ( div.offsetLeft === 9 && div.offsetHeight === 5 ) ) {\n\t\t\t\t\t\tthis.supportedAnimation = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tstyle.parentNode.removeChild( style );\n\t\t\t\t\tdiv.parentNode.removeChild( div );\n\t\t\t\t}\n\n\t\t\t\t// If CSS 3D transforms are not supported, check if 2D transforms are supported\n\t\t\t\tif ( this.supportedAnimation === null && ( typeof div.style['-webkit-transform'] !== 'undefined' || typeof div.style.transform !== 'undefined' ) ) {\n\t\t\t\t\tthis.supportedAnimation = 'css-2d';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.supportedAnimation = 'javascript';\n\t\t\t}\n\t\t\t\n\t\t\treturn this.supportedAnimation;\n\t\t},\n\n\t\t// Check what vendor prefix should be used in the current browser\n\t\tgetVendorPrefix: function() {\n\t\t\tif ( this.vendorPrefix !== null ) {\n\t\t\t\treturn this.vendorPrefix;\n\t\t\t}\n\n\t\t\tvar div = document.createElement( 'div' ),\n\t\t\t\tprefixes = [ 'Webkit', 'Moz', 'ms', 'O' ];\n\t\t\t\n\t\t\tif ( 'transform' in div.style ) {\n\t\t\t\tthis.vendorPrefix = '';\n\t\t\t\treturn this.vendorPrefix;\n\t\t\t}\n\t\t\t\n\t\t\tfor ( var i = 0; i < prefixes.length; i++ ) {\n\t\t\t\tif ( ( prefixes[ i ] + 'Transform' ) in div.style ) {\n\t\t\t\t\tthis.vendorPrefix = '-' + prefixes[ i ].toLowerCase() + '-';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this.vendorPrefix;\n\t\t},\n\n\t\t// Check the name of the transition's complete event in the current browser\n\t\tgetTransitionEvent: function() {\n\t\t\tif ( this.transitionEvent !== null ) {\n\t\t\t\treturn this.transitionEvent;\n\t\t\t}\n\n\t\t\tvar div = document.createElement( 'div' ),\n\t\t\t\ttransitions = {\n\t\t\t\t\t'transition': 'transitionend',\n\t\t\t\t\t'WebkitTransition': 'webkitTransitionEnd',\n\t\t\t\t\t'MozTransition': 'transitionend',\n\t\t\t\t\t'OTransition': 'oTransitionEnd'\n\t\t\t\t};\n\n\t\t\tfor ( var transition in transitions ) {\n\t\t\t\tif ( transition in div.style ) {\n\t\t\t\t\tthis.transitionEvent = transitions[ transition ];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.transitionEvent;\n\t\t},\n\n\t\t// If a single image is passed, check if it's loaded.\n\t\t// If a different element is passed, check if there are images\n\t\t// inside it, and check if these images are loaded.\n\t\tcheckImagesComplete: function( target, callback ) {\n\t\t\tvar that = this,\n\n\t\t\t\t// Check the initial status of the image(s)\n\t\t\t\tstatus = this.checkImagesStatus( target );\n\n\t\t\t// If there are loading images, wait for them to load.\n\t\t\t// If the images are loaded, call the callback function directly.\n\t\t\tif ( status === 'loading' ) {\n\t\t\t\tvar checkImages = setInterval(function() {\n\t\t\t\t\tstatus = that.checkImagesStatus( target );\n\n\t\t\t\t\tif ( status === 'complete' ) {\n\t\t\t\t\t\tclearInterval( checkImages );\n\n\t\t\t\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, 100 );\n\t\t\t} else if ( typeof callback === 'function' ) {\n\t\t\t\tcallback();\n\t\t\t}\n\n\t\t\treturn status;\n\t\t},\n\n\t\tcheckImagesStatus: function( target ) {\n\t\t\tvar status = 'complete';\n\n\t\t\tif ( target.is( 'img' ) && target[0].complete === false ) {\n\t\t\t\tstatus = 'loading';\n\t\t\t} else {\n\t\t\t\ttarget.find( 'img' ).each(function( index ) {\n\t\t\t\t\tvar image = $( this )[0];\n\n\t\t\t\t\tif ( image.complete === false ) {\n\t\t\t\t\t\tstatus = 'loading';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn status;\n\t\t},\n\n\t\tcheckIE: function() {\n\t\t\tif ( this.isIE !== null ) {\n\t\t\t\treturn this.isIE;\n\t\t\t}\n\n\t\t\tvar userAgent = window.navigator.userAgent,\n\t\t\t\tmsie = userAgent.indexOf( 'MSIE' );\n\n\t\t\tif ( userAgent.indexOf( 'MSIE' ) !== -1 || userAgent.match( /Trident.*rv\\:11\\./ ) ) {\n\t\t\t\tthis.isIE = true;\n\t\t\t} else {\n\t\t\t\tthis.isIE = false;\n\t\t\t}\n\n\t\t\treturn this.isIE;\n\t\t}\n\t};\n\n\twindow.SliderProUtils = SliderProUtils;\n\n})( window, jQuery );\n\n// Thumbnails module for Slider Pro.\n// \n// Adds the possibility to create a thumbnail scroller, each thumbnail\n// corresponding to a slide.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\tvar NS = 'Thumbnails.' + $.SliderPro.namespace;\n\n\tvar Thumbnails = {\n\n\t\t// Reference to the thumbnail scroller \n\t\t$thumbnails: null,\n\n\t\t// Reference to the container of the thumbnail scroller\n\t\t$thumbnailsContainer: null,\n\n\t\t// List of Thumbnail objects\n\t\tthumbnails: null,\n\n\t\t// Index of the selected thumbnail\n\t\tselectedThumbnailIndex: 0,\n\n\t\t// Total size (width or height, depending on the orientation) of the thumbnails\n\t\tthumbnailsSize: 0,\n\n\t\t// Size of the thumbnail's container\n\t\tthumbnailsContainerSize: 0,\n\n\t\t// The position of the thumbnail scroller inside its container\n\t\tthumbnailsPosition: 0,\n\n\t\t// Orientation of the thumbnails\n\t\tthumbnailsOrientation: null,\n\n\t\t// Indicates the 'left' or 'top' position based on the orientation of the thumbnails\n\t\tthumbnailsPositionProperty: null,\n\n\t\t// Indicates if there are thumbnails in the slider\n\t\tisThumbnailScroller: false,\n\n\t\tinitThumbnails: function() {\n\t\t\tvar that = this;\n\n\t\t\tthis.thumbnails = [];\n\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._thumbnailsOnUpdate, this ) );\n\t\t\tthis.on( 'sliderResize.' + NS, $.proxy( this._thumbnailsOnResize, this ) );\n\t\t\tthis.on( 'gotoSlide.' + NS, function( event ) {\n\t\t\t\tthat._gotoThumbnail( event.index );\n\t\t\t});\n\t\t},\n\n\t\t// Called when the slider is updated\n\t\t_thumbnailsOnUpdate: function() {\n\t\t\tvar that = this;\n\n\t\t\tif ( this.$slider.find( '.sp-thumbnail' ).length === 0 && this.thumbnails.length === 0 ) {\n\t\t\t\tthis.isThumbnailScroller = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.isThumbnailScroller = true;\n\n\t\t\t// Create the container of the thumbnail scroller, if it wasn't created yet\n\t\t\tif ( this.$thumbnailsContainer === null ) {\n\t\t\t\tthis.$thumbnailsContainer = $( '<div class=\"sp-thumbnails-container\"></div>' ).insertAfter( this.$slidesContainer );\n\t\t\t}\n\n\t\t\t// If the thumbnails' main container doesn't exist, create it, and get a reference to it\n\t\t\tif ( this.$thumbnails === null ) {\n\t\t\t\tif ( this.$slider.find( '.sp-thumbnails' ).length !== 0 ) {\n\t\t\t\t\tthis.$thumbnails = this.$slider.find( '.sp-thumbnails' ).appendTo( this.$thumbnailsContainer );\n\n\t\t\t\t\t// Shuffle/randomize the thumbnails\n\t\t\t\t\tif ( this.settings.shuffle === true ) {\n\t\t\t\t\t\tvar thumbnails = this.$thumbnails.find( '.sp-thumbnail' ),\n\t\t\t\t\t\t\tshuffledThumbnails = [];\n\n\t\t\t\t\t\t// Reposition the thumbnails based on the order of the indexes in the\n\t\t\t\t\t\t// 'shuffledIndexes' array\n\t\t\t\t\t\t$.each( this.shuffledIndexes, function( index, element ) {\n\t\t\t\t\t\t\tvar $thumbnail = $( thumbnails[ element ] );\n\n\t\t\t\t\t\t\tif ( $thumbnail.parent( 'a' ).length !== 0 ) {\n\t\t\t\t\t\t\t\t$thumbnail = $thumbnail.parent( 'a' );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tshuffledThumbnails.push( $thumbnail );\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Append the sorted thumbnails to the thumbnail scroller\n\t\t\t\t\t\tthis.$thumbnails.empty().append( shuffledThumbnails ) ;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.$thumbnails = $( '<div class=\"sp-thumbnails\"></div>' ).appendTo( this.$thumbnailsContainer );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if there are thumbnails inside the slides and move them in the thumbnails container\n\t\t\tthis.$slides.find( '.sp-thumbnail' ).each( function( index ) {\n\t\t\t\tvar $thumbnail = $( this ),\n\t\t\t\t\tthumbnailIndex = $thumbnail.parents( '.sp-slide' ).index(),\n\t\t\t\t\tlastThumbnailIndex = that.$thumbnails.find( '.sp-thumbnail' ).length - 1;\n\n\t\t\t\tif ( $thumbnail.parent( 'a' ).length !== 0 ) {\n\t\t\t\t\t$thumbnail = $thumbnail.parent( 'a' );\n\t\t\t\t}\n\n\t\t\t\t// If the index of the slide that contains the thumbnail is greater than the total number\n\t\t\t\t// of thumbnails from the thumbnails container, position the thumbnail at the end.\n\t\t\t\t// Otherwise, add the thumbnails at the corresponding position.\n\t\t\t\tif ( thumbnailIndex > lastThumbnailIndex ) {\n\t\t\t\t\t$thumbnail.appendTo( that.$thumbnails );\n\t\t\t\t} else {\n\t\t\t\t\t$thumbnail.insertBefore( that.$thumbnails.find( '.sp-thumbnail' ).eq( thumbnailIndex ) );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Loop through the Thumbnail objects and if a corresponding element is not found in the DOM,\n\t\t\t// it means that the thumbnail might have been removed. In this case, destroy that Thumbnail instance.\n\t\t\tfor ( var i = this.thumbnails.length - 1; i >= 0; i-- ) {\n\t\t\t\tif ( this.$thumbnails.find( '.sp-thumbnail[data-index=\"' + i + '\"]' ).length === 0 ) {\n\t\t\t\t\tvar thumbnail = this.thumbnails[ i ];\n\n\t\t\t\t\tthumbnail.destroy();\n\t\t\t\t\tthis.thumbnails.splice( i, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Loop through the thumbnails and if there is any uninitialized thumbnail,\n\t\t\t// initialize it, else update the thumbnail's index.\n\t\t\tthis.$thumbnails.find( '.sp-thumbnail' ).each(function( index ) {\n\t\t\t\tvar $thumbnail = $( this );\n\n\t\t\t\tif ( typeof $thumbnail.attr( 'data-init' ) === 'undefined' ) {\n\t\t\t\t\tthat._createThumbnail( $thumbnail, index );\n\t\t\t\t} else {\n\t\t\t\t\tthat.thumbnails[ index ].setIndex( index );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Remove the previous class that corresponds to the position of the thumbnail scroller\n\t\t\tthis.$thumbnailsContainer.removeClass( 'sp-top-thumbnails sp-bottom-thumbnails sp-left-thumbnails sp-right-thumbnails' );\n\n\t\t\t// Check the position of the thumbnail scroller and assign it the appropriate class and styling\n\t\t\tif ( this.settings.thumbnailsPosition === 'top' ) {\n\t\t\t\tthis.$thumbnailsContainer.addClass( 'sp-top-thumbnails' );\n\t\t\t\tthis.thumbnailsOrientation = 'horizontal';\n\t\t\t} else if ( this.settings.thumbnailsPosition === 'bottom' ) {\n\t\t\t\tthis.$thumbnailsContainer.addClass( 'sp-bottom-thumbnails' );\n\t\t\t\tthis.thumbnailsOrientation = 'horizontal';\n\t\t\t} else if ( this.settings.thumbnailsPosition === 'left' ) {\n\t\t\t\tthis.$thumbnailsContainer.addClass( 'sp-left-thumbnails' );\n\t\t\t\tthis.thumbnailsOrientation = 'vertical';\n\t\t\t} else if ( this.settings.thumbnailsPosition === 'right' ) {\n\t\t\t\tthis.$thumbnailsContainer.addClass( 'sp-right-thumbnails' );\n\t\t\t\tthis.thumbnailsOrientation = 'vertical';\n\t\t\t}\n\n\t\t\t// Check if the pointer needs to be created\n\t\t\tif ( this.settings.thumbnailPointer === true ) {\n\t\t\t\tthis.$thumbnailsContainer.addClass( 'sp-has-pointer' );\n\t\t\t} else {\n\t\t\t\tthis.$thumbnailsContainer.removeClass( 'sp-has-pointer' );\n\t\t\t}\n\n\t\t\t// Mark the thumbnail that corresponds to the selected slide\n\t\t\tthis.selectedThumbnailIndex = this.selectedSlideIndex;\n\t\t\tthis.$thumbnails.find( '.sp-thumbnail-container' ).eq( this.selectedThumbnailIndex ).addClass( 'sp-selected-thumbnail' );\n\t\t\t\n\t\t\t// Calculate the total size of the thumbnails\n\t\t\tthis.thumbnailsSize = 0;\n\n\t\t\t$.each( this.thumbnails, function( index, thumbnail ) {\n\t\t\t\tthumbnail.setSize( that.settings.thumbnailWidth, that.settings.thumbnailHeight );\n\t\t\t\tthat.thumbnailsSize += that.thumbnailsOrientation === 'horizontal' ? thumbnail.getSize().width : thumbnail.getSize().height;\n\t\t\t});\n\n\t\t\t// Set the size of the thumbnails\n\t\t\tif ( this.thumbnailsOrientation === 'horizontal' ) {\n\t\t\t\tthis.$thumbnails.css({ 'width': this.thumbnailsSize, 'height': this.settings.thumbnailHeight });\n\t\t\t\tthis.$thumbnailsContainer.css( 'height', '' );\n\t\t\t\tthis.thumbnailsPositionProperty = 'left';\n\t\t\t} else {\n\t\t\t\tthis.$thumbnails.css({ 'width': this.settings.thumbnailWidth, 'height': this.thumbnailsSize });\n\t\t\t\tthis.$thumbnailsContainer.css( 'width', '' );\n\t\t\t\tthis.thumbnailsPositionProperty = 'top';\n\t\t\t}\n\n\t\t\t// Fire the 'thumbnailsUpdate' event\n\t\t\tthis.trigger({ type: 'thumbnailsUpdate' });\n\t\t\tif ( $.isFunction( this.settings.thumbnailsUpdate ) ) {\n\t\t\t\tthis.settings.thumbnailsUpdate.call( this, { type: 'thumbnailsUpdate' } );\n\t\t\t}\n\t\t},\n\n\t\t// Create an individual thumbnail\n\t\t_createThumbnail: function( element, index ) {\n\t\t\tvar that = this,\n\t\t\t\tthumbnail = new Thumbnail( element, this.$thumbnails, index );\n\n\t\t\t// When the thumbnail is clicked, navigate to the corresponding slide\n\t\t\tthumbnail.on( 'thumbnailClick.' + NS, function( event ) {\n\t\t\t\tthat.gotoSlide( event.index );\n\t\t\t});\n\n\t\t\t// Add the thumbnail at the specified index\n\t\t\tthis.thumbnails.splice( index, 0, thumbnail );\n\t\t},\n\n\t\t// Called when the slider is resized.\n\t\t// Resets the size and position of the thumbnail scroller container.\n\t\t_thumbnailsOnResize: function() {\n\t\t\tif ( this.isThumbnailScroller === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar that = this,\n\t\t\t\tnewThumbnailsPosition;\n\n\t\t\tif ( this.thumbnailsOrientation === 'horizontal' ) {\n\t\t\t\tthis.thumbnailsContainerSize = Math.min( this.$slidesMask.width(), this.thumbnailsSize );\n\t\t\t\tthis.$thumbnailsContainer.css( 'width', this.thumbnailsContainerSize );\n\n\t\t\t\t// Reduce the slide mask's height, to make room for the thumbnails\n\t\t\t\tif ( this.settings.forceSize === 'fullWindow' ) {\n\t\t\t\t\tthis.$slidesMask.css( 'height', this.$slidesMask.height() - this.$thumbnailsContainer.outerHeight( true ) );\n\n\t\t\t\t\t// Resize the slides\n\t\t\t\t\tthis.slideHeight = this.$slidesMask.height();\n\t\t\t\t\tthis._resizeSlides();\n\n\t\t\t\t\t// Re-arrange the slides\n\t\t\t\t\tthis._resetSlidesPosition();\n\t\t\t\t}\n\t\t\t} else if ( this.thumbnailsOrientation === 'vertical' ) {\n\n\t\t\t\t// Check if the width of the slide mask plus the width of the thumbnail scroller is greater than\n\t\t\t\t// the width of the slider's container and if that's the case, reduce the slides container width\n\t\t\t\t// in order to make the entire slider fit inside the slider's container.\n\t\t\t\tif ( this.$slidesMask.width() + this.$thumbnailsContainer.outerWidth( true ) > this.$slider.parent().width() ) {\n\t\t\t\t\t// Reduce the slider's width, to make room for the thumbnails\n\t\t\t\t\tif ( this.settings.forceSize === 'fullWidth' || this.settings.forceSize === 'fullWindow' ) {\n\t\t\t\t\t\tthis.$slider.css( 'max-width', $( window ).width() - this.$thumbnailsContainer.outerWidth( true ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.$slider.css( 'max-width', this.$slider.parent().width() - this.$thumbnailsContainer.outerWidth( true ) );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.$slidesMask.css( 'width', this.$slider.width() );\n\n\t\t\t\t\t// If the slides are vertically oriented, update the width and height (to maintain the aspect ratio)\n\t\t\t\t\t// of the slides.\n\t\t\t\t\tif ( this.settings.orientation === 'vertical' ) {\n\t\t\t\t\t\tthis.slideWidth = this.$slider.width();\n\n\t\t\t\t\t\tthis._resizeSlides();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Re-arrange the slides\n\t\t\t\t\tthis._resetSlidesPosition();\n\t\t\t\t}\n\n\t\t\t\tthis.thumbnailsContainerSize = Math.min( this.$slidesMask.height(), this.thumbnailsSize );\n\t\t\t\tthis.$thumbnailsContainer.css( 'height', this.thumbnailsContainerSize );\n\t\t\t}\n\n\t\t\t// If the total size of the thumbnails is smaller than the thumbnail scroller' container (which has\n\t\t\t// the same size as the slides container), it means that all the thumbnails will be visible, so set\n\t\t\t// the position of the thumbnail scroller to 0.\n\t\t\t// \n\t\t\t// If that's not the case, the thumbnail scroller will be positioned based on which thumbnail is selected.\n\t\t\tif ( this.thumbnailsSize <= this.thumbnailsContainerSize || this.$thumbnails.find( '.sp-selected-thumbnail' ).length === 0 ) {\n\t\t\t\tnewThumbnailsPosition = 0;\n\t\t\t} else {\n\t\t\t\tnewThumbnailsPosition = Math.max( - this.thumbnails[ this.selectedThumbnailIndex ].getPosition()[ this.thumbnailsPositionProperty ], this.thumbnailsContainerSize - this.thumbnailsSize );\n\t\t\t}\n\n\t\t\t// Add a padding to the slider, based on the thumbnail scroller's orientation, to make room\n\t\t\t// for the thumbnails.\n\t\t\tif ( this.settings.thumbnailsPosition === 'top' ) {\n\t\t\t\tthis.$slider.css({ 'paddingTop': this.$thumbnailsContainer.outerHeight( true ), 'paddingLeft': '', 'paddingRight': '' });\n\t\t\t} else if ( this.settings.thumbnailsPosition === 'bottom' ) {\n\t\t\t\tthis.$slider.css({ 'paddingTop': '', 'paddingLeft': '', 'paddingRight': '' });\n\t\t\t} else if ( this.settings.thumbnailsPosition === 'left' ) {\n\t\t\t\tthis.$slider.css({ 'paddingTop': '', 'paddingLeft': this.$thumbnailsContainer.outerWidth( true ), 'paddingRight': '' });\n\t\t\t} else if ( this.settings.thumbnailsPosition === 'right' ) {\n\t\t\t\tthis.$slider.css({ 'paddingTop': '', 'paddingLeft': '', 'paddingRight': this.$thumbnailsContainer.outerWidth( true ) });\n\t\t\t}\n\n\t\t\tthis._moveThumbnailsTo( newThumbnailsPosition, true );\n\t\t},\n\n\t\t// Selects the thumbnail at the indicated index and moves the thumbnail scroller\n\t\t// accordingly.\n\t\t_gotoThumbnail: function( index ) {\n\t\t\tif ( this.isThumbnailScroller === false || typeof this.thumbnails[ index ] === 'undefined' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar previousIndex = this.selectedThumbnailIndex,\n\t\t\t\tnewThumbnailsPosition = this.thumbnailsPosition;\n\n\t\t\tthis.selectedThumbnailIndex = index;\n\n\t\t\t// Set the 'selected' class to the appropriate thumbnail\n\t\t\tthis.$thumbnails.find( '.sp-selected-thumbnail' ).removeClass( 'sp-selected-thumbnail' );\n\t\t\tthis.$thumbnails.find( '.sp-thumbnail-container' ).eq( this.selectedThumbnailIndex ).addClass( 'sp-selected-thumbnail' );\n\n\t\t\t// Calculate the new position that the thumbnail scroller needs to go to.\n\t\t\t// \n\t\t\t// If the selected thumbnail has a higher index than the previous one, make sure that the thumbnail\n\t\t\t// that comes after the selected thumbnail will be visible, if the selected thumbnail is not the\n\t\t\t// last thumbnail in the list.\n\t\t\t// \n\t\t\t// If the selected thumbnail has a lower index than the previous one, make sure that the thumbnail\n\t\t\t// that's before the selected thumbnail will be visible, if the selected thumbnail is not the\n\t\t\t// first thumbnail in the list.\n\t\t\tif ( this.settings.rightToLeft === true && this.thumbnailsOrientation === 'horizontal' ) {\n\t\t\t\tif ( this.selectedThumbnailIndex >= previousIndex ) {\n\t\t\t\t\tvar rtlNextThumbnailIndex = this.selectedThumbnailIndex === this.thumbnails.length - 1 ? this.selectedThumbnailIndex : this.selectedThumbnailIndex + 1,\n\t\t\t\t\t\trtlNextThumbnail = this.thumbnails[ rtlNextThumbnailIndex ];\n\n\t\t\t\t\tif ( rtlNextThumbnail.getPosition().left < - this.thumbnailsPosition ) {\n\t\t\t\t\t\tnewThumbnailsPosition = - rtlNextThumbnail.getPosition().left;\n\t\t\t\t\t}\n\t\t\t\t} else if ( this.selectedThumbnailIndex < previousIndex ) {\n\t\t\t\t\tvar rtlPreviousThumbnailIndex = this.selectedThumbnailIndex === 0 ? this.selectedThumbnailIndex : this.selectedThumbnailIndex - 1,\n\t\t\t\t\t\trtlPreviousThumbnail = this.thumbnails[ rtlPreviousThumbnailIndex ],\n\t\t\t\t\t\trtlThumbnailsRightPosition = - this.thumbnailsPosition + this.thumbnailsContainerSize;\n\n\t\t\t\t\tif ( rtlPreviousThumbnail.getPosition().right > rtlThumbnailsRightPosition ) {\n\t\t\t\t\t\tnewThumbnailsPosition = this.thumbnailsPosition - ( rtlPreviousThumbnail.getPosition().right - rtlThumbnailsRightPosition );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( this.selectedThumbnailIndex >= previousIndex ) {\n\t\t\t\t\tvar nextThumbnailIndex = this.selectedThumbnailIndex === this.thumbnails.length - 1 ? this.selectedThumbnailIndex : this.selectedThumbnailIndex + 1,\n\t\t\t\t\t\tnextThumbnail = this.thumbnails[ nextThumbnailIndex ],\n\t\t\t\t\t\tnextThumbnailPosition = this.thumbnailsOrientation === 'horizontal' ? nextThumbnail.getPosition().right : nextThumbnail.getPosition().bottom,\n\t\t\t\t\t\tthumbnailsRightPosition = - this.thumbnailsPosition + this.thumbnailsContainerSize;\n\n\t\t\t\t\tif ( nextThumbnailPosition > thumbnailsRightPosition ) {\n\t\t\t\t\t\tnewThumbnailsPosition = this.thumbnailsPosition - ( nextThumbnailPosition - thumbnailsRightPosition );\n\t\t\t\t\t}\n\t\t\t\t} else if ( this.selectedThumbnailIndex < previousIndex ) {\n\t\t\t\t\tvar previousThumbnailIndex = this.selectedThumbnailIndex === 0 ? this.selectedThumbnailIndex : this.selectedThumbnailIndex - 1,\n\t\t\t\t\t\tpreviousThumbnail = this.thumbnails[ previousThumbnailIndex ],\n\t\t\t\t\t\tpreviousThumbnailPosition = this.thumbnailsOrientation === 'horizontal' ? previousThumbnail.getPosition().left : previousThumbnail.getPosition().top;\n\n\t\t\t\t\tif ( previousThumbnailPosition < - this.thumbnailsPosition ) {\n\t\t\t\t\t\tnewThumbnailsPosition = - previousThumbnailPosition;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Move the thumbnail scroller to the calculated position\n\t\t\tthis._moveThumbnailsTo( newThumbnailsPosition );\n\n\t\t\t// Fire the 'gotoThumbnail' event\n\t\t\tthis.trigger({ type: 'gotoThumbnail' });\n\t\t\tif ( $.isFunction( this.settings.gotoThumbnail ) ) {\n\t\t\t\tthis.settings.gotoThumbnail.call( this, { type: 'gotoThumbnail' });\n\t\t\t}\n\t\t},\n\n\t\t// Move the thumbnail scroller to the indicated position\n\t\t_moveThumbnailsTo: function( position, instant, callback ) {\n\t\t\tvar that = this,\n\t\t\t\tcss = {};\n\n\t\t\t// Return if the position hasn't changed\n\t\t\tif ( position === this.thumbnailsPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.thumbnailsPosition = position;\n\n\t\t\t// Use CSS transitions if they are supported. If not, use JavaScript animation\n\t\t\tif ( this.supportedAnimation === 'css-3d' || this.supportedAnimation === 'css-2d' ) {\n\t\t\t\tvar transition,\n\t\t\t\t\tleft = this.thumbnailsOrientation === 'horizontal' ? position : 0,\n\t\t\t\t\ttop = this.thumbnailsOrientation === 'horizontal' ? 0 : position;\n\n\t\t\t\tif ( this.supportedAnimation === 'css-3d' ) {\n\t\t\t\t\tcss[ this.vendorPrefix + 'transform' ] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n\t\t\t\t} else {\n\t\t\t\t\tcss[ this.vendorPrefix + 'transform' ] = 'translate(' + left + 'px, ' + top + 'px)';\n\t\t\t\t}\n\n\t\t\t\tif ( typeof instant !== 'undefined' && instant === true ) {\n\t\t\t\t\ttransition = '';\n\t\t\t\t} else {\n\t\t\t\t\tthis.$thumbnails.addClass( 'sp-animated' );\n\t\t\t\t\ttransition = this.vendorPrefix + 'transform ' + 700 / 1000 + 's';\n\n\t\t\t\t\tthis.$thumbnails.on( this.transitionEvent, function( event ) {\n\t\t\t\t\t\tif ( event.target !== event.currentTarget ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthat.$thumbnails.off( that.transitionEvent );\n\t\t\t\t\t\tthat.$thumbnails.removeClass( 'sp-animated' );\n\n\t\t\t\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Fire the 'thumbnailsMoveComplete' event\n\t\t\t\t\t\tthat.trigger({ type: 'thumbnailsMoveComplete' });\n\t\t\t\t\t\tif ( $.isFunction( that.settings.thumbnailsMoveComplete ) ) {\n\t\t\t\t\t\t\tthat.settings.thumbnailsMoveComplete.call( that, { type: 'thumbnailsMoveComplete' });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tcss[ this.vendorPrefix + 'transition' ] = transition;\n\n\t\t\t\tthis.$thumbnails.css( css );\n\t\t\t} else {\n\t\t\t\tcss[ 'margin-' + this.thumbnailsPositionProperty ] = position;\n\n\t\t\t\tif ( typeof instant !== 'undefined' && instant === true ) {\n\t\t\t\t\tthis.$thumbnails.css( css );\n\t\t\t\t} else {\n\t\t\t\t\tthis.$thumbnails\n\t\t\t\t\t\t.addClass( 'sp-animated' )\n\t\t\t\t\t\t.animate( css, 700, function() {\n\t\t\t\t\t\t\tthat.$thumbnails.removeClass( 'sp-animated' );\n\n\t\t\t\t\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Fire the 'thumbnailsMoveComplete' event\n\t\t\t\t\t\t\tthat.trigger({ type: 'thumbnailsMoveComplete' });\n\t\t\t\t\t\t\tif ( $.isFunction( that.settings.thumbnailsMoveComplete ) ) {\n\t\t\t\t\t\t\t\tthat.settings.thumbnailsMoveComplete.call( that, { type: 'thumbnailsMoveComplete' });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Stop the movement of the thumbnail scroller\n\t\t_stopThumbnailsMovement: function() {\n\t\t\tvar css = {};\n\n\t\t\tif ( this.supportedAnimation === 'css-3d' || this.supportedAnimation === 'css-2d' ) {\n\t\t\t\tvar\tmatrixString = this.$thumbnails.css( this.vendorPrefix + 'transform' ),\n\t\t\t\t\tmatrixType = matrixString.indexOf( 'matrix3d' ) !== -1 ? 'matrix3d' : 'matrix',\n\t\t\t\t\tmatrixArray = matrixString.replace( matrixType, '' ).match( /-?[0-9\\.]+/g ),\n\t\t\t\t\tleft = matrixType === 'matrix3d' ? parseInt( matrixArray[ 12 ], 10 ) : parseInt( matrixArray[ 4 ], 10 ),\n\t\t\t\t\ttop = matrixType === 'matrix3d' ? parseInt( matrixArray[ 13 ], 10 ) : parseInt( matrixArray[ 5 ], 10 );\n\n\t\t\t\tif ( this.supportedAnimation === 'css-3d' ) {\n\t\t\t\t\tcss[ this.vendorPrefix + 'transform' ] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n\t\t\t\t} else {\n\t\t\t\t\tcss[ this.vendorPrefix + 'transform' ] = 'translate(' + left + 'px, ' + top + 'px)';\n\t\t\t\t}\n\n\t\t\t\tcss[ this.vendorPrefix + 'transition' ] = '';\n\n\t\t\t\tthis.$thumbnails.css( css );\n\t\t\t\tthis.$thumbnails.off( this.transitionEvent );\n\t\t\t\tthis.thumbnailsPosition = this.thumbnailsOrientation === 'horizontal' ? parseInt( matrixArray[ 4 ] , 10 ) : parseInt( matrixArray[ 5 ] , 10 );\n\t\t\t} else {\n\t\t\t\tthis.$thumbnails.stop();\n\t\t\t\tthis.thumbnailsPosition = parseInt( this.$thumbnails.css( 'margin-' + this.thumbnailsPositionProperty ), 10 );\n\t\t\t}\n\n\t\t\tthis.$thumbnails.removeClass( 'sp-animated' );\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyThumbnails: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Remove event listeners\n\t\t\tthis.off( 'update.' + NS );\n\n\t\t\tif ( this.isThumbnailScroller === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tthis.off( 'sliderResize.' + NS );\n\t\t\tthis.off( 'gotoSlide.' + NS );\n\t\t\t$( window ).off( 'resize.' + this.uniqueId + '.' + NS );\n\n\t\t\t// Destroy the individual thumbnails\n\t\t\tthis.$thumbnails.find( '.sp-thumbnail' ).each( function() {\n\t\t\t\tvar $thumbnail = $( this ),\n\t\t\t\t\tindex = parseInt( $thumbnail.attr( 'data-index' ), 10 ),\n\t\t\t\t\tthumbnail = that.thumbnails[ index ];\n\n\t\t\t\tthumbnail.off( 'thumbnailClick.' + NS );\n\t\t\t\tthumbnail.destroy();\n\t\t\t});\n\n\t\t\tthis.thumbnails.length = 0;\n\n\t\t\t// Add the thumbnail scroller directly in the slider and\n\t\t\t// remove the thumbnail scroller container\n\t\t\tthis.$thumbnails.appendTo( this.$slider );\n\t\t\tthis.$thumbnailsContainer.remove();\n\t\t\t\n\t\t\t// Remove any created padding\n\t\t\tthis.$slider.css({ 'paddingTop': '', 'paddingLeft': '', 'paddingRight': '' });\n\t\t},\n\n\t\tthumbnailsDefaults: {\n\n\t\t\t// Sets the width of the thumbnail\n\t\t\tthumbnailWidth: 100,\n\n\t\t\t// Sets the height of the thumbnail\n\t\t\tthumbnailHeight: 80,\n\n\t\t\t// Sets the position of the thumbnail scroller (top, bottom, right, left)\n\t\t\tthumbnailsPosition: 'bottom',\n\n\t\t\t// Indicates if a pointer will be displayed for the selected thumbnail\n\t\t\tthumbnailPointer: false,\n\n\t\t\t// Called when the thumbnails are updated\n\t\t\tthumbnailsUpdate: function() {},\n\n\t\t\t// Called when a new thumbnail is selected\n\t\t\tgotoThumbnail: function() {},\n\n\t\t\t// Called when the thumbnail scroller has moved\n\t\t\tthumbnailsMoveComplete: function() {}\n\t\t}\n\t};\n\n\tvar Thumbnail = function( thumbnail, thumbnails, index ) {\n\n\t\t// Reference to the thumbnail jQuery element\n\t\tthis.$thumbnail = thumbnail;\n\n\t\t// Reference to the thumbnail scroller\n\t\tthis.$thumbnails = thumbnails;\n\n\t\t// Reference to the thumbnail's container, which will be \n\t\t// created dynamically.\n\t\tthis.$thumbnailContainer = null;\n\n\t\t// The width and height of the thumbnail\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\n\t\t// Indicates whether the thumbnail's image is loaded\n\t\tthis.isImageLoaded = false;\n\n\t\t// Set the index of the slide\n\t\tthis.setIndex( index );\n\n\t\t// Initialize the thumbnail\n\t\tthis._init();\n\t};\n\n\tThumbnail.prototype = {\n\n\t\t_init: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Mark the thumbnail as initialized\n\t\t\tthis.$thumbnail.attr( 'data-init', true );\n\n\t\t\t// Create a container for the thumbnail and add the original thumbnail to this container.\n\t\t\t// Having a container will help crop the thumbnail image if it's too large.\n\t\t\tthis.$thumbnailContainer = $( '<div class=\"sp-thumbnail-container\"></div>' ).appendTo( this.$thumbnails );\n\n\t\t\tif ( this.$thumbnail.parent( 'a' ).length !== 0 ) {\n\t\t\t\tthis.$thumbnail.parent( 'a' ).appendTo( this.$thumbnailContainer );\n\t\t\t} else {\n\t\t\t\tthis.$thumbnail.appendTo( this.$thumbnailContainer );\n\t\t\t}\n\n\t\t\t// When the thumbnail container is clicked, fire an event\n\t\t\tthis.$thumbnailContainer.on( 'click.' + NS, function() {\n\t\t\t\tthat.trigger({ type: 'thumbnailClick.' + NS, index: that.index });\n\t\t\t});\n\t\t},\n\n\t\t// Set the width and height of the thumbnail\n\t\tsetSize: function( width, height ) {\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\t// Apply the width and height to the thumbnail's container\n\t\t\tthis.$thumbnailContainer.css({ 'width': this.width, 'height': this.height });\n\n\t\t\t// If there is an image, resize it to fit the thumbnail container\n\t\t\tif ( this.$thumbnail.is( 'img' ) && typeof this.$thumbnail.attr( 'data-src' ) === 'undefined' ) {\n\t\t\t\tthis.resizeImage();\n\t\t\t}\n\t\t},\n\n\t\t// Return the width and height of the thumbnail\n\t\tgetSize: function() {\n\t\t\treturn {\n\t\t\t\twidth: this.$thumbnailContainer.outerWidth( true ),\n\t\t\t\theight: this.$thumbnailContainer.outerHeight( true )\n\t\t\t};\n\t\t},\n\n\t\t// Return the top, bottom, left and right position of the thumbnail\n\t\tgetPosition: function() {\n\t\t\treturn {\n\t\t\t\tleft: this.$thumbnailContainer.position().left + parseInt( this.$thumbnailContainer.css( 'marginLeft' ) , 10 ),\n\t\t\t\tright: this.$thumbnailContainer.position().left + parseInt( this.$thumbnailContainer.css( 'marginLeft' ) , 10 ) + this.$thumbnailContainer.outerWidth(),\n\t\t\t\ttop: this.$thumbnailContainer.position().top + parseInt( this.$thumbnailContainer.css( 'marginTop' ) , 10 ),\n\t\t\t\tbottom: this.$thumbnailContainer.position().top + parseInt( this.$thumbnailContainer.css( 'marginTop' ) , 10 ) + this.$thumbnailContainer.outerHeight()\n\t\t\t};\n\t\t},\n\n\t\t// Set the index of the thumbnail\n\t\tsetIndex: function( index ) {\n\t\t\tthis.index = index;\n\t\t\tthis.$thumbnail.attr( 'data-index', this.index );\n\t\t},\n\n\t\t// Resize the thumbnail's image\n\t\tresizeImage: function() {\n\t\t\tvar that = this;\n\n\t\t\t// If the image is not loaded yet, load it\n\t\t\tif ( this.isImageLoaded === false ) {\n\t\t\t\tSliderProUtils.checkImagesComplete( this.$thumbnailContainer , function() {\n\t\t\t\t\tthat.isImageLoaded = true;\n\t\t\t\t\tthat.resizeImage();\n\t\t\t\t});\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the reference to the thumbnail image again because it was replaced by\n\t\t\t// another img element during the loading process\n\t\t\tthis.$thumbnail = this.$thumbnailContainer.find( '.sp-thumbnail' );\n\n\t\t\t// Calculate whether the image should stretch horizontally or vertically\n\t\t\tvar imageWidth = this.$thumbnail.width(),\n\t\t\t\timageHeight = this.$thumbnail.height();\n\n\t\t\tif ( imageWidth / imageHeight <= this.width / this.height ) {\n\t\t\t\tthis.$thumbnail.css({ width: '100%', height: 'auto' });\n\t\t\t} else {\n\t\t\t\tthis.$thumbnail.css({ width: 'auto', height: '100%' });\n\t\t\t}\n\n\t\t\tthis.$thumbnail.css({ 'marginLeft': ( this.$thumbnailContainer.width() - this.$thumbnail.width() ) * 0.5, 'marginTop': ( this.$thumbnailContainer.height() - this.$thumbnail.height() ) * 0.5 });\n\t\t},\n\n\t\t// Destroy the thumbnail\n\t\tdestroy: function() {\n\t\t\tthis.$thumbnailContainer.off( 'click.' + NS );\n\n\t\t\t// Remove added attributes\n\t\t\tthis.$thumbnail.removeAttr( 'data-init' );\n\t\t\tthis.$thumbnail.removeAttr( 'data-index' );\n\n\t\t\t// Remove the thumbnail's container and add the thumbnail\n\t\t\t// back to the thumbnail scroller container\n\t\t\tif ( this.$thumbnail.parent( 'a' ).length !== 0 ) {\n\t\t\t\tthis.$thumbnail.parent( 'a' ).insertBefore( this.$thumbnailContainer );\n\t\t\t} else {\n\t\t\t\tthis.$thumbnail.insertBefore( this.$thumbnailContainer );\n\t\t\t}\n\t\t\t\n\t\t\tthis.$thumbnailContainer.remove();\n\t\t},\n\n\t\t// Attach an event handler to the slide\n\t\ton: function( type, callback ) {\n\t\t\treturn this.$thumbnailContainer.on( type, callback );\n\t\t},\n\n\t\t// Detach an event handler to the slide\n\t\toff: function( type ) {\n\t\t\treturn this.$thumbnailContainer.off( type );\n\t\t},\n\n\t\t// Trigger an event on the slide\n\t\ttrigger: function( data ) {\n\t\t\treturn this.$thumbnailContainer.triggerHandler( data );\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Thumbnails', Thumbnails );\n\n})( window, jQuery );\n\n// ConditionalImages module for Slider Pro.\n// \n// Adds the possibility to specify multiple sources for each image and\n// load the image that's the most appropriate for the size of the slider.\n// For example, instead of loading a large image even if the slider will be small\n// you can specify a smaller image that will be loaded instead.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\tvar NS = 'ConditionalImages.' + $.SliderPro.namespace;\n\n\tvar ConditionalImages = {\n\n\t\t// Reference to the previous size\n\t\tpreviousImageSize: null,\n\n\t\t// Reference to the current size\n\t\tcurrentImageSize: null,\n\n\t\t// Indicates if the current display supports high PPI\n\t\tisRetinaScreen: false,\n\n\t\tinitConditionalImages: function() {\n\t\t\tthis.currentImageSize = this.previousImageSize = 'default';\n\t\t\tthis.isRetinaScreen = ( typeof this._isRetina !== 'undefined' ) && ( this._isRetina() === true );\n\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._conditionalImagesOnUpdate, this ) );\n\t\t\tthis.on( 'sliderResize.' + NS, $.proxy( this._conditionalImagesOnResize, this ) );\n\t\t},\n\n\t\t// Loop through all the existing images and specify the original path of the image\n\t\t// inside the 'data-default' attribute.\n\t\t_conditionalImagesOnUpdate: function() {\n\t\t\t$.each( this.slides, function( index, element ) {\n\t\t\t\tvar $slide = element.$slide;\n\n\t\t\t\t$slide.find( 'img:not([ data-default ])' ).each(function() {\n\t\t\t\t\tvar $image = $( this );\n\n\t\t\t\t\tif ( typeof $image.attr( 'data-src' ) !== 'undefined' ) {\n\t\t\t\t\t\t$image.attr( 'data-default', $image.attr( 'data-src' ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$image.attr( 'data-default', $image.attr( 'src' ) );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t// When the window resizes, identify the applyable image size based on the current size of the slider\n\t\t// and apply it to all images that have a version of the image specified for this size.\n\t\t_conditionalImagesOnResize: function() {\n\t\t\tif ( this.slideWidth <= this.settings.smallSize ) {\n\t\t\t\tthis.currentImageSize = 'small';\n\t\t\t} else if ( this.slideWidth <= this.settings.mediumSize ) {\n\t\t\t\tthis.currentImageSize = 'medium';\n\t\t\t} else if ( this.slideWidth <= this.settings.largeSize ) {\n\t\t\t\tthis.currentImageSize = 'large';\n\t\t\t} else {\n\t\t\t\tthis.currentImageSize = 'default';\n\t\t\t}\n\n\t\t\tif ( this.previousImageSize !== this.currentImageSize ) {\n\t\t\t\tvar that = this;\n\n\t\t\t\t$.each( this.slides, function( index, element ) {\n\t\t\t\t\tvar $slide = element.$slide;\n\n\t\t\t\t\t$slide.find( 'img' ).each(function() {\n\t\t\t\t\t\tvar $image = $( this ),\n\t\t\t\t\t\t\timageSource = '';\n\n\t\t\t\t\t\t// Check if the current display supports high PPI and if a retina version of the current size was specified\n\t\t\t\t\t\tif ( that.isRetinaScreen === true && typeof $image.attr( 'data-retina' + that.currentImageSize ) !== 'undefined' ) {\n\t\t\t\t\t\t\timageSource = $image.attr( 'data-retina' + that.currentImageSize );\n\n\t\t\t\t\t\t\t// If the retina image was not loaded yet, replace the default image source with the one\n\t\t\t\t\t\t\t// that corresponds to the current slider size\n\t\t\t\t\t\t\tif ( typeof $image.attr( 'data-retina' ) !== 'undefined' && $image.attr( 'data-retina' ) !== imageSource ) {\n\t\t\t\t\t\t\t\t$image.attr( 'data-retina', imageSource );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if ( ( that.isRetinaScreen === false || that.isRetinaScreen === true && typeof $image.attr( 'data-retina' ) === 'undefined' ) && typeof $image.attr( 'data-' + that.currentImageSize ) !== 'undefined' ) {\n\t\t\t\t\t\t\timageSource = $image.attr( 'data-' + that.currentImageSize );\n\n\t\t\t\t\t\t\t// If the image is set to lazy load, replace the image source with the one\n\t\t\t\t\t\t\t// that corresponds to the current slider size\n\t\t\t\t\t\t\tif ( typeof $image.attr( 'data-src' ) !== 'undefined' && $image.attr( 'data-src' ) !== imageSource ) {\n\t\t\t\t\t\t\t\t$image.attr( 'data-src', imageSource );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If a new image was found\n\t\t\t\t\t\tif ( imageSource !== '' ) {\n\n\t\t\t\t\t\t\t// The existence of the 'data-src' attribute indicates that the image\n\t\t\t\t\t\t\t// will be lazy loaded, so don't load the new image yet\n\t\t\t\t\t\t\tif ( typeof $image.attr( 'data-src' ) === 'undefined' && $image.attr( 'src' ) !== imageSource  ) {\n\t\t\t\t\t\t\t\tthat._loadConditionalImage( $image, imageSource, function( newImage ) {\n\t\t\t\t\t\t\t\t\tif ( newImage.hasClass( 'sp-image' ) ) {\n\t\t\t\t\t\t\t\t\t\telement.$mainImage = newImage;\n\t\t\t\t\t\t\t\t\t\telement.resizeMainImage( true );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tthis.previousImageSize = this.currentImageSize;\n\t\t\t}\n\t\t},\n\n\t\t// Replace the target image with a new image\n\t\t_loadConditionalImage: function( image, source, callback ) {\n\n\t\t\t// Create a new image element\n\t\t\tvar newImage = $( new Image() );\n\n\t\t\t// Copy the class(es) and inline style\n\t\t\tnewImage.attr( 'class', image.attr( 'class' ) );\n\t\t\tnewImage.attr( 'style', image.attr( 'style' ) );\n\n\t\t\t// Copy the data attributes\n\t\t\t$.each( image.data(), function( name, value ) {\n\t\t\t\tnewImage.attr( 'data-' + name, value );\n\t\t\t});\n\n\t\t\t// Copy the width and height attributes if they exist\n\t\t\tif ( typeof image.attr( 'width' ) !== 'undefined') {\n\t\t\t\tnewImage.attr( 'width', image.attr( 'width' ) );\n\t\t\t}\n\n\t\t\tif ( typeof image.attr( 'height' ) !== 'undefined') {\n\t\t\t\tnewImage.attr( 'height', image.attr( 'height' ) );\n\t\t\t}\n\n\t\t\tif ( typeof image.attr( 'alt' ) !== 'undefined' ) {\n\t\t\t\tnewImage.attr( 'alt', image.attr( 'alt' ) );\n\t\t\t}\n\n\t\t\tif ( typeof image.attr( 'title' ) !== 'undefined' ) {\n\t\t\t\tnewImage.attr( 'title', image.attr( 'title' ) );\n\t\t\t}\n\n\t\t\tnewImage.attr( 'src', source );\n\n\t\t\t// Add the new image in the same container and remove the older image\n\t\t\tnewImage.insertAfter( image );\n\t\t\timage.remove();\n\t\t\timage = null;\n\t\t\t\t\n\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\tcallback( newImage );\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyConditionalImages: function() {\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis.off( 'sliderResize.' + NS );\n\t\t},\n\n\t\tconditionalImagesDefaults: {\n\n\t\t\t// If the slider size is below this size, the small version of the images will be used\n\t\t\tsmallSize: 480,\n\n\t\t\t// If the slider size is below this size, the small version of the images will be used\n\t\t\tmediumSize: 768,\n\n\t\t\t// If the slider size is below this size, the small version of the images will be used\n\t\t\tlargeSize: 1024\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'ConditionalImages', ConditionalImages );\n\n})( window, jQuery );\n\n// Retina module for Slider Pro.\n// \n// Adds the possibility to load a different image when the slider is\n// viewed on a retina screen.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\t\n\tvar NS = 'Retina.' + $.SliderPro.namespace;\n\n\tvar Retina = {\n\n\t\tinitRetina: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Return if it's not a retina screen\n\t\t\tif ( this._isRetina() === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tthis.on( 'sliderResize.' + NS, $.proxy( this._checkRetinaImages, this ) );\n\n\t\t\tif ( this.$slider.find( '.sp-thumbnail' ).length !== 0 ) {\n\t\t\t\tthis.on( 'update.Thumbnails.' + NS, $.proxy( this._checkRetinaThumbnailImages, this ) );\n\t\t\t}\n\t\t},\n\n\t\t// Checks if the current display supports high PPI\n\t\t_isRetina: function() {\n\t\t\tif ( window.devicePixelRatio >= 2 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( window.matchMedia && ( window.matchMedia( \"(-webkit-min-device-pixel-ratio: 2),(min-resolution: 2dppx)\" ).matches ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t// Loop through the slides and replace the images with their retina version\n\t\t_checkRetinaImages: function() {\n\t\t\tvar that = this;\n\n\t\t\t$.each( this.slides, function( index, element ) {\n\t\t\t\tvar $slide = element.$slide;\n\n\t\t\t\tif ( typeof $slide.attr( 'data-retina-loaded' ) === 'undefined' ) {\n\t\t\t\t\t$slide.attr( 'data-retina-loaded', true );\n\n\t\t\t\t\t$slide.find( 'img[data-retina]' ).each(function() {\n\t\t\t\t\t\tvar $image = $( this );\n\n\t\t\t\t\t\tif ( typeof $image.attr( 'data-src' ) !== 'undefined' ) {\n\t\t\t\t\t\t\t$image.attr( 'data-src', $image.attr( 'data-retina' ) );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat._loadRetinaImage( $image, function( newImage ) {\n\t\t\t\t\t\t\t\tif ( newImage.hasClass( 'sp-image' ) ) {\n\t\t\t\t\t\t\t\t\telement.$mainImage = newImage;\n\t\t\t\t\t\t\t\t\telement.resizeMainImage( true );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Loop through the thumbnails and replace the images with their retina version\n\t\t_checkRetinaThumbnailImages: function() {\n\t\t\tvar that = this;\n\n\t\t\t$.each( this.thumbnails, function( index, element ) {\n\t\t\t\tvar $thumbnail = element.$thumbnailContainer;\n\n\t\t\t\tif ( typeof $thumbnail.attr( 'data-retina-loaded' ) === 'undefined' ) {\n\t\t\t\t\t$thumbnail.attr( 'data-retina-loaded', true );\n\n\t\t\t\t\t$thumbnail.find( 'img[data-retina]' ).each(function() {\n\t\t\t\t\t\tvar $image = $( this );\n\n\t\t\t\t\t\tif ( typeof $image.attr( 'data-src' ) !== 'undefined' ) {\n\t\t\t\t\t\t\t$image.attr( 'data-src', $image.attr( 'data-retina' ) );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat._loadRetinaImage( $image, function( newImage ) {\n\t\t\t\t\t\t\t\tif ( newImage.hasClass( 'sp-thumbnail' ) ) {\n\t\t\t\t\t\t\t\t\telement.resizeImage();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Load the retina image\n\t\t_loadRetinaImage: function( image, callback ) {\n\t\t\tvar retinaFound = false,\n\t\t\t\tnewImagePath = '';\n\n\t\t\t// Check if there is a retina image specified\n\t\t\tif ( typeof image.attr( 'data-retina' ) !== 'undefined' ) {\n\t\t\t\tretinaFound = true;\n\n\t\t\t\tnewImagePath = image.attr( 'data-retina' );\n\t\t\t}\n\n\t\t\t// Check if there is a lazy loaded, non-retina, image specified\n\t\t\tif ( typeof image.attr( 'data-src' ) !== 'undefined' ) {\n\t\t\t\tif ( retinaFound === false ) {\n\t\t\t\t\tnewImagePath = image.attr( 'data-src') ;\n\t\t\t\t}\n\n\t\t\t\timage.removeAttr('data-src');\n\t\t\t}\n\n\t\t\t// Return if there isn't a retina or lazy loaded image\n\t\t\tif ( newImagePath === '' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Create a new image element\n\t\t\tvar newImage = $( new Image() );\n\n\t\t\t// Copy the class(es) and inline style\n\t\t\tnewImage.attr( 'class', image.attr('class') );\n\t\t\tnewImage.attr( 'style', image.attr('style') );\n\n\t\t\t// Copy the data attributes\n\t\t\t$.each( image.data(), function( name, value ) {\n\t\t\t\tnewImage.attr( 'data-' + name, value );\n\t\t\t});\n\n\t\t\t// Copy the width and height attributes if they exist\n\t\t\tif ( typeof image.attr( 'width' ) !== 'undefined' ) {\n\t\t\t\tnewImage.attr( 'width', image.attr( 'width' ) );\n\t\t\t}\n\n\t\t\tif ( typeof image.attr( 'height' ) !== 'undefined' ) {\n\t\t\t\tnewImage.attr( 'height', image.attr( 'height' ) );\n\t\t\t}\n\n\t\t\tif ( typeof image.attr( 'alt' ) !== 'undefined' ) {\n\t\t\t\tnewImage.attr( 'alt', image.attr( 'alt' ) );\n\t\t\t}\n\n\t\t\tif ( typeof image.attr( 'title' ) !== 'undefined' ) {\n\t\t\t\tnewImage.attr( 'title', image.attr( 'title' ) );\n\t\t\t}\n\n\t\t\t// Add the new image in the same container and remove the older image\n\t\t\tnewImage.insertAfter( image );\n\t\t\timage.remove();\n\t\t\timage = null;\n\n\t\t\t// Assign the source of the image\n\t\t\tnewImage.attr( 'src', newImagePath );\n\n\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\tcallback( newImage );\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyRetina: function() {\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis.off( 'update.Thumbnails.' + NS );\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Retina', Retina );\n\t\n})( window, jQuery );\n\n// Lazy Loading module for Slider Pro.\n// \n// Adds the possibility to delay the loading of the images until the slides/thumbnails\n// that contain them become visible. This technique improves the initial loading\n// performance.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\tvar NS = 'LazyLoading.' + $.SliderPro.namespace;\n\n\tvar LazyLoading = {\n\n\t\tallowLazyLoadingCheck: true,\n\n\t\tinitLazyLoading: function() {\n\t\t\tvar that = this;\n\n\t\t\t// The 'resize' event is fired after every update, so it's possible to use it for checking\n\t\t\t// if the update made new slides become visible\n\t\t\t// \n\t\t\t// Also, resizing the slider might make new slides or thumbnails visible\n\t\t\tthis.on( 'sliderResize.' + NS, $.proxy( this._lazyLoadingOnResize, this ) );\n\n\t\t\t// Check visible images when a new slide is selected\n\t\t\tthis.on( 'gotoSlide.' + NS, $.proxy( this._checkAndLoadVisibleImages, this ) );\n\n\t\t\t// Check visible thumbnail images when the thumbnails are updated because new thumbnail\n\t\t\t// might have been added or the settings might have been changed so that more thumbnail\n\t\t\t// images become visible\n\t\t\t// \n\t\t\t// Also, check visible thumbnail images after the thumbnails have moved because new thumbnails might\n\t\t\t// have become visible\n\t\t\tthis.on( 'thumbnailsUpdate.' + NS + ' ' + 'thumbnailsMoveComplete.' + NS, $.proxy( this._checkAndLoadVisibleThumbnailImages, this ) );\n\t\t},\n\n\t\t_lazyLoadingOnResize: function() {\n\t\t\tvar that = this;\n\n\t\t\tif ( this.allowLazyLoadingCheck === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.allowLazyLoadingCheck = false;\n\t\t\t\n\t\t\tthis._checkAndLoadVisibleImages();\n\n\t\t\tif ( this.$slider.find( '.sp-thumbnail' ).length !== 0 ) {\n\t\t\t\tthis._checkAndLoadVisibleThumbnailImages();\n\t\t\t}\n\n\t\t\t// Use a timer to deffer the loading of images in order to prevent too many\n\t\t\t// checking attempts\n\t\t\tsetTimeout(function() {\n\t\t\t\tthat.allowLazyLoadingCheck = true;\n\t\t\t}, 500 );\n\t\t},\n\n\t\t// Check visible slides and load their images\n\t\t_checkAndLoadVisibleImages: function() {\n\t\t\tif ( this.$slider.find( '.sp-slide:not([ data-loaded ])' ).length === 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar that = this,\n\n\t\t\t\t// Use either the middle position or the index of the selected slide as a reference, depending on\n\t\t\t\t// whether the slider is loopable\n\t\t\t\treferencePosition = this.settings.loop === true ? this.middleSlidePosition : this.selectedSlideIndex,\n\n\t\t\t\t// Calculate how many slides are visible at the sides of the selected slide\n\t\t\t\tvisibleOnSides = Math.ceil( ( parseInt( this.$slidesMask.css( this.sizeProperty ), 10) - this.averageSlideSize ) / 2 / this.averageSlideSize ),\n\n\t\t\t\t// Calculate the indexes of the first and last slide that will be checked\n\t\t\t\tfrom = this.settings.centerSelectedSlide === true ? Math.max( referencePosition - visibleOnSides - 1, 0 ) : Math.max( referencePosition - 1, 0 ),\n\t\t\t\tto = this.settings.centerSelectedSlide === true ? Math.min( referencePosition + visibleOnSides + 1, this.getTotalSlides() - 1 ) : Math.min( referencePosition + visibleOnSides * 2 + 1, this.getTotalSlides() - 1  ),\n\t\t\t\t\n\t\t\t\t// Get all the slides that need to be checked\n\t\t\t\tslidesToCheck = this.slidesOrder.slice( from, to + 1 );\n\n\t\t\t// Loop through the selected slides and if the slide is not marked as having\n\t\t\t// been loaded yet, loop through its images and load them.\n\t\t\t$.each( slidesToCheck, function( index, element ) {\n\t\t\t\tvar slide = that.slides[ element ],\n\t\t\t\t\t$slide = slide.$slide;\n\n\t\t\t\tif ( typeof $slide.attr( 'data-loaded' ) === 'undefined' ) {\n\t\t\t\t\t$slide.attr( 'data-loaded', true );\n\n\t\t\t\t\t$slide.find( 'img[ data-src ]' ).each(function() {\n\t\t\t\t\t\tvar image = $( this );\n\t\t\t\t\t\tthat._loadImage( image, function( newImage ) {\n\t\t\t\t\t\t\tif ( newImage.hasClass( 'sp-image' ) ) {\n\t\t\t\t\t\t\t\tslide.$mainImage = newImage;\n\t\t\t\t\t\t\t\tslide.resizeMainImage( true );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Check visible thumbnails and load their images\n\t\t_checkAndLoadVisibleThumbnailImages: function() {\n\t\t\tif ( this.$slider.find( '.sp-thumbnail-container:not([ data-loaded ])' ).length === 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar that = this,\n\t\t\t\tthumbnailSize = this.thumbnailsSize / this.thumbnails.length,\n\n\t\t\t\t// Calculate the indexes of the first and last thumbnail that will be checked\n\t\t\t\tfrom = Math.floor( Math.abs( this.thumbnailsPosition / thumbnailSize ) ),\n\t\t\t\tto = Math.floor( ( - this.thumbnailsPosition + this.thumbnailsContainerSize ) / thumbnailSize ),\n\n\t\t\t\t// Get all the thumbnails that need to be checked\n\t\t\t\tthumbnailsToCheck = this.thumbnails.slice( from, to + 1 );\n\n\t\t\t// Loop through the selected thumbnails and if the thumbnail is not marked as having\n\t\t\t// been loaded yet, load its image.\n\t\t\t$.each( thumbnailsToCheck, function( index, element ) {\n\t\t\t\tvar $thumbnailContainer = element.$thumbnailContainer;\n\n\t\t\t\tif ( typeof $thumbnailContainer.attr( 'data-loaded' ) === 'undefined' ) {\n\t\t\t\t\t$thumbnailContainer.attr( 'data-loaded', true );\n\n\t\t\t\t\t$thumbnailContainer.find( 'img[ data-src ]' ).each(function() {\n\t\t\t\t\t\tvar image = $( this );\n\n\t\t\t\t\t\tthat._loadImage( image, function() {\n\t\t\t\t\t\t\telement.resizeImage();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Load an image\n\t\t_loadImage: function( image, callback ) {\n\t\t\t// Create a new image element\n\t\t\tvar newImage = $( new Image() );\n\n\t\t\t// Copy the class(es) and inline style\n\t\t\tnewImage.attr( 'class', image.attr( 'class' ) );\n\t\t\tnewImage.attr( 'style', image.attr( 'style' ) );\n\n\t\t\t// Copy the data attributes\n\t\t\t$.each( image.data(), function( name, value ) {\n\t\t\t\tnewImage.attr( 'data-' + name, value );\n\t\t\t});\n\n\t\t\t// Copy the width and height attributes if they exist\n\t\t\tif ( typeof image.attr( 'width' ) !== 'undefined') {\n\t\t\t\tnewImage.attr( 'width', image.attr( 'width' ) );\n\t\t\t}\n\n\t\t\tif ( typeof image.attr( 'height' ) !== 'undefined') {\n\t\t\t\tnewImage.attr( 'height', image.attr( 'height' ) );\n\t\t\t}\n\n\t\t\tif ( typeof image.attr( 'alt' ) !== 'undefined' ) {\n\t\t\t\tnewImage.attr( 'alt', image.attr( 'alt' ) );\n\t\t\t}\n\n\t\t\tif ( typeof image.attr( 'title' ) !== 'undefined' ) {\n\t\t\t\tnewImage.attr( 'title', image.attr( 'title' ) );\n\t\t\t}\n\n\t\t\t// Assign the source of the image\n\t\t\tnewImage.attr( 'src', image.attr( 'data-src' ) );\n\t\t\tnewImage.removeAttr( 'data-src' );\n\n\t\t\t// Add the new image in the same container and remove the older image\n\t\t\tnewImage.insertAfter( image );\n\t\t\timage.remove();\n\t\t\timage = null;\n\t\t\t\n\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\tcallback( newImage );\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyLazyLoading: function() {\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis.off( 'gotoSlide.' + NS );\n\t\t\tthis.off( 'sliderResize.' + NS );\n\t\t\tthis.off( 'thumbnailsUpdate.' + NS );\n\t\t\tthis.off( 'thumbnailsMoveComplete.' + NS );\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'LazyLoading', LazyLoading );\n\n})( window, jQuery );\n\n// Layers module for Slider Pro.\n// \n// Adds support for animated and static layers. The layers can contain any content,\n// from simple text for video elements.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\tvar NS = 'Layers.' +  $.SliderPro.namespace;\n\n\tvar Layers = {\n\n\t\t// Reference to the original 'gotoSlide' method\n\t\tlayersGotoSlideReference: null,\n\n\t\t// Reference to the timer that will delay the overriding\n\t\t// of the 'gotoSlide' method\n\t\twaitForLayersTimer: null,\n\n\t\tinitLayers: function() {\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._layersOnUpdate, this ) );\n\t\t\tthis.on( 'sliderResize.' + NS, $.proxy( this._layersOnResize, this ) );\n\t\t\tthis.on( 'gotoSlide.' + NS, $.proxy( this._layersOnGotoSlide, this ) );\n\t\t},\n\n\t\t// Loop through the slides and initialize all layers\n\t\t_layersOnUpdate: function( event ) {\n\t\t\tvar that = this;\n\n\t\t\t$.each( this.slides, function( index, element ) {\n\t\t\t\tvar $slide = element.$slide;\n\n\t\t\t\t// Initialize the layers\n\t\t\t\tthis.$slide.find( '.sp-layer:not([ data-layer-init ])').each(function() {\n\t\t\t\t\tvar layer = new Layer( $( this ) );\n\n\t\t\t\t\t// Add the 'layers' array to the slide objects (instance of SliderProSlide)\n\t\t\t\t\tif ( typeof element.layers === 'undefined' ) {\n\t\t\t\t\t\telement.layers = [];\n\t\t\t\t\t}\n\n\t\t\t\t\telement.layers.push( layer );\n\n\t\t\t\t\tif ( $( this ).hasClass( 'sp-static' ) === false ) {\n\n\t\t\t\t\t\t// Add the 'animatedLayers' array to the slide objects (instance of SliderProSlide)\n\t\t\t\t\t\tif ( typeof element.animatedLayers === 'undefined' ) {\n\t\t\t\t\t\t\telement.animatedLayers = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telement.animatedLayers.push( layer );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// If the 'waitForLayers' option is enabled, the slider will not move to another slide\n\t\t\t// until all the layers from the previous slide will be hidden. To achieve this,\n\t\t\t// replace the current 'gotoSlide' function with another function that will include the \n\t\t\t// required functionality.\n\t\t\t// \n\t\t\t// Since the 'gotoSlide' method might be overridden by other modules as well, delay this\n\t\t\t// override to make sure it's the last override.\n\t\t\tif ( this.settings.waitForLayers === true ) {\n\t\t\t\tclearTimeout( this.waitForLayersTimer );\n\n\t\t\t\tthis.waitForLayersTimer = setTimeout(function() {\n\t\t\t\t\tthat.layersGotoSlideReference = that.gotoSlide;\n\t\t\t\t\tthat.gotoSlide = that._layersGotoSlide;\n\t\t\t\t}, 1 );\n\t\t\t}\n\n\t\t\t// Show the layers for the initial slide\n\t\t\t// Delay the call in order to make sure the layers\n\t\t\t// are scaled properly before displaying them\n\t\t\tsetTimeout(function() {\n\t\t\t\tthat.showLayers( that.selectedSlideIndex );\n\t\t\t}, 1);\n\t\t},\n\n\t\t// When the slider resizes, try to scale down the layers proportionally. The automatic scaling\n\t\t// will make use of an option, 'autoScaleReference', by comparing the current width of the slider\n\t\t// with the reference width. So, if the reference width is 1000 pixels and the current width is\n\t\t// 500 pixels, it means that the layers will be scaled down to 50% of their size.\n\t\t_layersOnResize: function() {\n\t\t\tvar that = this,\n\t\t\t\tautoScaleReference,\n\t\t\t\tuseAutoScale = this.settings.autoScaleLayers,\n\t\t\t\tscaleRatio;\n\n\t\t\tif ( this.settings.autoScaleLayers === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there isn't a reference for how the layers should scale down automatically, use the 'width'\n\t\t\t// option as a reference, unless the width was set to a percentage. If there isn't a set reference and\n\t\t\t// the width was set to a percentage, auto scaling will not be used because it's not possible to\n\t\t\t// calculate how much should the layers scale.\n\t\t\tif ( this.settings.autoScaleReference === -1 ) {\n\t\t\t\tif ( typeof this.settings.width === 'string' && this.settings.width.indexOf( '%' ) !== -1 ) {\n\t\t\t\t\tuseAutoScale = false;\n\t\t\t\t} else {\n\t\t\t\t\tautoScaleReference = parseInt( this.settings.width, 10 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tautoScaleReference = this.settings.autoScaleReference;\n\t\t\t}\n\n\t\t\tif ( useAutoScale === true && this.slideWidth < autoScaleReference ) {\n\t\t\t\tscaleRatio = that.slideWidth / autoScaleReference;\n\t\t\t} else {\n\t\t\t\tscaleRatio = 1;\n\t\t\t}\n\n\t\t\t$.each( this.slides, function( index, slide ) {\n\t\t\t\tif ( typeof slide.layers !== 'undefined' ) {\n\t\t\t\t\t$.each( slide.layers, function( index, layer ) {\n\t\t\t\t\t\tlayer.scale( scaleRatio );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Replace the 'gotoSlide' method with this one, which makes it possible to \n\t\t// change the slide only after the layers from the previous slide are hidden.\n\t\t_layersGotoSlide: function( index ) {\n\t\t\tvar that = this,\n\t\t\t\tanimatedLayers = this.slides[ this.selectedSlideIndex ].animatedLayers;\n\n\t\t\t// If the slider is dragged, don't wait for the layer to hide\n\t\t\tif ( this.$slider.hasClass( 'sp-swiping' ) || typeof animatedLayers === 'undefined' || animatedLayers.length === 0  ) {\n\t\t\t\tthis.layersGotoSlideReference( index );\n\t\t\t} else {\n\t\t\t\tthis.on( 'hideLayersComplete.' + NS, function() {\n\t\t\t\t\tthat.off( 'hideLayersComplete.' + NS );\n\t\t\t\t\tthat.layersGotoSlideReference( index );\n\t\t\t\t});\n\n\t\t\t\tthis.hideLayers( this.selectedSlideIndex );\n\t\t\t}\n\t\t},\n\n\t\t// When a new slide is selected, hide the layers from the previous slide\n\t\t// and show the layers from the current slide.\n\t\t_layersOnGotoSlide: function( event ) {\n\t\t\tif ( this.previousSlideIndex !== this.selectedSlideIndex ) {\n\t\t\t\tthis.hideLayers( this.previousSlideIndex );\n\t\t\t}\n\n\t\t\tthis.showLayers( this.selectedSlideIndex );\n\t\t},\n\n\t\t// Show the animated layers from the slide at the specified index,\n\t\t// and fire an event when all the layers from the slide become visible.\n\t\tshowLayers: function( index ) {\n\t\t\tvar that = this,\n\t\t\t\tanimatedLayers = this.slides[ index ].animatedLayers,\n\t\t\t\tlayerCounter = 0;\n\n\t\t\tif ( typeof animatedLayers === 'undefined' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$.each( animatedLayers, function( index, element ) {\n\n\t\t\t\t// If the layer is already visible, increment the counter directly, else wait \n\t\t\t\t// for the layer's showing animation to complete.\n\t\t\t\tif ( element.isVisible() === true ) {\n\t\t\t\t\tlayerCounter++;\n\n\t\t\t\t\tif ( layerCounter === animatedLayers.length ) {\n\t\t\t\t\t\tthat.trigger({ type: 'showLayersComplete', index: index });\n\t\t\t\t\t\tif ( $.isFunction( that.settings.showLayersComplete ) ) {\n\t\t\t\t\t\t\tthat.settings.showLayersComplete.call( that, { type: 'showLayersComplete', index: index });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.show(function() {\n\t\t\t\t\t\tlayerCounter++;\n\n\t\t\t\t\t\tif ( layerCounter === animatedLayers.length ) {\n\t\t\t\t\t\t\tthat.trigger({ type: 'showLayersComplete', index: index });\n\t\t\t\t\t\t\tif ( $.isFunction( that.settings.showLayersComplete ) ) {\n\t\t\t\t\t\t\t\tthat.settings.showLayersComplete.call( that, { type: 'showLayersComplete', index: index });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Hide the animated layers from the slide at the specified index,\n\t\t// and fire an event when all the layers from the slide become invisible.\n\t\thideLayers: function( index ) {\n\t\t\tvar that = this,\n\t\t\t\tanimatedLayers = this.slides[ index ].animatedLayers,\n\t\t\t\tlayerCounter = 0;\n\n\t\t\tif ( typeof animatedLayers === 'undefined' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$.each( animatedLayers, function( index, element ) {\n\n\t\t\t\t// If the layer is already invisible, increment the counter directly, else wait \n\t\t\t\t// for the layer's hiding animation to complete.\n\t\t\t\tif ( element.isVisible() === false ) {\n\t\t\t\t\tlayerCounter++;\n\n\t\t\t\t\tif ( layerCounter === animatedLayers.length ) {\n\t\t\t\t\t\tthat.trigger({ type: 'hideLayersComplete', index: index });\n\t\t\t\t\t\tif ( $.isFunction( that.settings.hideLayersComplete ) ) {\n\t\t\t\t\t\t\tthat.settings.hideLayersComplete.call( that, { type: 'hideLayersComplete', index: index });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.hide(function() {\n\t\t\t\t\t\tlayerCounter++;\n\n\t\t\t\t\t\tif ( layerCounter === animatedLayers.length ) {\n\t\t\t\t\t\t\tthat.trigger({ type: 'hideLayersComplete', index: index });\n\t\t\t\t\t\t\tif ( $.isFunction( that.settings.hideLayersComplete ) ) {\n\t\t\t\t\t\t\t\tthat.settings.hideLayersComplete.call( that, { type: 'hideLayersComplete', index: index });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyLayers: function() {\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis.off( 'sliderResize.' + NS );\n\t\t\tthis.off( 'gotoSlide.' + NS );\n\t\t\tthis.off( 'hideLayersComplete.' + NS );\n\t\t},\n\n\t\tlayersDefaults: {\n\n\t\t\t// Indicates whether the slider will wait for the layers to disappear before\n\t\t\t// going to a new slide\n\t\t\twaitForLayers: false,\n\n\t\t\t// Indicates whether the layers will be scaled automatically\n\t\t\tautoScaleLayers: true,\n\n\t\t\t// Sets a reference width which will be compared to the current slider width\n\t\t\t// in order to determine how much the layers need to scale down. By default,\n\t\t\t// the reference width will be equal to the slide width. However, if the slide width\n\t\t\t// is set to a percentage value, then it's necessary to set a specific value for 'autoScaleReference'.\n\t\t\tautoScaleReference: -1,\n\n\t\t\t// Called when all animated layers become visible\n\t\t\tshowLayersComplete: function() {},\n\n\t\t\t// Called when all animated layers become invisible\n\t\t\thideLayersComplete: function() {}\n\t\t}\n\t};\n\n\t// Override the slide's 'destroy' method in order to destroy the \n\t// layers that where added to the slide as well.\n\tvar slideDestroy = window.SliderProSlide.prototype.destroy;\n\n\twindow.SliderProSlide.prototype.destroy = function() {\n\t\tif ( typeof this.layers !== 'undefined' ) {\n\t\t\t$.each( this.layers, function( index, element ) {\n\t\t\t\telement.destroy();\n\t\t\t});\n\n\t\t\tthis.layers.length = 0;\n\t\t}\n\n\t\tif ( typeof this.animatedLayers !== 'undefined' ) {\n\t\t\tthis.animatedLayers.length = 0;\n\t\t}\n\n\t\tslideDestroy.apply( this );\n\t};\n\n\tvar Layer = function( layer ) {\n\n\t\t// Reference to the layer jQuery element\n\t\tthis.$layer = layer;\n\n\t\t// Indicates whether a layer is currently visible or hidden\n\t\tthis.visible = false;\n\n\t\t// Indicates whether the layer was styled\n\t\tthis.styled = false;\n\n\t\t// Holds the data attributes added to the layer\n\t\tthis.data = null;\n\n\t\t// Indicates the layer's reference point (topLeft, bottomLeft, topRight or bottomRight)\n\t\tthis.position = null;\n\t\t\n\t\t// Indicates which CSS property (left or right) will be used for positioning the layer \n\t\tthis.horizontalProperty = null;\n\t\t\n\t\t// Indicates which CSS property (top or bottom) will be used for positioning the layer \n\t\tthis.verticalProperty = null;\n\n\t\t// Indicates the value of the horizontal position\n\t\tthis.horizontalPosition = null;\n\t\t\n\t\t// Indicates the value of the vertical position\n\t\tthis.verticalPosition = null;\n\n\t\t// Indicates how much the layers needs to be scaled\n\t\tthis.scaleRatio = 1;\n\n\t\t// Indicates the type of supported transition (CSS3 2D, CSS3 3D or JavaScript)\n\t\tthis.supportedAnimation = SliderProUtils.getSupportedAnimation();\n\n\t\t// Indicates the required vendor prefix for CSS (i.e., -webkit, -moz, etc.)\n\t\tthis.vendorPrefix = SliderProUtils.getVendorPrefix();\n\n\t\t// Indicates the name of the CSS transition's complete event (i.e., transitionend, webkitTransitionEnd, etc.)\n\t\tthis.transitionEvent = SliderProUtils.getTransitionEvent();\n\n\t\t// Reference to the timer that will be used to hide/show the layers\n\t\tthis.delayTimer = null;\n\n\t\t// Reference to the timer that will be used to hide the layers automatically after a given time interval\n\t\tthis.stayTimer = null;\n\n\t\tthis._init();\n\t};\n\n\tLayer.prototype = {\n\n\t\t// Initialize the layers\n\t\t_init: function() {\n\t\t\tthis.$layer.attr( 'data-layer-init', true );\n\n\t\t\tif ( this.$layer.hasClass( 'sp-static' ) ) {\n\t\t\t\tthis._setStyle();\n\t\t\t} else {\n\t\t\t\tthis.$layer.css({ 'visibility': 'hidden' });\n\t\t\t}\n\t\t},\n\n\t\t// Set the size and position of the layer\n\t\t_setStyle: function() {\n\t\t\tthis.styled = true;\n\n\t\t\t// Get the data attributes specified in HTML\n\t\t\tthis.data = this.$layer.data();\n\t\t\t\n\t\t\tif ( typeof this.data.width !== 'undefined' ) {\n\t\t\t\tthis.$layer.css( 'width', this.data.width );\n\t\t\t}\n\n\t\t\tif ( typeof this.data.height !== 'undefined' ) {\n\t\t\t\tthis.$layer.css( 'height', this.data.height );\n\t\t\t}\n\n\t\t\tif ( typeof this.data.depth !== 'undefined' ) {\n\t\t\t\tthis.$layer.css( 'z-index', this.data.depth );\n\t\t\t}\n\n\t\t\tthis.position = this.data.position ? ( this.data.position ).toLowerCase() : 'topleft';\n\n\t\t\tif ( this.position.indexOf( 'right' ) !== -1 ) {\n\t\t\t\tthis.horizontalProperty = 'right';\n\t\t\t} else if ( this.position.indexOf( 'left' ) !== -1 ) {\n\t\t\t\tthis.horizontalProperty = 'left';\n\t\t\t} else {\n\t\t\t\tthis.horizontalProperty = 'center';\n\t\t\t}\n\n\t\t\tif ( this.position.indexOf( 'bottom' ) !== -1 ) {\n\t\t\t\tthis.verticalProperty = 'bottom';\n\t\t\t} else if ( this.position.indexOf( 'top' ) !== -1 ) {\n\t\t\t\tthis.verticalProperty = 'top';\n\t\t\t} else {\n\t\t\t\tthis.verticalProperty = 'center';\n\t\t\t}\n\n\t\t\tthis._setPosition();\n\n\t\t\tthis.scale( this.scaleRatio );\n\t\t},\n\n\t\t// Set the position of the layer\n\t\t_setPosition: function() {\n\t\t\tvar inlineStyle = this.$layer.attr( 'style' );\n\n\t\t\tthis.horizontalPosition = typeof this.data.horizontal !== 'undefined' ? this.data.horizontal : 0;\n\t\t\tthis.verticalPosition = typeof this.data.vertical !== 'undefined' ? this.data.vertical : 0;\n\n\t\t\t// Set the horizontal position of the layer based on the data set\n\t\t\tif ( this.horizontalProperty === 'center' ) {\n\t\t\t\t\n\t\t\t\t// prevent content wrapping while setting the width\n\t\t\t\tif ( this.$layer.is( 'img' ) === false && ( typeof inlineStyle === 'undefined' || ( typeof inlineStyle !== 'undefined' && inlineStyle.indexOf( 'width' ) === -1 ) ) ) {\n\t\t\t\t\tthis.$layer.css( 'white-space', 'nowrap' );\n\t\t\t\t\tthis.$layer.css( 'width', this.$layer.outerWidth( true ) );\n\t\t\t\t}\n\n\t\t\t\tthis.$layer.css({ 'marginLeft': 'auto', 'marginRight': 'auto', 'left': this.horizontalPosition, 'right': 0 });\n\t\t\t} else {\n\t\t\t\tthis.$layer.css( this.horizontalProperty, this.horizontalPosition );\n\t\t\t}\n\n\t\t\t// Set the vertical position of the layer based on the data set\n\t\t\tif ( this.verticalProperty === 'center' ) {\n\n\t\t\t\t// prevent content wrapping while setting the height\n\t\t\t\tif ( this.$layer.is( 'img' ) === false && ( typeof inlineStyle === 'undefined' || ( typeof inlineStyle !== 'undefined' && inlineStyle.indexOf( 'height' ) === -1 ) ) ) {\n\t\t\t\t\tthis.$layer.css( 'white-space', 'nowrap' );\n\t\t\t\t\tthis.$layer.css( 'height', this.$layer.outerHeight( true ) );\n\t\t\t\t}\n\n\t\t\t\tthis.$layer.css({ 'marginTop': 'auto', 'marginBottom': 'auto', 'top': this.verticalPosition, 'bottom': 0 });\n\t\t\t} else {\n\t\t\t\tthis.$layer.css( this.verticalProperty, this.verticalPosition );\n\t\t\t}\n\t\t},\n\n\t\t// Scale the layer\n\t\tscale: function( ratio ) {\n\n\t\t\t// Return if the layer is set to be unscalable\n\t\t\tif ( this.$layer.hasClass( 'sp-no-scale' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Store the ratio (even if the layer is not ready to be scaled yet)\n\t\t\tthis.scaleRatio = ratio;\n\n\t\t\t// Return if the layer is not styled yet\n\t\t\tif ( this.styled === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar horizontalProperty = this.horizontalProperty === 'center' ? 'left' : this.horizontalProperty,\n\t\t\t\tverticalProperty = this.verticalProperty === 'center' ? 'top' : this.verticalProperty,\n\t\t\t\tcss = {};\n\n\t\t\t// Apply the scaling\n\t\t\tcss[ this.vendorPrefix + 'transform-origin' ] = this.horizontalProperty + ' ' + this.verticalProperty;\n\t\t\tcss[ this.vendorPrefix + 'transform' ] = 'scale(' + this.scaleRatio + ')';\n\n\t\t\t// If the position is not set to a percentage value, apply the scaling to the position\n\t\t\tif ( typeof this.horizontalPosition !== 'string' ) {\n\t\t\t\tcss[ horizontalProperty ] = this.horizontalPosition * this.scaleRatio;\n\t\t\t}\n\n\t\t\t// If the position is not set to a percentage value, apply the scaling to the position\n\t\t\tif ( typeof this.verticalPosition !== 'string' ) {\n\t\t\t\tcss[ verticalProperty ] = this.verticalPosition * this.scaleRatio;\n\t\t\t}\n\n\t\t\t// If the width or height is set to a percentage value, increase the percentage in order to\n\t\t\t// maintain the same layer to slide proportions. This is necessary because otherwise the scaling\n\t\t\t// transform would minimize the layers more than intended.\n\t\t\tif ( typeof this.data.width === 'string' && this.data.width.indexOf( '%' ) !== -1 ) {\n\t\t\t\tcss.width = ( parseInt( this.data.width, 10 ) / this.scaleRatio ).toString() + '%';\n\t\t\t}\n\n\t\t\tif ( typeof this.data.height === 'string' && this.data.height.indexOf( '%' ) !== -1 ) {\n\t\t\t\tcss.height = ( parseInt( this.data.height, 10 ) / this.scaleRatio ).toString() + '%';\n\t\t\t}\n\n\t\t\tthis.$layer.css( css );\n\t\t},\n\n\t\t// Show the layer\n\t\tshow: function( callback ) {\n\t\t\tif ( this.visible === true ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.visible = true;\n\n\t\t\t// First, style the layer if it's not already styled\n\t\t\tif ( this.styled === false ) {\n\t\t\t\tthis._setStyle();\n\t\t\t}\n\n\t\t\tvar that = this,\n\t\t\t\toffset = typeof this.data.showOffset !== 'undefined' ? this.data.showOffset : 50,\n\t\t\t\tduration = typeof this.data.showDuration !== 'undefined' ? this.data.showDuration / 1000 : 0.4,\n\t\t\t\tdelay = typeof this.data.showDelay !== 'undefined' ? this.data.showDelay : 10,\n\t\t\t\tstayDuration = typeof that.data.stayDuration !== 'undefined' ? parseInt( that.data.stayDuration, 10 ) : -1;\n\n\t\t\t// Animate the layers with CSS3 or with JavaScript\n\t\t\tif ( this.supportedAnimation === 'javascript' ) {\n\t\t\t\tthis.$layer\n\t\t\t\t\t.stop()\n\t\t\t\t\t.delay( delay )\n\t\t\t\t\t.css({ 'opacity': 0, 'visibility': 'visible' })\n\t\t\t\t\t.animate( { 'opacity': 1 }, duration * 1000, function() {\n\n\t\t\t\t\t\t// Hide the layer after a given time interval\n\t\t\t\t\t\tif ( stayDuration !== -1 ) {\n\t\t\t\t\t\t\tthat.stayTimer = setTimeout(function() {\n\t\t\t\t\t\t\t\tthat.hide();\n\t\t\t\t\t\t\t\tthat.stayTimer = null;\n\t\t\t\t\t\t\t}, stayDuration );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( typeof callback !== 'undefined' ) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar start = { 'opacity': 0, 'visibility': 'visible' },\n\t\t\t\t\ttarget = { 'opacity': 1 },\n\t\t\t\t\ttransformValues = '';\n\n\t\t\t\tstart[ this.vendorPrefix + 'transform' ] = 'scale(' + this.scaleRatio + ')';\n\t\t\t\ttarget[ this.vendorPrefix + 'transform' ] = 'scale(' + this.scaleRatio + ')';\n\t\t\t\ttarget[ this.vendorPrefix + 'transition' ] = 'opacity ' + duration + 's';\n\n\t\t\t\tif ( typeof this.data.showTransition !== 'undefined' ) {\n\t\t\t\t\tif ( this.data.showTransition === 'left' ) {\n\t\t\t\t\t\ttransformValues = offset + 'px, 0';\n\t\t\t\t\t} else if ( this.data.showTransition === 'right' ) {\n\t\t\t\t\t\ttransformValues = '-' + offset + 'px, 0';\n\t\t\t\t\t} else if ( this.data.showTransition === 'up' ) {\n\t\t\t\t\t\ttransformValues = '0, ' + offset + 'px';\n\t\t\t\t\t} else if ( this.data.showTransition === 'down') {\n\t\t\t\t\t\ttransformValues = '0, -' + offset + 'px';\n\t\t\t\t\t}\n\n\t\t\t\t\tstart[ this.vendorPrefix + 'transform' ] += this.supportedAnimation === 'css-3d' ? ' translate3d(' + transformValues + ', 0)' : ' translate(' + transformValues + ')';\n\t\t\t\t\ttarget[ this.vendorPrefix + 'transform' ] += this.supportedAnimation === 'css-3d' ? ' translate3d(0, 0, 0)' : ' translate(0, 0)';\n\t\t\t\t\ttarget[ this.vendorPrefix + 'transition' ] += ', ' + this.vendorPrefix + 'transform ' + duration + 's';\n\t\t\t\t}\n\n\t\t\t\t// Listen when the layer animation is complete\n\t\t\t\tthis.$layer.on( this.transitionEvent, function( event ) {\n\t\t\t\t\tif ( event.target !== event.currentTarget ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthat.$layer\n\t\t\t\t\t\t.off( that.transitionEvent )\n\t\t\t\t\t\t.css( that.vendorPrefix + 'transition', '' );\n\n\t\t\t\t\t// Hide the layer after a given time interval\n\t\t\t\t\tif ( stayDuration !== -1 ) {\n\t\t\t\t\t\tthat.stayTimer = setTimeout(function() {\n\t\t\t\t\t\t\tthat.hide();\n\t\t\t\t\t\t\tthat.stayTimer = null;\n\t\t\t\t\t\t}, stayDuration );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( typeof callback !== 'undefined' ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthis.$layer.css( start );\n\n\t\t\t\tthis.delayTimer = setTimeout( function() {\n\t\t\t\t\tthat.$layer.css( target );\n\t\t\t\t}, delay );\n\t\t\t}\n\t\t},\n\n\t\t// Hide the layer\n\t\thide: function( callback ) {\n\t\t\tif ( this.visible === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar that = this,\n\t\t\t\toffset = typeof this.data.hideOffset !== 'undefined' ? this.data.hideOffset : 50,\n\t\t\t\tduration = typeof this.data.hideDuration !== 'undefined' ? this.data.hideDuration / 1000 : 0.4,\n\t\t\t\tdelay = typeof this.data.hideDelay !== 'undefined' ? this.data.hideDelay : 10;\n\n\t\t\tthis.visible = false;\n\n\t\t\t// If the layer is hidden before it hides automatically, clear the timer\n\t\t\tif ( this.stayTimer !== null ) {\n\t\t\t\tclearTimeout( this.stayTimer );\n\t\t\t}\n\n\t\t\t// Animate the layers with CSS3 or with JavaScript\n\t\t\tif ( this.supportedAnimation === 'javascript' ) {\n\t\t\t\tthis.$layer\n\t\t\t\t\t.stop()\n\t\t\t\t\t.delay( delay )\n\t\t\t\t\t.animate({ 'opacity': 0 }, duration * 1000, function() {\n\t\t\t\t\t\t$( this ).css( 'visibility', 'hidden' );\n\n\t\t\t\t\t\tif ( typeof callback !== 'undefined' ) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar transformValues = '',\n\t\t\t\t\ttarget = { 'opacity': 0 };\n\n\t\t\t\ttarget[ this.vendorPrefix + 'transform' ] = 'scale(' + this.scaleRatio + ')';\n\t\t\t\ttarget[ this.vendorPrefix + 'transition' ] = 'opacity ' + duration + 's';\n\n\t\t\t\tif ( typeof this.data.hideTransition !== 'undefined' ) {\n\t\t\t\t\tif ( this.data.hideTransition === 'left' ) {\n\t\t\t\t\t\ttransformValues = '-' + offset + 'px, 0';\n\t\t\t\t\t} else if ( this.data.hideTransition === 'right' ) {\n\t\t\t\t\t\ttransformValues = offset + 'px, 0';\n\t\t\t\t\t} else if ( this.data.hideTransition === 'up' ) {\n\t\t\t\t\t\ttransformValues = '0, -' + offset + 'px';\n\t\t\t\t\t} else if ( this.data.hideTransition === 'down' ) {\n\t\t\t\t\t\ttransformValues = '0, ' + offset + 'px';\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ this.vendorPrefix + 'transform' ] += this.supportedAnimation === 'css-3d' ? ' translate3d(' + transformValues + ', 0)' : ' translate(' + transformValues + ')';\n\t\t\t\t\ttarget[ this.vendorPrefix + 'transition' ] += ', ' + this.vendorPrefix + 'transform ' + duration + 's';\n\t\t\t\t}\n\n\t\t\t\t// Listen when the layer animation is complete\n\t\t\t\tthis.$layer.on( this.transitionEvent, function( event ) {\n\t\t\t\t\tif ( event.target !== event.currentTarget ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthat.$layer\n\t\t\t\t\t\t.off( that.transitionEvent )\n\t\t\t\t\t\t.css( that.vendorPrefix + 'transition', '' );\n\n\t\t\t\t\t// Hide the layer after transition\n\t\t\t\t\tif ( that.visible === false ) {\n\t\t\t\t\t\tthat.$layer.css( 'visibility', 'hidden' );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( typeof callback !== 'undefined' ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthis.delayTimer = setTimeout( function() {\n\t\t\t\t\tthat.$layer.css( target );\n\t\t\t\t}, delay );\n\t\t\t}\n\t\t},\n\n\t\tisVisible: function() {\n\t\t\tif ( this.visible === false || this.$layer.is( ':hidden' ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t// Destroy the layer\n\t\tdestroy: function() {\n\t\t\tthis.$layer.removeAttr( 'style' );\n\t\t\tthis.$layer.removeAttr( 'data-layer-init' );\n\t\t\tclearTimeout( this.delayTimer );\n\t\t\tclearTimeout( this.stayTimer );\n\t\t\tthis.delayTimer = null;\n\t\t\tthis.stayTimer = null;\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Layers', Layers );\n\t\n})( window, jQuery );\n\n// Fade module for Slider Pro.\n// \n// Adds the possibility to navigate through slides using a cross-fade effect.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\tvar NS = 'Fade.' + $.SliderPro.namespace;\n\n\tvar Fade = {\n\n\t\t// Reference to the original 'gotoSlide' method\n\t\tfadeGotoSlideReference: null,\n\n\t\tinitFade: function() {\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._fadeOnUpdate, this ) );\n\t\t},\n\n\t\t// If fade is enabled, store a reference to the original 'gotoSlide' method\n\t\t// and then assign a new function to 'gotoSlide'.\n\t\t_fadeOnUpdate: function() {\n\t\t\tif ( this.settings.fade === true ) {\n\t\t\t\tthis.fadeGotoSlideReference = this.gotoSlide;\n\t\t\t\tthis.gotoSlide = this._fadeGotoSlide;\n\t\t\t}\n\t\t},\n\n\t\t// Will replace the original 'gotoSlide' function by adding a cross-fade effect\n\t\t// between the previous and the next slide.\n\t\t_fadeGotoSlide: function( index ) {\n\t\t\tif ( index === this.selectedSlideIndex ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// If the slides are being swiped/dragged, don't use fade, but call the original method instead.\n\t\t\t// If not, which means that a new slide was selected through a button, arrows or direct call, then\n\t\t\t// use fade.\n\t\t\tif ( this.$slider.hasClass( 'sp-swiping' ) ) {\n\t\t\t\tthis.fadeGotoSlideReference( index );\n\t\t\t} else {\n\t\t\t\tvar that = this,\n\t\t\t\t\t$nextSlide,\n\t\t\t\t\t$previousSlide,\n\t\t\t\t\tnewIndex = index;\n\n\t\t\t\t// Loop through all the slides and overlap the previous and next slide,\n\t\t\t\t// and hide the other slides.\n\t\t\t\t$.each( this.slides, function( index, element ) {\n\t\t\t\t\tvar slideIndex = element.getIndex(),\n\t\t\t\t\t\t$slide = element.$slide;\n\n\t\t\t\t\tif ( slideIndex === newIndex ) {\n\t\t\t\t\t\t$slide.css({ 'opacity': 0, 'left': 0, 'top': 0, 'z-index': 20, visibility: 'visible' });\n\t\t\t\t\t\t$nextSlide = $slide;\n\t\t\t\t\t} else if ( slideIndex === that.selectedSlideIndex ) {\n\t\t\t\t\t\t$slide.css({ 'opacity': 1, 'left': 0, 'top': 0, 'z-index': 10, visibility: 'visible' });\n\t\t\t\t\t\t$previousSlide = $slide;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$slide.css({ 'opacity': 1, visibility: 'hidden', 'z-index': '' });\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Set the new indexes for the previous and selected slides\n\t\t\t\tthis.previousSlideIndex = this.selectedSlideIndex;\n\t\t\t\tthis.selectedSlideIndex = index;\n\n\t\t\t\t// Re-assign the 'sp-selected' class to the currently selected slide\n\t\t\t\tthis.$slides.find( '.sp-selected' ).removeClass( 'sp-selected' );\n\t\t\t\tthis.$slides.find( '.sp-slide' ).eq( this.selectedSlideIndex ).addClass( 'sp-selected' );\n\t\t\t\n\t\t\t\t// Rearrange the slides if the slider is loop-able\n\t\t\t\tif ( that.settings.loop === true ) {\n\t\t\t\t\tthat._updateSlidesOrder();\n\t\t\t\t}\n\n\t\t\t\t// Move the slides container so that the cross-fading slides (which now have the top and left\n\t\t\t\t// position set to 0) become visible.\n\t\t\t\tthis._moveTo( 0, true );\n\n\t\t\t\t// Fade in the selected slide\n\t\t\t\tthis._fadeSlideTo( $nextSlide, 1, function() {\n\n\t\t\t\t\t// This flag will indicate if all the fade transitions are complete,\n\t\t\t\t\t// in case there are multiple running at the same time, which happens\n\t\t\t\t\t// when the slides are navigated very quickly\n\t\t\t\t\tvar allTransitionsComplete = true;\n\n\t\t\t\t\t// Go through all the slides and check if there is at least one slide \n\t\t\t\t\t// that is still transitioning.\n\t\t\t\t\t$.each( that.slides, function( index, element ) {\n\t\t\t\t\t\tif ( typeof element.$slide.attr( 'data-transitioning' ) !== 'undefined' ) {\n\t\t\t\t\t\t\tallTransitionsComplete = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif ( allTransitionsComplete === true ) {\n\n\t\t\t\t\t\t// After all the transitions are complete, make all the slides visible again\n\t\t\t\t\t\t$.each( that.slides, function( index, element ) {\n\t\t\t\t\t\t\tvar $slide = element.$slide;\n\t\t\t\t\t\t\t$slide.css({ 'visibility': '', 'opacity': '', 'z-index': '' });\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Reset the position of the slides and slides container\n\t\t\t\t\t\tthat._resetSlidesPosition();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fire the 'gotoSlideComplete' event\n\t\t\t\t\tthat.trigger({ type: 'gotoSlideComplete', index: index, previousIndex: that.previousSlideIndex });\n\t\t\t\t\tif ( $.isFunction( that.settings.gotoSlideComplete ) ) {\n\t\t\t\t\t\tthat.settings.gotoSlideComplete.call( that, { type: 'gotoSlideComplete', index: index, previousIndex: that.previousSlideIndex } );\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Fade out the previous slide, if indicated, in addition to fading in the next slide\n\t\t\t\tif ( this.settings.fadeOutPreviousSlide === true ) {\n\t\t\t\t\tthis._fadeSlideTo( $previousSlide, 0 );\n\t\t\t\t}\n\n\t\t\t\tif ( this.settings.autoHeight === true ) {\n\t\t\t\t\tthis._resizeHeight();\n\t\t\t\t}\n\n\t\t\t\t// Fire the 'gotoSlide' event\n\t\t\t\tthis.trigger({ type: 'gotoSlide', index: index, previousIndex: this.previousSlideIndex });\n\t\t\t\tif ( $.isFunction( this.settings.gotoSlide ) ) {\n\t\t\t\t\tthis.settings.gotoSlide.call( this, { type: 'gotoSlide', index: index, previousIndex: this.previousSlideIndex });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Fade the target slide to the specified opacity (0 or 1)\n\t\t_fadeSlideTo: function( target, opacity, callback ) {\n\t\t\tvar that = this;\n\n\t\t\t// apply the attribute only to slides that fade in\n\t\t\tif ( opacity === 1 ) {\n\t\t\t\ttarget.attr( 'data-transitioning', true );\n\t\t\t}\n\n\t\t\t// Use CSS transitions if they are supported. If not, use JavaScript animation.\n\t\t\tif ( this.supportedAnimation === 'css-3d' || this.supportedAnimation === 'css-2d' ) {\n\n\t\t\t\t// There needs to be a delay between the moment the opacity is set\n\t\t\t\t// and the moment the transitions starts.\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\tvar css = { 'opacity': opacity };\n\t\t\t\t\tcss[ that.vendorPrefix + 'transition' ] = 'opacity ' + that.settings.fadeDuration / 1000 + 's';\n\t\t\t\t\ttarget.css( css );\n\t\t\t\t}, 100 );\n\n\t\t\t\ttarget.on( this.transitionEvent, function( event ) {\n\t\t\t\t\tif ( event.target !== event.currentTarget ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttarget.off( that.transitionEvent );\n\t\t\t\t\ttarget.css( that.vendorPrefix + 'transition', '' );\n\t\t\t\t\ttarget.removeAttr( 'data-transitioning');\n\n\t\t\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttarget.stop().animate({ 'opacity': opacity }, this.settings.fadeDuration, function() {\n\t\t\t\t\ttarget.removeAttr( 'data-transitioning' );\n\n\t\t\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyFade: function() {\n\t\t\tthis.off( 'update.' + NS );\n\n\t\t\tif ( this.fadeGotoSlideReference !== null ) {\n\t\t\t\tthis.gotoSlide = this.fadeGotoSlideReference;\n\t\t\t}\n\t\t},\n\n\t\tfadeDefaults: {\n\n\t\t\t// Indicates if fade will be used\n\t\t\tfade: false,\n\n\t\t\t// Indicates if the previous slide will be faded out (in addition to the next slide being faded in)\n\t\t\tfadeOutPreviousSlide: true,\n\n\t\t\t// Sets the duration of the fade effect\n\t\t\tfadeDuration: 500\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Fade', Fade );\n\n})( window, jQuery );\n\n// Touch Swipe module for Slider Pro.\n// \n// Adds touch-swipe functionality for slides.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\t\n\tvar NS = 'TouchSwipe.' + $.SliderPro.namespace;\n\n\tvar TouchSwipe = {\n\n\t\t// The x and y coordinates of the pointer/finger's starting position\n\t\ttouchStartPoint: {x: 0, y: 0},\n\n\t\t// The x and y coordinates of the pointer/finger's end position\n\t\ttouchEndPoint: {x: 0, y: 0},\n\n\t\t// The distance from the starting to the end position on the x and y axis\n\t\ttouchDistance: {x: 0, y: 0},\n\n\t\t// The position of the slides when the touch swipe starts\n\t\ttouchStartPosition: 0,\n\n\t\t// Indicates if the slides are being swiped\n\t\tisTouchMoving: false,\n\n\t\t// Stores the names of the events\n\t\ttouchSwipeEvents: { startEvent: '', moveEvent: '', endEvent: '' },\n\n\t\t// Indicates if scrolling (the page) in the opposite direction of the\n\t\t// slides' layout is allowed. This is used to block vertical (or horizontal)\n\t\t// scrolling when the user is scrolling through the slides.\n\t\tallowOppositeScrolling: true,\n\n\t\t// Indicates whether the previous 'start' event was a 'touchstart' or 'mousedown'\n\t\tpreviousStartEvent: '',\n\n\t\tinitTouchSwipe: function() {\n\t\t\tvar that = this;\n\n\t\t\t// check if touch swipe is enabled\n\t\t\tif ( this.settings.touchSwipe === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.touchSwipeEvents.startEvent = 'touchstart' + '.' + NS + ' mousedown' + '.' + NS;\n\t\t\tthis.touchSwipeEvents.moveEvent = 'touchmove' + '.' + NS + ' mousemove' + '.' + NS;\n\t\t\tthis.touchSwipeEvents.endEvent = 'touchend' + '.' + this.uniqueId + '.' + NS + ' mouseup' + '.' + this.uniqueId + '.' + NS;\n\n\t\t\t// Listen for touch swipe/mouse move events\n\t\t\tthis.$slidesMask.on( this.touchSwipeEvents.startEvent, $.proxy( this._onTouchStart, this ) );\n\t\t\tthis.$slidesMask.on( 'dragstart.' + NS, function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\n\t\t\t// Prevent 'click' events unless there is intention for a 'click'\n\t\t\tthis.$slidesMask.find( 'a' ).on( 'click.' + NS, function( event ) {\n\t\t\t\tif ( that.$slider.hasClass( 'sp-swiping' ) ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Add the grabbing icon\n\t\t\tthis.$slidesMask.addClass( 'sp-grab' );\n\t\t},\n\n\t\t// Called when the slides starts being dragged\n\t\t_onTouchStart: function( event ) {\n\n\t\t\t// Return if a 'mousedown' event follows a 'touchstart' event\n\t\t\tif ( event.type === 'mousedown' && this.previousStartEvent === 'touchstart' ) {\n\t\t\t\tthis.previousStartEvent = event.type;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Assign the new 'start' event\n\t\t\tthis.previousStartEvent = event.type;\n\n\t\t\t// Disable dragging if the element is set to allow selections\n\t\t\tif ( $( event.target ).closest( '.sp-selectable' ).length >= 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar that = this,\n\t\t\t\teventObject = typeof event.originalEvent.touches !== 'undefined' ? event.originalEvent.touches[0] : event.originalEvent;\n\n\t\t\t// Get the initial position of the mouse pointer and the initial position\n\t\t\t// of the slides' container\n\t\t\tthis.touchStartPoint.x = eventObject.pageX || eventObject.clientX;\n\t\t\tthis.touchStartPoint.y = eventObject.pageY || eventObject.clientY;\n\t\t\tthis.touchStartPosition = this.slidesPosition;\n\n\t\t\t// Clear the previous distance values\n\t\t\tthis.touchDistance.x = this.touchDistance.y = 0;\n\n\t\t\t// If the slides are being grabbed while they're still animating, stop the\n\t\t\t// current movement\n\t\t\tif ( this.$slides.hasClass( 'sp-animated' ) ) {\n\t\t\t\tthis.isTouchMoving = true;\n\t\t\t\tthis._stopMovement();\n\t\t\t\tthis.touchStartPosition = this.slidesPosition;\n\t\t\t}\n\n\t\t\t// Listen for move and end events\n\t\t\tthis.$slidesMask.on( this.touchSwipeEvents.moveEvent, $.proxy( this._onTouchMove, this ) );\n\t\t\t$( document ).on( this.touchSwipeEvents.endEvent, $.proxy( this._onTouchEnd, this ) );\n\n\t\t\t// Swap grabbing icons\n\t\t\tthis.$slidesMask.removeClass( 'sp-grab' ).addClass( 'sp-grabbing' );\n\t\t},\n\n\t\t// Called during the slides' dragging\n\t\t_onTouchMove: function( event ) {\n\t\t\tvar eventObject = typeof event.originalEvent.touches !== 'undefined' ? event.originalEvent.touches[0] : event.originalEvent;\n\n\t\t\t// Indicate that the move event is being fired\n\t\t\tthis.isTouchMoving = true;\n\n\t\t\t// Add 'sp-swiping' class to indicate that the slides are being swiped\n\t\t\tif ( this.$slider.hasClass( 'sp-swiping' ) === false ) {\n\t\t\t\tthis.$slider.addClass( 'sp-swiping' );\n\t\t\t}\n\n\t\t\t// Get the current position of the mouse pointer\n\t\t\tthis.touchEndPoint.x = eventObject.pageX || eventObject.clientX;\n\t\t\tthis.touchEndPoint.y = eventObject.pageY || eventObject.clientY;\n\n\t\t\t// Calculate the distance of the movement on both axis\n\t\t\tthis.touchDistance.x = this.touchEndPoint.x - this.touchStartPoint.x;\n\t\t\tthis.touchDistance.y = this.touchEndPoint.y - this.touchStartPoint.y;\n\t\t\t\n\t\t\t// Calculate the distance of the swipe that takes place in the same direction as the orientation of the slides\n\t\t\t// and calculate the distance from the opposite direction.\n\t\t\t// \n\t\t\t// For a swipe to be valid there should more distance in the same direction as the orientation of the slides.\n\t\t\tvar distance = this.settings.orientation === 'horizontal' ? this.touchDistance.x : this.touchDistance.y,\n\t\t\t\toppositeDistance = this.settings.orientation === 'horizontal' ? this.touchDistance.y : this.touchDistance.x;\n\n\t\t\t// If the movement is in the same direction as the orientation of the slides, the swipe is valid\n\t\t\t// and opposite scrolling will not be allowed.\n\t\t\tif ( Math.abs( distance ) > Math.abs( oppositeDistance ) ) {\n\t\t\t\tthis.allowOppositeScrolling = false;\n\t\t\t}\n\n\t\t\t// If opposite scrolling is still allowed, the swipe wasn't valid, so return.\n\t\t\tif ( this.allowOppositeScrolling === true ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// Don't allow opposite scrolling\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( this.settings.loop === false ) {\n\t\t\t\t// Make the slides move slower if they're dragged outside its bounds\n\t\t\t\tif ( ( this.slidesPosition > this.touchStartPosition && this.selectedSlideIndex === 0 ) ||\n\t\t\t\t\t( this.slidesPosition < this.touchStartPosition && this.selectedSlideIndex === this.getTotalSlides() - 1 )\n\t\t\t\t) {\n\t\t\t\t\tdistance = distance * 0.2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._moveTo( this.touchStartPosition + distance, true );\n\t\t},\n\n\t\t// Called when the slides are released\n\t\t_onTouchEnd: function( event ) {\n\t\t\tvar that = this,\n\t\t\t\ttouchDistance = this.settings.orientation === 'horizontal' ? this.touchDistance.x : this.touchDistance.y;\n\n\t\t\t// Remove the 'move' and 'end' listeners\n\t\t\tthis.$slidesMask.off( this.touchSwipeEvents.moveEvent );\n\t\t\t$( document ).off( this.touchSwipeEvents.endEvent );\n\n\t\t\tthis.allowOppositeScrolling = true;\n\n\t\t\t// Swap grabbing icons\n\t\t\tthis.$slidesMask.removeClass( 'sp-grabbing' ).addClass( 'sp-grab' );\n\n\t\t\t// Remove the 'sp-swiping' class with a delay, to allow\n\t\t\t// other event listeners (i.e. click) to check the existance\n\t\t\t// of the swipe event.\n\t\t\tif ( this.$slider.hasClass( 'sp-swiping' ) ) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tthat.$slider.removeClass( 'sp-swiping' );\n\t\t\t\t}, 100 );\n\t\t\t}\n\n\t\t\t// Return if the slides didn't move\n\t\t\tif ( this.isTouchMoving === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.isTouchMoving = false;\n\n\t\t\t// Calculate the old position of the slides in order to return to it if the swipe\n\t\t\t// is below the threshold\n\t\t\tvar selectedSlideOffset = this.settings.centerSelectedSlide === true && this.settings.visibleSize !== 'auto' ? Math.round( ( parseInt( this.$slidesMask.css( this.sizeProperty ), 10 ) - this.getSlideAt( this.selectedSlideIndex ).getSize()[ this.sizeProperty ] ) / 2 ) : 0,\n\t\t\t\toldSlidesPosition = - parseInt( this.$slides.find( '.sp-slide' ).eq( this.selectedSlideIndex ).css( this.positionProperty ), 10 ) + selectedSlideOffset;\n\n\t\t\tif ( Math.abs( touchDistance ) < this.settings.touchSwipeThreshold ) {\n\t\t\t\tthis._moveTo( oldSlidesPosition );\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// Calculate by how many slides the slides container has moved\n\t\t\t\tvar\tslideArrayDistance = ( this.settings.rightToLeft === true && this.settings.orientation === 'horizontal' ? -1 : 1 ) * touchDistance / ( this.averageSlideSize + this.settings.slideDistance );\n\n\t\t\t\t// Floor the obtained value and add or subtract 1, depending on the direction of the swipe\n\t\t\t\tslideArrayDistance = parseInt( slideArrayDistance, 10 ) + ( slideArrayDistance > 0 ? 1 : - 1 );\n\n\t\t\t\t// Get the index of the currently selected slide and subtract the position index in order to obtain\n\t\t\t\t// the new index of the selected slide. \n\t\t\t\tvar nextSlideIndex = this.slidesOrder[ $.inArray( this.selectedSlideIndex, this.slidesOrder ) - slideArrayDistance ];\n\n\t\t\t\tif ( this.settings.loop === true ) {\n\t\t\t\t\tthis.gotoSlide( nextSlideIndex );\n\t\t\t\t} else {\n\t\t\t\t\tif ( typeof nextSlideIndex !== 'undefined' ) {\n\t\t\t\t\t\tthis.gotoSlide( nextSlideIndex );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._moveTo( oldSlidesPosition );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyTouchSwipe: function() {\n\t\t\tthis.$slidesMask.off( 'dragstart.' + NS );\n\t\t\tthis.$slidesMask.find( 'a' ).off( 'click.' + NS );\n\n\t\t\tthis.$slidesMask.off( this.touchSwipeEvents.startEvent );\n\t\t\tthis.$slidesMask.off( this.touchSwipeEvents.moveEvent );\n\t\t\t$( document ).off( this.touchSwipeEvents.endEvent );\n\t\t\t\n\t\t\tthis.$slidesMask.removeClass( 'sp-grab' );\n\t\t},\n\n\t\ttouchSwipeDefaults: {\n\t\t\t\n\t\t\t// Indicates whether the touch swipe will be enabled\n\t\t\ttouchSwipe: true,\n\n\t\t\t// Sets the minimum amount that the slides should move\n\t\t\ttouchSwipeThreshold: 50\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'TouchSwipe', TouchSwipe );\n\t\n})( window, jQuery );\n\n// Caption module for Slider Pro.\n// \n// Adds a corresponding caption for each slide. The caption\n// will appear and disappear with the slide.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\t\n\tvar NS = 'Caption.' + $.SliderPro.namespace;\n\n\tvar Caption = {\n\n\t\t// Reference to the container element that will hold the caption\n\t\t$captionContainer: null,\n\n\t\t// The caption content/text\n\t\tcaptionContent: '',\n\n\t\tinitCaption: function() {\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._captionOnUpdate, this ) );\n\t\t\tthis.on( 'gotoSlide.' + NS, $.proxy( this._updateCaptionContent, this ) );\n\t\t},\n\n\t\t// Create the caption container and hide the captions inside the slides\n\t\t_captionOnUpdate: function() {\n\t\t\tthis.$captionContainer = this.$slider.find( '.sp-caption-container' );\n\n\t\t\tif ( this.$slider.find( '.sp-caption' ).length && this.$captionContainer.length === 0 ) {\n\t\t\t\tthis.$captionContainer = $( '<div class=\"sp-caption-container\"></div>' ).appendTo( this.$slider );\n\n\t\t\t\t// Show the caption for the selected slide\n\t\t\t\tthis._updateCaptionContent();\n\t\t\t}\n\n\t\t\t// Hide the captions inside the slides\n\t\t\tthis.$slides.find( '.sp-caption' ).each(function() {\n\t\t\t\t$( this ).css( 'display', 'none' );\n\t\t\t});\n\t\t},\n\n\t\t// Show the caption content for the selected slide\n\t\t_updateCaptionContent: function() {\n\t\t\tvar that = this,\n\t\t\t\tnewCaptionField = this.$slider.find( '.sp-slide' ).eq( this.selectedSlideIndex ).find( '.sp-caption' ),\n\t\t\t\tnewCaptionContent = newCaptionField.length !== 0 ? newCaptionField.html() : '';\n\n\t\t\t// Either use a fade effect for swapping the captions or use an instant change\n\t\t\tif ( this.settings.fadeCaption === true ) {\n\t\t\t\t\n\t\t\t\t// If the previous slide had a caption, fade out that caption first and when the animation is over\n\t\t\t\t// fade in the current caption.\n\t\t\t\t// If the previous slide didn't have a caption, fade in the current caption directly.\n\t\t\t\tif ( this.captionContent !== '' ) {\n\n\t\t\t\t\t// If the caption container has 0 opacity when the fade out transition starts, set it\n\t\t\t\t\t// to 1 because the transition wouldn't work if the initial and final values are the same,\n\t\t\t\t\t// and the callback functions wouldn't fire in this case.\n\t\t\t\t\tif ( parseFloat( this.$captionContainer.css( 'opacity' ), 10 ) === 0 ) {\n\t\t\t\t\t\tthis.$captionContainer.css( this.vendorPrefix + 'transition', '' );\n\t\t\t\t\t\tthis.$captionContainer.css( 'opacity', 1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._fadeCaptionTo( 0, function() {\n\t\t\t\t\t\tthat.captionContent = newCaptionContent;\n\n\t\t\t\t\t\tif ( newCaptionContent !== '' ) {\n\t\t\t\t\t\t\tthat.$captionContainer.html( that.captionContent );\n\t\t\t\t\t\t\tthat._fadeCaptionTo( 1 );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.$captionContainer.empty();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.captionContent = newCaptionContent;\n\t\t\t\t\tthis.$captionContainer.html( this.captionContent );\n\t\t\t\t\tthis.$captionContainer.css( 'opacity', 0 );\n\t\t\t\t\tthis._fadeCaptionTo( 1 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.captionContent = newCaptionContent;\n\t\t\t\tthis.$captionContainer.html( this.captionContent );\n\t\t\t}\n\t\t},\n\n\t\t// Fade the caption container to the specified opacity\n\t\t_fadeCaptionTo: function( opacity, callback ) {\n\t\t\tvar that = this;\n\n\t\t\t// Use CSS transitions if they are supported. If not, use JavaScript animation.\n\t\t\tif ( this.supportedAnimation === 'css-3d' || this.supportedAnimation === 'css-2d' ) {\n\t\t\t\t\n\t\t\t\t// There needs to be a delay between the moment the opacity is set\n\t\t\t\t// and the moment the transitions starts.\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\tvar css = { 'opacity': opacity };\n\t\t\t\t\tcss[ that.vendorPrefix + 'transition' ] = 'opacity ' + that.settings.captionFadeDuration / 1000 + 's';\n\t\t\t\t\tthat.$captionContainer.css( css );\n\t\t\t\t}, 1 );\n\n\t\t\t\tthis.$captionContainer.on( this.transitionEvent, function( event ) {\n\t\t\t\t\tif ( event.target !== event.currentTarget ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthat.$captionContainer.off( that.transitionEvent );\n\t\t\t\t\tthat.$captionContainer.css( that.vendorPrefix + 'transition', '' );\n\n\t\t\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.$captionContainer.stop().animate({ 'opacity': opacity }, this.settings.captionFadeDuration, function() {\n\t\t\t\t\tif ( typeof callback === 'function' ) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyCaption: function() {\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis.off( 'gotoSlide.' + NS );\n\n\t\t\tthis.$captionContainer.remove();\n\n\t\t\tthis.$slider.find( '.sp-caption' ).each(function() {\n\t\t\t\t$( this ).css( 'display', '' );\n\t\t\t});\n\t\t},\n\n\t\tcaptionDefaults: {\n\n\t\t\t// Indicates whether or not the captions will be faded\n\t\t\tfadeCaption: true,\n\n\t\t\t// Sets the duration of the fade animation\n\t\t\tcaptionFadeDuration: 500\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Caption', Caption );\n\t\n})( window, jQuery );\n\n// Deep Linking module for Slider Pro.\n// \n// Updates the hash of the URL as the user navigates through the slides.\n// Also, allows navigating to a specific slide by indicating it in the hash.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\tvar NS = 'DeepLinking.' + $.SliderPro.namespace;\n\n\tvar DeepLinking = {\n\n\t\tinitDeepLinking: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Parse the initial hash\n\t\t\tthis.on( 'init.' + NS, function() {\n\t\t\t\tthat._gotoHash( window.location.hash );\n\t\t\t});\n\n\t\t\t// Update the hash when a new slide is selected\n\t\t\tthis.on( 'gotoSlide.' + NS, function( event ) {\n\t\t\t\tif ( that.settings.updateHash === true ) {\n\n\t\t\t\t\t// get the 'id' attribute of the slide\n\t\t\t\t\tvar slideId = that.$slider.find( '.sp-slide' ).eq( event.index ).attr( 'id' );\n\n\t\t\t\t\t// if the slide doesn't have an 'id' attribute, use the slide index\n\t\t\t\t\tif ( typeof slideId === 'undefined' ) {\n\t\t\t\t\t\tslideId = event.index;\n\t\t\t\t\t}\n\n\t\t\t\t\twindow.location.hash = that.$slider.attr( 'id' ) + '/' + slideId;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Check when the hash changes and navigate to the indicated slide\n\t\t\t$( window ).on( 'hashchange.' + this.uniqueId + '.' + NS, function() {\n\t\t\t\tthat._gotoHash( window.location.hash );\n\t\t\t});\n\t\t},\n\n\t\t// Parse the hash and return the slider id and the slide id\n\t\t_parseHash: function( hash ) {\n\t\t\tif ( hash !== '' ) {\n\t\t\t\t// Eliminate the # symbol\n\t\t\t\thash = hash.substring(1);\n\n\t\t\t\t// Get the specified slider id and slide id\n\t\t\t\tvar values = hash.split( '/' ),\n\t\t\t\t\tslideId = values.pop(),\n\t\t\t\t\tsliderId = hash.slice( 0, - slideId.toString().length - 1 );\n\n\t\t\t\tif ( this.$slider.attr( 'id' ) === sliderId ) {\n\t\t\t\t\treturn { 'sliderID': sliderId, 'slideId': slideId };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t// Navigate to the appropriate slide, based on the specified hash\n\t\t_gotoHash: function( hash ) {\n\t\t\tvar result = this._parseHash( hash );\n\n\t\t\tif ( result === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar slideId = result.slideId,\n\t\t\t\tslideIdNumber = parseInt( slideId, 10 );\n\n\t\t\t// check if the specified slide id is a number or string\n\t\t\tif ( isNaN( slideIdNumber ) ) {\n\t\t\t\t// get the index of the slide based on the specified id\n\t\t\t\tvar slideIndex = this.$slider.find( '.sp-slide#' + slideId ).index();\n\n\t\t\t\tif ( slideIndex !== -1 && slideIndex !== this.selectedSlideIndex ) {\n\t\t\t\t\tthis.gotoSlide( slideIndex );\n\t\t\t\t}\n\t\t\t} else if ( slideIdNumber !== this.selectedSlideIndex ) {\n\t\t\t\tthis.gotoSlide( slideIdNumber );\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyDeepLinking: function() {\n\t\t\tthis.off( 'init.' + NS );\n\t\t\tthis.off( 'gotoSlide.' + NS );\n\t\t\t$( window ).off( 'hashchange.' + this.uniqueId + '.' + NS );\n\t\t},\n\n\t\tdeepLinkingDefaults: {\n\n\t\t\t// Indicates whether the hash will be updated when a new slide is selected\n\t\t\tupdateHash: false\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'DeepLinking', DeepLinking );\n\t\n})( window, jQuery );\n\n// Autoplay module for Slider Pro.\n// \n// Adds automatic navigation through the slides by calling the\n// 'nextSlide' or 'previousSlide' methods at certain time intervals.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\t\n\tvar NS = 'Autoplay.' + $.SliderPro.namespace;\n\n\tvar Autoplay = {\n\n\t\tautoplayTimer: null,\n\n\t\tisTimerRunning: false,\n\n\t\tisTimerPaused: false,\n\n\t\tinitAutoplay: function() {\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._autoplayOnUpdate, this ) );\n\t\t},\n\n\t\t// Start the autoplay if it's enabled, or stop it if it's disabled but running \n\t\t_autoplayOnUpdate: function( event ) {\n\t\t\tif ( this.settings.autoplay === true ) {\n\t\t\t\tthis.on( 'gotoSlide.' + NS, $.proxy( this._autoplayOnGotoSlide, this ) );\n\t\t\t\tthis.on( 'mouseenter.' + NS, $.proxy( this._autoplayOnMouseEnter, this ) );\n\t\t\t\tthis.on( 'mouseleave.' + NS, $.proxy( this._autoplayOnMouseLeave, this ) );\n\n\t\t\t\tthis.startAutoplay();\n\t\t\t} else {\n\t\t\t\tthis.off( 'gotoSlide.' + NS );\n\t\t\t\tthis.off( 'mouseenter.' + NS );\n\t\t\t\tthis.off( 'mouseleave.' + NS );\n\n\t\t\t\tthis.stopAutoplay();\n\t\t\t}\n\t\t},\n\n\t\t// Restart the autoplay timer when a new slide is selected\n\t\t_autoplayOnGotoSlide: function( event ) {\n\t\t\t// stop previous timers before starting a new one\n\t\t\tif ( this.isTimerRunning === true ) {\n\t\t\t\tthis.stopAutoplay();\n\t\t\t}\n\t\t\t\n\t\t\tif ( this.isTimerPaused === false ) {\n\t\t\t\tthis.startAutoplay();\n\t\t\t}\n\t\t},\n\n\t\t// Pause the autoplay when the slider is hovered\n\t\t_autoplayOnMouseEnter: function( event ) {\n\t\t\tif ( this.isTimerRunning && ( this.settings.autoplayOnHover === 'pause' || this.settings.autoplayOnHover === 'stop' ) ) {\n\t\t\t\tthis.stopAutoplay();\n\t\t\t\tthis.isTimerPaused = true;\n\t\t\t}\n\t\t},\n\n\t\t// Start the autoplay when the mouse moves away from the slider\n\t\t_autoplayOnMouseLeave: function( event ) {\n\t\t\tif ( this.settings.autoplay === true && this.isTimerRunning === false && this.settings.autoplayOnHover !== 'stop' ) {\n\t\t\t\tthis.startAutoplay();\n\t\t\t\tthis.isTimerPaused = false;\n\t\t\t}\n\t\t},\n\n\t\t// Starts the autoplay\n\t\tstartAutoplay: function() {\n\t\t\tvar that = this;\n\t\t\t\n\t\t\tthis.isTimerRunning = true;\n\n\t\t\tthis.autoplayTimer = setTimeout(function() {\n\t\t\t\tif ( that.settings.autoplayDirection === 'normal' ) {\n\t\t\t\t\tthat.nextSlide();\n\t\t\t\t} else if ( that.settings.autoplayDirection === 'backwards' ) {\n\t\t\t\t\tthat.previousSlide();\n\t\t\t\t}\n\t\t\t}, this.settings.autoplayDelay );\n\t\t},\n\n\t\t// Stops the autoplay\n\t\tstopAutoplay: function() {\n\t\t\tthis.isTimerRunning = false;\n\t\t\tthis.isTimerPaused = false;\n\n\t\t\tclearTimeout( this.autoplayTimer );\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyAutoplay: function() {\n\t\t\tclearTimeout( this.autoplayTimer );\n\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis.off( 'gotoSlide.' + NS );\n\t\t\tthis.off( 'mouseenter.' + NS );\n\t\t\tthis.off( 'mouseleave.' + NS );\n\t\t},\n\n\t\tautoplayDefaults: {\n\t\t\t// Indicates whether or not autoplay will be enabled\n\t\t\tautoplay: true,\n\n\t\t\t// Sets the delay/interval at which the autoplay will run\n\t\t\tautoplayDelay: 5000,\n\n\t\t\t// Indicates whether autoplay will navigate to the next slide or previous slide\n\t\t\tautoplayDirection: 'normal',\n\n\t\t\t// Indicates if the autoplay will be paused or stopped when the slider is hovered.\n\t\t\t// Possible values are 'pause', 'stop' or 'none'.\n\t\t\tautoplayOnHover: 'pause'\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Autoplay', Autoplay );\n\t\n})(window, jQuery);\n\n// Keyboard module for Slider Pro.\n// \n// Adds the possibility to navigate through slides using the keyboard arrow keys, or\n// open the link attached to the main slide image by using the Enter key.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\t\n\tvar NS = 'Keyboard.' + $.SliderPro.namespace;\n\n\tvar Keyboard = {\n\n\t\tinitKeyboard: function() {\n\t\t\tvar that = this,\n\t\t\t\thasFocus = false;\n\n\t\t\tif ( this.settings.keyboard === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Detect when the slide is in focus and when it's not, and, optionally, make it\n\t\t\t// responsive to keyboard input only when it's in focus\n\t\t\tthis.$slider.on( 'focus.' + NS, function() {\n\t\t\t\thasFocus = true;\n\t\t\t});\n\n\t\t\tthis.$slider.on( 'blur.' + NS, function() {\n\t\t\t\thasFocus = false;\n\t\t\t});\n\n\t\t\t$( document ).on( 'keydown.' + this.uniqueId + '.' + NS, function( event ) {\n\t\t\t\tif ( that.settings.keyboardOnlyOnFocus === true && hasFocus === false ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If the left arrow key is pressed, go to the previous slide.\n\t\t\t\t// If the right arrow key is pressed, go to the next slide.\n\t\t\t\t// If the Enter key is pressed, open the link attached to the main slide image.\n\t\t\t\tif ( event.which === 37 ) {\n\t\t\t\t\tthat.previousSlide();\n\t\t\t\t} else if ( event.which === 39 ) {\n\t\t\t\t\tthat.nextSlide();\n\t\t\t\t} else if ( event.which === 13 ) {\n\t\t\t\t\tvar link = that.$slider.find( '.sp-slide' ).eq( that.selectedSlideIndex ).find( '.sp-image-container a' );\n\t\t\t\t\t\n\t\t\t\t\tif ( link.length !== 0 ) {\n\t\t\t\t\t\tlink[0].click();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyKeyboard: function() {\n\t\t\tthis.$slider.off( 'focus.' + NS );\n\t\t\tthis.$slider.off( 'blur.' + NS );\n\t\t\t$( document ).off( 'keydown.' + this.uniqueId + '.' + NS );\n\t\t},\n\n\t\tkeyboardDefaults: {\n\n\t\t\t// Indicates whether keyboard navigation will be enabled\n\t\t\tkeyboard: true,\n\n\t\t\t// Indicates whether the slider will respond to keyboard input only when\n\t\t\t// the slider is in focus.\n\t\t\tkeyboardOnlyOnFocus: false\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Keyboard', Keyboard );\n\t\n})( window, jQuery );\n\n// Full Screen module for Slider Pro.\n// \n// Adds the possibility to open the slider full-screen, using the HTML5 FullScreen API.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\tvar NS = 'FullScreen.' + $.SliderPro.namespace;\n\n\tvar FullScreen = {\n\n\t\t// Indicates whether the slider is currently in full-screen mode\n\t\tisFullScreen: false,\n\n\t\t// Reference to the full-screen button\n\t\t$fullScreenButton: null,\n\n\t\t// Reference to a set of settings that influence the slider's size\n\t\t// before it goes full-screen\n\t\tsizeBeforeFullScreen: {},\n\n\t\tinitFullScreen: function() {\n\t\t\tif ( ! ( document.fullscreenEnabled ||\n\t\t\t\tdocument.webkitFullscreenEnabled ||\n\t\t\t\tdocument.mozFullScreenEnabled ||\n\t\t\t\tdocument.msFullscreenEnabled ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._fullScreenOnUpdate, this ) );\n\t\t},\n\n\t\t// Create or remove the full-screen button depending on the value of the 'fullScreen' option\n\t\t_fullScreenOnUpdate: function() {\n\t\t\tif ( this.settings.fullScreen === true && this.$fullScreenButton === null ) {\n\t\t\t\tthis._addFullScreen();\n\t\t\t} else if ( this.settings.fullScreen === false && this.$fullScreenButton !== null ) {\n\t\t\t\tthis._removeFullScreen();\n\t\t\t}\n\n\t\t\tif ( this.settings.fullScreen === true ) {\n\t\t\t\tif ( this.settings.fadeFullScreen === true ) {\n\t\t\t\t\tthis.$fullScreenButton.addClass( 'sp-fade-full-screen' );\n\t\t\t\t} else if ( this.settings.fadeFullScreen === false ) {\n\t\t\t\t\tthis.$fullScreenButton.removeClass( 'sp-fade-full-screen' );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Create the full-screen button\n\t\t_addFullScreen: function() {\n\t\t\tthis.$fullScreenButton = $('<div class=\"sp-full-screen-button\"></div>').appendTo( this.$slider );\n\t\t\tthis.$fullScreenButton.on( 'click.' + NS, $.proxy( this._onFullScreenButtonClick, this ) );\n\n\t\t\tdocument.addEventListener( 'fullscreenchange', $.proxy( this._onFullScreenChange, this ) );\n\t\t\tdocument.addEventListener( 'mozfullscreenchange', $.proxy( this._onFullScreenChange, this ) );\n\t\t\tdocument.addEventListener( 'webkitfullscreenchange', $.proxy( this._onFullScreenChange, this ) );\n\t\t\tdocument.addEventListener( 'MSFullscreenChange', $.proxy( this._onFullScreenChange, this ) );\n\t\t},\n\n\t\t// Remove the full-screen button\n\t\t_removeFullScreen: function() {\n\t\t\tif ( this.$fullScreenButton !== null ) {\n\t\t\t\tthis.$fullScreenButton.off( 'click.' + NS );\n\t\t\t\tthis.$fullScreenButton.remove();\n\t\t\t\tthis.$fullScreenButton = null;\n\t\t\t\tdocument.removeEventListener( 'fullscreenchange', this._onFullScreenChange );\n\t\t\t\tdocument.removeEventListener( 'mozfullscreenchange', this._onFullScreenChange );\n\t\t\t\tdocument.removeEventListener( 'webkitfullscreenchange', this._onFullScreenChange );\n\t\t\t\tdocument.removeEventListener( 'MSFullscreenChange', this._onFullScreenChange );\n\t\t\t}\n\t\t},\n\n\t\t// When the full-screen button is clicked, put the slider into full-screen mode, and\n\t\t// take it out of the full-screen mode when it's clicked again.\n\t\t_onFullScreenButtonClick: function() {\n\t\t\tif ( this.isFullScreen === false ) {\n\t\t\t\tif ( this.instance.requestFullScreen ) {\n\t\t\t\t\tthis.instance.requestFullScreen();\n\t\t\t\t} else if ( this.instance.mozRequestFullScreen ) {\n\t\t\t\t\tthis.instance.mozRequestFullScreen();\n\t\t\t\t} else if ( this.instance.webkitRequestFullScreen ) {\n\t\t\t\t\tthis.instance.webkitRequestFullScreen();\n\t\t\t\t} else if ( this.instance.msRequestFullscreen ) {\n\t\t\t\t\tthis.instance.msRequestFullscreen();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( document.exitFullScreen ) {\n\t\t\t\t\tdocument.exitFullScreen();\n\t\t\t\t} else if ( document.mozCancelFullScreen ) {\n\t\t\t\t\tdocument.mozCancelFullScreen();\n\t\t\t\t} else if ( document.webkitCancelFullScreen ) {\n\t\t\t\t\tdocument.webkitCancelFullScreen();\n\t\t\t\t} else if ( document.msExitFullscreen ) {\n\t\t\t\t\tdocument.msExitFullscreen();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// This will be called whenever the full-screen mode changes.\n\t\t// If the slider is in full-screen mode, set it to 'full window', and if it's\n\t\t// not in full-screen mode anymore, set it back to the original size.\n\t\t_onFullScreenChange: function() {\n\t\t\tthis.isFullScreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement ? true : false;\n\n\t\t\tif ( this.isFullScreen === true ) {\n\t\t\t\tthis.sizeBeforeFullScreen = { forceSize: this.settings.forceSize, autoHeight: this.settings.autoHeight };\n\t\t\t\tthis.$slider.addClass( 'sp-full-screen' );\n\t\t\t\tthis.settings.forceSize = 'fullWindow';\n\t\t\t\tthis.settings.autoHeight = false;\n\t\t\t} else {\n\t\t\t\tthis.$slider.css( 'margin', '' );\n\t\t\t\tthis.$slider.removeClass( 'sp-full-screen' );\n\t\t\t\tthis.settings.forceSize = this.sizeBeforeFullScreen.forceSize;\n\t\t\t\tthis.settings.autoHeight = this.sizeBeforeFullScreen.autoHeight;\n\t\t\t}\n\n\t\t\tthis.resize();\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyFullScreen: function() {\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis._removeFullScreen();\n\t\t},\n\n\t\tfullScreenDefaults: {\n\n\t\t\t// Indicates whether the full-screen button is enabled\n\t\t\tfullScreen: false,\n\n\t\t\t// Indicates whether the button will fade in only on hover\n\t\t\tfadeFullScreen: true\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'FullScreen', FullScreen );\n\n})( window, jQuery );\n\n// Buttons module for Slider Pro.\n// \n// Adds navigation buttons at the bottom of the slider.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\t\n\tvar NS = 'Buttons.' + $.SliderPro.namespace;\n\n\tvar Buttons = {\n\n\t\t// Reference to the buttons container\n\t\t$buttons: null,\n\n\t\tinitButtons: function() {\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._buttonsOnUpdate, this ) );\n\t\t},\n\n\t\t_buttonsOnUpdate: function() {\n\t\t\tthis.$buttons = this.$slider.find('.sp-buttons');\n\t\t\t\n\t\t\t// If there is more that one slide but the buttons weren't created yet, create the buttons.\n\t\t\t// If the buttons were created but their number differs from the total number of slides, re-create the buttons.\n\t\t\t// If the buttons were created but there are less than one slide, remove the buttons.s\n\t\t\tif ( this.settings.buttons === true && this.getTotalSlides() > 1 && this.$buttons.length === 0 ) {\n\t\t\t\tthis._createButtons();\n\t\t\t} else if ( this.settings.buttons === true && this.getTotalSlides() !== this.$buttons.find( '.sp-button' ).length && this.$buttons.length !== 0 ) {\n\t\t\t\tthis._adjustButtons();\n\t\t\t} else if ( this.settings.buttons === false || ( this.getTotalSlides() <= 1 && this.$buttons.length !== 0 ) ) {\n\t\t\t\tthis._removeButtons();\n\t\t\t}\n\t\t},\n\n\t\t// Create the buttons\n\t\t_createButtons: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Create the buttons' container\n\t\t\tthis.$buttons = $( '<div class=\"sp-buttons\"></div>' ).appendTo( this.$slider );\n\n\t\t\t// Create the buttons\n\t\t\tfor ( var i = 0; i < this.getTotalSlides(); i++ ) {\n\t\t\t\t$( '<div class=\"sp-button\"></div>' ).appendTo( this.$buttons );\n\t\t\t}\n\n\t\t\t// Listen for button clicks \n\t\t\tthis.$buttons.on( 'click.' + NS, '.sp-button', function() {\n\t\t\t\tthat.gotoSlide( $( this ).index() );\n\t\t\t});\n\n\t\t\t// Set the initially selected button\n\t\t\tthis.$buttons.find( '.sp-button' ).eq( this.selectedSlideIndex ).addClass( 'sp-selected-button' );\n\n\t\t\t// Select the corresponding button when the slide changes\n\t\t\tthis.on( 'gotoSlide.' + NS, function( event ) {\n\t\t\t\tthat.$buttons.find( '.sp-selected-button' ).removeClass( 'sp-selected-button' );\n\t\t\t\tthat.$buttons.find( '.sp-button' ).eq( event.index ).addClass( 'sp-selected-button' );\n\t\t\t});\n\n\t\t\t// Indicate that the slider has buttons \n\t\t\tthis.$slider.addClass( 'sp-has-buttons' );\n\t\t},\n\n\t\t// Re-create the buttons. This is calles when the number of slides changes.\n\t\t_adjustButtons: function() {\n\t\t\tthis.$buttons.empty();\n\n\t\t\t// Create the buttons\n\t\t\tfor ( var i = 0; i < this.getTotalSlides(); i++ ) {\n\t\t\t\t$( '<div class=\"sp-button\"></div>' ).appendTo( this.$buttons );\n\t\t\t}\n\n\t\t\t// Change the selected the buttons\n\t\t\tthis.$buttons.find( '.sp-selected-button' ).removeClass( 'sp-selected-button' );\n\t\t\tthis.$buttons.find( '.sp-button' ).eq( this.selectedSlideIndex ).addClass( 'sp-selected-button' );\n\t\t},\n\n\t\t// Remove the buttons\n\t\t_removeButtons: function() {\n\t\t\tthis.$buttons.off( 'click.' + NS, '.sp-button' );\n\t\t\tthis.off( 'gotoSlide.' + NS );\n\t\t\tthis.$buttons.remove();\n\t\t\tthis.$slider.removeClass( 'sp-has-buttons' );\n\t\t},\n\n\t\tdestroyButtons: function() {\n\t\t\tthis._removeButtons();\n\t\t\tthis.off( 'update.' + NS );\n\t\t},\n\n\t\tbuttonsDefaults: {\n\t\t\t\n\t\t\t// Indicates whether the buttons will be created\n\t\t\tbuttons: true\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Buttons', Buttons );\n\n})( window, jQuery );\n\n// Arrows module for Slider Pro.\n// \n// Adds arrows for navigating to the next or previous slide.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\tvar NS = 'Arrows.' + $.SliderPro.namespace;\n\n\tvar Arrows = {\n\n\t\t// Reference to the arrows container\n\t\t$arrows: null,\n\n\t\t// Reference to the previous arrow\n\t\t$previousArrow: null,\n\n\t\t// Reference to the next arrow\n\t\t$nextArrow: null,\n\n\t\tinitArrows: function() {\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._arrowsOnUpdate, this ) );\n\t\t\tthis.on( 'gotoSlide.' + NS, $.proxy( this._checkArrowsVisibility, this ) );\n\t\t},\n\n\t\t_arrowsOnUpdate: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Create the arrows if the 'arrows' option is set to true\n\t\t\tif ( this.settings.arrows === true && this.$arrows === null ) {\n\t\t\t\tthis.$arrows = $( '<div class=\"sp-arrows\"></div>' ).appendTo( this.$slidesContainer );\n\t\t\t\t\n\t\t\t\tthis.$previousArrow = $( '<div class=\"sp-arrow sp-previous-arrow\"></div>' ).appendTo( this.$arrows );\n\t\t\t\tthis.$nextArrow = $( '<div class=\"sp-arrow sp-next-arrow\"></div>' ).appendTo( this.$arrows );\n\n\t\t\t\tthis.$previousArrow.on( 'click.' + NS, function() {\n\t\t\t\t\tthat.previousSlide();\n\t\t\t\t});\n\n\t\t\t\tthis.$nextArrow.on( 'click.' + NS, function() {\n\t\t\t\t\tthat.nextSlide();\n\t\t\t\t});\n\n\t\t\t\tthis._checkArrowsVisibility();\n\t\t\t} else if ( this.settings.arrows === false && this.$arrows !== null ) {\n\t\t\t\tthis._removeArrows();\n\t\t\t}\n\n\t\t\tif ( this.settings.arrows === true ) {\n\t\t\t\tif ( this.settings.fadeArrows === true ) {\n\t\t\t\t\tthis.$arrows.addClass( 'sp-fade-arrows' );\n\t\t\t\t} else if ( this.settings.fadeArrows === false ) {\n\t\t\t\t\tthis.$arrows.removeClass( 'sp-fade-arrows' );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Show or hide the arrows depending on the position of the selected slide\n\t\t_checkArrowsVisibility: function() {\n\t\t\tif ( this.settings.arrows === false || this.settings.loop === true ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( this.selectedSlideIndex === 0 ) {\n\t\t\t\tthis.$previousArrow.css( 'display', 'none' );\n\t\t\t} else {\n\t\t\t\tthis.$previousArrow.css( 'display', 'block' );\n\t\t\t}\n\n\t\t\tif ( this.selectedSlideIndex === this.getTotalSlides() - 1 ) {\n\t\t\t\tthis.$nextArrow.css( 'display', 'none' );\n\t\t\t} else {\n\t\t\t\tthis.$nextArrow.css( 'display', 'block' );\n\t\t\t}\n\t\t},\n\t\t\n\t\t_removeArrows: function() {\n\t\t\tif ( this.$arrows !== null ) {\n\t\t\t\tthis.$previousArrow.off( 'click.' + NS );\n\t\t\t\tthis.$nextArrow.off( 'click.' + NS );\n\t\t\t\tthis.$arrows.remove();\n\t\t\t\tthis.$arrows = null;\n\t\t\t}\n\t\t},\n\n\t\tdestroyArrows: function() {\n\t\t\tthis._removeArrows();\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis.off( 'gotoSlide.' + NS );\n\t\t},\n\n\t\tarrowsDefaults: {\n\n\t\t\t// Indicates whether the arrow buttons will be created\n\t\t\tarrows: false,\n\n\t\t\t// Indicates whether the arrows will fade in only on hover\n\t\t\tfadeArrows: true\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Arrows', Arrows );\n\n})( window, jQuery );\n\n// Thumbnail Touch Swipe module for Slider Pro.\n// \n// Adds touch-swipe functionality for thumbnails.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\t\n\tvar NS = 'ThumbnailTouchSwipe.' + $.SliderPro.namespace;\n\n\tvar ThumbnailTouchSwipe = {\n\n\t\t// The x and y coordinates of the pointer/finger's starting position\n\t\tthumbnailTouchStartPoint: { x: 0, y: 0 },\n\n\t\t// The x and y coordinates of the pointer/finger's end position\n\t\tthumbnailTouchEndPoint: { x: 0, y: 0 },\n\n\t\t// The distance from the starting to the end position on the x and y axis\n\t\tthumbnailTouchDistance: { x: 0, y: 0 },\n\n\t\t// The position of the thumbnail scroller when the touch swipe starts\n\t\tthumbnailTouchStartPosition: 0,\n\n\t\t// Indicates if the thumbnail scroller is being swiped\n\t\tisThumbnailTouchMoving: false,\n\n\t\t// Indicates if the touch swipe was initialized\n\t\tisThumbnailTouchSwipe: false,\n\n\t\t// Stores the names of the events\n\t\tthumbnailTouchSwipeEvents: { startEvent: '', moveEvent: '', endEvent: '' },\n\n\t\t// Indicates whether the previous 'start' event was a 'touchstart' or 'mousedown'\n\t\tthumbnailPreviousStartEvent: '',\n\n\t\tinitThumbnailTouchSwipe: function() {\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._thumbnailTouchSwipeOnUpdate, this ) );\n\t\t},\n\n\t\t_thumbnailTouchSwipeOnUpdate: function() {\n\n\t\t\t// Return if there are no thumbnails\n\t\t\tif ( this.isThumbnailScroller === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Initialize the touch swipe functionality if it wasn't initialized yet\n\t\t\tif ( this.settings.thumbnailTouchSwipe === true && this.isThumbnailTouchSwipe === false ) {\n\t\t\t\tthis.isThumbnailTouchSwipe = true;\n\n\t\t\t\tthis.thumbnailTouchSwipeEvents.startEvent = 'touchstart' + '.' + NS + ' mousedown' + '.' + NS;\n\t\t\t\tthis.thumbnailTouchSwipeEvents.moveEvent = 'touchmove' + '.' + NS + ' mousemove' + '.' + NS;\n\t\t\t\tthis.thumbnailTouchSwipeEvents.endEvent = 'touchend' + '.' + this.uniqueId + '.' + NS + ' mouseup' + '.' + this.uniqueId + '.' + NS;\n\t\t\t\t\n\t\t\t\t// Listen for touch swipe/mouse move events\n\t\t\t\tthis.$thumbnails.on( this.thumbnailTouchSwipeEvents.startEvent, $.proxy( this._onThumbnailTouchStart, this ) );\n\t\t\t\tthis.$thumbnails.on( 'dragstart.' + NS, function( event ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t});\n\t\t\t\n\t\t\t\t// Add the grabbing icon\n\t\t\t\tthis.$thumbnails.addClass( 'sp-grab' );\n\t\t\t}\n\n\t\t\t// Remove the default thumbnailClick\n\t\t\t$.each( this.thumbnails, function( index, thumbnail ) {\n\t\t\t\tthumbnail.off( 'thumbnailClick' );\n\t\t\t});\n\t\t},\n\n\t\t// Called when the thumbnail scroller starts being dragged\n\t\t_onThumbnailTouchStart: function( event ) {\n\n\t\t\t// Return if a 'mousedown' event follows a 'touchstart' event\n\t\t\tif ( event.type === 'mousedown' && this.thumbnailPreviousStartEvent === 'touchstart' ) {\n\t\t\t\tthis.thumbnailPreviousStartEvent = event.type;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Assign the new 'start' event\n\t\t\tthis.thumbnailPreviousStartEvent = event.type;\n\n\t\t\t// Disable dragging if the element is set to allow selections\n\t\t\tif ( $( event.target ).closest( '.sp-selectable' ).length >= 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar that = this,\n\t\t\t\teventObject = typeof event.originalEvent.touches !== 'undefined' ? event.originalEvent.touches[0] : event.originalEvent;\n\n\t\t\t// Prevent default behavior for mouse events\n\t\t\tif ( typeof event.originalEvent.touches === 'undefined' ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\n\t\t\t// Disable click events on links\n\t\t\t$( event.target ).parents( '.sp-thumbnail-container' ).find( 'a' ).one( 'click.' + NS, function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\n\t\t\t// Get the initial position of the mouse pointer and the initial position\n\t\t\t// of the thumbnail scroller\n\t\t\tthis.thumbnailTouchStartPoint.x = eventObject.pageX || eventObject.clientX;\n\t\t\tthis.thumbnailTouchStartPoint.y = eventObject.pageY || eventObject.clientY;\n\t\t\tthis.thumbnailTouchStartPosition = this.thumbnailsPosition;\n\n\t\t\t// Clear the previous distance values\n\t\t\tthis.thumbnailTouchDistance.x = this.thumbnailTouchDistance.y = 0;\n\n\t\t\t// If the thumbnail scroller is being grabbed while it's still animating, stop the\n\t\t\t// current movement\n\t\t\tif ( this.$thumbnails.hasClass( 'sp-animated' ) ) {\n\t\t\t\tthis.isThumbnailTouchMoving = true;\n\t\t\t\tthis._stopThumbnailsMovement();\n\t\t\t\tthis.thumbnailTouchStartPosition = this.thumbnailsPosition;\n\t\t\t}\n\n\t\t\t// Listen for move and end events\n\t\t\tthis.$thumbnails.on( this.thumbnailTouchSwipeEvents.moveEvent, $.proxy( this._onThumbnailTouchMove, this ) );\n\t\t\t$( document ).on( this.thumbnailTouchSwipeEvents.endEvent, $.proxy( this._onThumbnailTouchEnd, this ) );\n\n\t\t\t// Swap grabbing icons\n\t\t\tthis.$thumbnails.removeClass( 'sp-grab' ).addClass( 'sp-grabbing' );\n\n\t\t\t// Add 'sp-swiping' class to indicate that the thumbnail scroller is being swiped\n\t\t\tthis.$thumbnailsContainer.addClass( 'sp-swiping' );\n\t\t},\n\n\t\t// Called during the thumbnail scroller's dragging\n\t\t_onThumbnailTouchMove: function( event ) {\n\t\t\tvar eventObject = typeof event.originalEvent.touches !== 'undefined' ? event.originalEvent.touches[0] : event.originalEvent;\n\n\t\t\t// Indicate that the move event is being fired\n\t\t\tthis.isThumbnailTouchMoving = true;\n\n\t\t\t// Get the current position of the mouse pointer\n\t\t\tthis.thumbnailTouchEndPoint.x = eventObject.pageX || eventObject.clientX;\n\t\t\tthis.thumbnailTouchEndPoint.y = eventObject.pageY || eventObject.clientY;\n\n\t\t\t// Calculate the distance of the movement on both axis\n\t\t\tthis.thumbnailTouchDistance.x = this.thumbnailTouchEndPoint.x - this.thumbnailTouchStartPoint.x;\n\t\t\tthis.thumbnailTouchDistance.y = this.thumbnailTouchEndPoint.y - this.thumbnailTouchStartPoint.y;\n\t\t\t\n\t\t\t// Calculate the distance of the swipe that takes place in the same direction as the orientation of the thumbnails\n\t\t\t// and calculate the distance from the opposite direction.\n\t\t\t// \n\t\t\t// For a swipe to be valid there should more distance in the same direction as the orientation of the thumbnails.\n\t\t\tvar distance = this.thumbnailsOrientation === 'horizontal' ? this.thumbnailTouchDistance.x : this.thumbnailTouchDistance.y,\n\t\t\t\toppositeDistance = this.thumbnailsOrientation === 'horizontal' ? this.thumbnailTouchDistance.y : this.thumbnailTouchDistance.x;\n\n\t\t\t// If the movement is in the same direction as the orientation of the thumbnails, the swipe is valid\n\t\t\tif ( Math.abs( distance ) > Math.abs( oppositeDistance ) ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make the thumbnail scroller move slower if it's dragged outside its bounds\n\t\t\tif ( this.thumbnailsPosition >= 0 ) {\n\t\t\t\tvar infOffset = - this.thumbnailTouchStartPosition;\n\t\t\t\tdistance = infOffset + ( distance - infOffset ) * 0.2;\n\t\t\t} else if ( this.thumbnailsPosition <= - this.thumbnailsSize + this.thumbnailsContainerSize ) {\n\t\t\t\tvar supOffset = this.thumbnailsSize - this.thumbnailsContainerSize + this.thumbnailTouchStartPosition;\n\t\t\t\tdistance = - supOffset + ( distance + supOffset ) * 0.2;\n\t\t\t}\n\t\t\t\n\t\t\tthis._moveThumbnailsTo( this.thumbnailTouchStartPosition + distance, true );\n\t\t},\n\n\t\t// Called when the thumbnail scroller is released\n\t\t_onThumbnailTouchEnd: function( event ) {\n\t\t\tvar that = this,\n\t\t\t\tthumbnailTouchDistance = this.thumbnailsOrientation === 'horizontal' ? this.thumbnailTouchDistance.x : this.thumbnailTouchDistance.y;\n\n\t\t\t// Remove the move and end listeners\n\t\t\tthis.$thumbnails.off( this.thumbnailTouchSwipeEvents.moveEvent );\n\t\t\t$( document ).off( this.thumbnailTouchSwipeEvents.endEvent );\n\n\t\t\t// Swap grabbing icons\n\t\t\tthis.$thumbnails.removeClass( 'sp-grabbing' ).addClass( 'sp-grab' );\n\n\t\t\t// Check if there is intention for a tap/click\n\t\t\tif ( this.isThumbnailTouchMoving === false ||\n\t\t\t\tthis.isThumbnailTouchMoving === true &&\n\t\t\t\tMath.abs( this.thumbnailTouchDistance.x ) < 10 &&\n\t\t\t\tMath.abs( this.thumbnailTouchDistance.y ) < 10\n\t\t\t) {\n\t\t\t\tvar targetThumbnail = $( event.target ).hasClass( 'sp-thumbnail-container' ) ? $( event.target ) : $( event.target ).parents( '.sp-thumbnail-container' ),\n\t\t\t\t\tindex = targetThumbnail.index();\n\n\t\t\t\t// If a link is cliked, navigate to that link, else navigate to the slide that corresponds to the thumbnail\n\t\t\t\tif ( $( event.target ).parents( 'a' ).length !== 0 ) {\n\t\t\t\t\t$( event.target ).parents( 'a' ).off( 'click.' + NS );\n\t\t\t\t\tthis.$thumbnailsContainer.removeClass( 'sp-swiping' );\n\t\t\t\t} else if ( index !== this.selectedThumbnailIndex && index !== -1 ) {\n\t\t\t\t\tthis.gotoSlide( index );\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.isThumbnailTouchMoving = false;\n\n\t\t\t$( event.target ).parents( '.sp-thumbnail' ).one( 'click', function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\n\t\t\t// Remove the 'sp-swiping' class but with a delay\n\t\t\t// because there might be other event listeners that check\n\t\t\t// the existence of this class, and this class should still be \n\t\t\t// applied for those listeners, since there was a swipe event\n\t\t\tsetTimeout(function() {\n\t\t\t\tthat.$thumbnailsContainer.removeClass( 'sp-swiping' );\n\t\t\t}, 1 );\n\n\t\t\t// Keep the thumbnail scroller inside the bounds\n\t\t\tif ( this.thumbnailsPosition > 0 ) {\n\t\t\t\tthis._moveThumbnailsTo( 0 );\n\t\t\t} else if ( this.thumbnailsPosition < this.thumbnailsContainerSize - this.thumbnailsSize ) {\n\t\t\t\tthis._moveThumbnailsTo( this.thumbnailsContainerSize - this.thumbnailsSize );\n\t\t\t}\n\n\t\t\t// Fire the 'thumbnailsMoveComplete' event\n\t\t\tthis.trigger({ type: 'thumbnailsMoveComplete' });\n\t\t\tif ( $.isFunction( this.settings.thumbnailsMoveComplete ) ) {\n\t\t\t\tthis.settings.thumbnailsMoveComplete.call( this, { type: 'thumbnailsMoveComplete' });\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyThumbnailTouchSwipe: function() {\n\t\t\tthis.off( 'update.' + NS );\n\n\t\t\tif ( this.isThumbnailScroller === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.$thumbnails.off( this.thumbnailTouchSwipeEvents.startEvent );\n\t\t\tthis.$thumbnails.off( this.thumbnailTouchSwipeEvents.moveEvent );\n\t\t\tthis.$thumbnails.off( 'dragstart.' + NS );\n\t\t\t$( document ).off( this.thumbnailTouchSwipeEvents.endEvent );\n\t\t\tthis.$thumbnails.removeClass( 'sp-grab' );\n\t\t},\n\n\t\tthumbnailTouchSwipeDefaults: {\n\n\t\t\t// Indicates whether the touch swipe will be enabled for thumbnails\n\t\t\tthumbnailTouchSwipe: true\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'ThumbnailTouchSwipe', ThumbnailTouchSwipe );\n\n})( window, jQuery );\n\n// Thumbnail Arrows module for Slider Pro.\n// \n// Adds thumbnail arrows for moving the thumbnail scroller.\n;(function( window, $ ) {\n\n\t\"use strict\";\n\t\n\tvar NS = 'ThumbnailArrows.' + $.SliderPro.namespace;\n\n\tvar ThumbnailArrows = {\n\n\t\t// Reference to the arrows container\n\t\t$thumbnailArrows: null,\n\n\t\t// Reference to the 'previous' thumbnail arrow\n\t\t$previousThumbnailArrow: null,\n\n\t\t// Reference to the 'next' thumbnail arrow\n\t\t$nextThumbnailArrow: null,\n\n\t\tinitThumbnailArrows: function() {\n\t\t\tvar that = this;\n\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._thumbnailArrowsOnUpdate, this ) );\n\t\t\t\n\t\t\t// Check if the arrows need to be visible or invisible when the thumbnail scroller\n\t\t\t// resizes and when the thumbnail scroller moves.\n\t\t\tthis.on( 'sliderResize.' + NS + ' ' + 'thumbnailsMoveComplete.' + NS, function() {\n\t\t\t\tif ( that.isThumbnailScroller === true && that.settings.thumbnailArrows === true ) {\n\t\t\t\t\tthat._checkThumbnailArrowsVisibility();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t// Called when the slider is updated\n\t\t_thumbnailArrowsOnUpdate: function() {\n\t\t\tvar that = this;\n\t\t\t\n\t\t\tif ( this.isThumbnailScroller === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Create or remove the thumbnail scroller arrows\n\t\t\tif ( this.settings.thumbnailArrows === true && this.$thumbnailArrows === null ) {\n\t\t\t\tthis.$thumbnailArrows = $( '<div class=\"sp-thumbnail-arrows\"></div>' ).appendTo( this.$thumbnailsContainer );\n\t\t\t\t\n\t\t\t\tthis.$previousThumbnailArrow = $( '<div class=\"sp-thumbnail-arrow sp-previous-thumbnail-arrow\"></div>' ).appendTo( this.$thumbnailArrows );\n\t\t\t\tthis.$nextThumbnailArrow = $( '<div class=\"sp-thumbnail-arrow sp-next-thumbnail-arrow\"></div>' ).appendTo( this.$thumbnailArrows );\n\n\t\t\t\tthis.$previousThumbnailArrow.on( 'click.' + NS, function() {\n\t\t\t\t\tvar previousPosition = Math.min( 0, that.thumbnailsPosition + that.thumbnailsContainerSize );\n\t\t\t\t\tthat._moveThumbnailsTo( previousPosition );\n\t\t\t\t});\n\n\t\t\t\tthis.$nextThumbnailArrow.on( 'click.' + NS, function() {\n\t\t\t\t\tvar nextPosition = Math.max( that.thumbnailsContainerSize - that.thumbnailsSize, that.thumbnailsPosition - that.thumbnailsContainerSize );\n\t\t\t\t\tthat._moveThumbnailsTo( nextPosition );\n\t\t\t\t});\n\t\t\t} else if ( this.settings.thumbnailArrows === false && this.$thumbnailArrows !== null ) {\n\t\t\t\tthis._removeThumbnailArrows();\n\t\t\t}\n\n\t\t\t// Add fading functionality and check if the arrows need to be visible or not\n\t\t\tif ( this.settings.thumbnailArrows === true ) {\n\t\t\t\tif ( this.settings.fadeThumbnailArrows === true ) {\n\t\t\t\t\tthis.$thumbnailArrows.addClass( 'sp-fade-thumbnail-arrows' );\n\t\t\t\t} else if ( this.settings.fadeThumbnailArrows === false ) {\n\t\t\t\t\tthis.$thumbnailArrows.removeClass( 'sp-fade-thumbnail-arrows' );\n\t\t\t\t}\n\n\t\t\t\tthis._checkThumbnailArrowsVisibility();\n\t\t\t}\n\t\t},\n\n\t\t// Checks if the 'next' or 'previous' arrows need to be visible or hidden,\n\t\t// based on the position of the thumbnail scroller\n\t\t_checkThumbnailArrowsVisibility: function() {\n\t\t\tif ( this.thumbnailsPosition === 0 ) {\n\t\t\t\tthis.$previousThumbnailArrow.css( 'display', 'none' );\n\t\t\t} else {\n\t\t\t\tthis.$previousThumbnailArrow.css( 'display', 'block' );\n\t\t\t}\n\n\t\t\tif ( this.thumbnailsPosition === this.thumbnailsContainerSize - this.thumbnailsSize ) {\n\t\t\t\tthis.$nextThumbnailArrow.css( 'display', 'none' );\n\t\t\t} else {\n\t\t\t\tthis.$nextThumbnailArrow.css( 'display', 'block' );\n\t\t\t}\n\t\t},\n\n\t\t// Remove the thumbnail arrows\n\t\t_removeThumbnailArrows: function() {\n\t\t\tif ( this.$thumbnailArrows !== null ) {\n\t\t\t\tthis.$previousThumbnailArrow.off( 'click.' + NS );\n\t\t\t\tthis.$nextThumbnailArrow.off( 'click.' + NS );\n\t\t\t\tthis.$thumbnailArrows.remove();\n\t\t\t\tthis.$thumbnailArrows = null;\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyThumbnailArrows: function() {\n\t\t\tthis._removeThumbnailArrows();\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis.off( 'sliderResize.' + NS );\n\t\t\tthis.off( 'thumbnailsMoveComplete.' + NS );\n\t\t},\n\n\t\tthumbnailArrowsDefaults: {\n\n\t\t\t// Indicates whether the thumbnail arrows will be enabled\n\t\t\tthumbnailArrows: false,\n\n\t\t\t// Indicates whether the thumbnail arrows will be faded\n\t\t\tfadeThumbnailArrows: true\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'ThumbnailArrows', ThumbnailArrows );\n\n})( window, jQuery );\n\n// Video module for Slider Pro\n//\n// Adds automatic control for several video players and providers\n;(function( window, $ ) {\n\n\t\"use strict\";\n\n\tvar NS = 'Video.' + $.SliderPro.namespace;\n\t\n\tvar Video = {\n\n\t\tfirstInit: false,\n\n\t\tinitVideo: function() {\n\t\t\tthis.on( 'update.' + NS, $.proxy( this._videoOnUpdate, this ) );\n\t\t\tthis.on( 'gotoSlide.' + NS, $.proxy( this._videoOnGotoSlide, this ) );\n\t\t\tthis.on( 'gotoSlideComplete.' + NS, $.proxy( this._videoOnGotoSlideComplete, this ) );\n\t\t},\n\n\t\t_videoOnUpdate: function() {\n\t\t\tvar that = this;\n\n\t\t\t// Find all the inline videos and initialize them\n\t\t\tthis.$slider.find( '.sp-video' ).not( 'a, [data-video-init]' ).each(function() {\n\t\t\t\tvar video = $( this );\n\t\t\t\tthat._initVideo( video );\n\t\t\t});\n\n\t\t\t// Find all the lazy-loaded videos and preinitialize them. They will be initialized\n\t\t\t// only when their play button is clicked.\n\t\t\tthis.$slider.find( 'a.sp-video' ).not( '[data-video-preinit]' ).each(function() {\n\t\t\t\tvar video = $( this );\n\t\t\t\tthat._preinitVideo( video );\n\t\t\t});\n\n\t\t\t// call the 'gotoSlideComplete' method in case the first slide contains a video that\n\t\t\t// needs to play automatically\n\t\t\tif ( this.firstInit === false ) {\n\t\t\t\tthis.firstInit = true;\n\t\t\t\tthis._videoOnGotoSlideComplete({ index: this.selectedSlideIndex, previousIndex: -1 });\n\t\t\t}\n\t\t},\n\n\t\t// Initialize the target video\n\t\t_initVideo: function( video ) {\n\t\t\tvar that = this;\n\n\t\t\tvideo.attr( 'data-video-init', true )\n\t\t\t\t.videoController();\n\n\t\t\t// When the video starts playing, pause the autoplay if it's running\n\t\t\tvideo.on( 'videoPlay.' + NS, function() {\n\t\t\t\tif ( that.settings.playVideoAction === 'stopAutoplay' && typeof that.stopAutoplay !== 'undefined' ) {\n\t\t\t\t\tthat.stopAutoplay();\n\t\t\t\t\tthat.settings.autoplay = false;\n\t\t\t\t}\n\n\t\t\t\t// Fire the 'videoPlay' event\n\t\t\t\tvar eventObject = { type: 'videoPlay', video: video };\n\t\t\t\tthat.trigger( eventObject );\n\t\t\t\tif ( $.isFunction( that.settings.videoPlay ) ) {\n\t\t\t\t\tthat.settings.videoPlay.call( that, eventObject );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// When the video is paused, restart the autoplay\n\t\t\tvideo.on( 'videoPause.' + NS, function() {\n\t\t\t\tif ( that.settings.pauseVideoAction === 'startAutoplay' && typeof that.startAutoplay !== 'undefined' ) {\n\t\t\t\t\tthat.stopAutoplay();\n\t\t\t\t\tthat.startAutoplay();\n\t\t\t\t\tthat.settings.autoplay = true;\n\t\t\t\t}\n\n\t\t\t\t// Fire the 'videoPause' event\n\t\t\t\tvar eventObject = { type: 'videoPause', video: video };\n\t\t\t\tthat.trigger( eventObject );\n\t\t\t\tif ( $.isFunction( that.settings.videoPause ) ) {\n\t\t\t\t\tthat.settings.videoPause.call( that, eventObject );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// When the video ends, restart the autoplay (which was paused during the playback), or\n\t\t\t// go to the next slide, or replay the video\n\t\t\tvideo.on( 'videoEnded.' + NS, function() {\n\t\t\t\tif ( that.settings.endVideoAction === 'startAutoplay' && typeof that.startAutoplay !== 'undefined' ) {\n\t\t\t\t\tthat.stopAutoplay();\n\t\t\t\t\tthat.startAutoplay();\n\t\t\t\t\tthat.settings.autoplay = true;\n\t\t\t\t} else if ( that.settings.endVideoAction === 'nextSlide' ) {\n\t\t\t\t\tthat.nextSlide();\n\t\t\t\t} else if ( that.settings.endVideoAction === 'replayVideo' ) {\n\t\t\t\t\tvideo.videoController( 'replay' );\n\t\t\t\t}\n\n\t\t\t\t// Fire the 'videoEnd' event\n\t\t\t\tvar eventObject = { type: 'videoEnd', video: video };\n\t\t\t\tthat.trigger( eventObject );\n\t\t\t\tif ( $.isFunction(that.settings.videoEnd ) ) {\n\t\t\t\t\tthat.settings.videoEnd.call( that, eventObject );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t// Pre-initialize the video. This is for lazy loaded videos.\n\t\t_preinitVideo: function( video ) {\n\t\t\tvar that = this;\n\n\t\t\tvideo.attr( 'data-video-preinit', true );\n\n\t\t\t// When the video poster is clicked, remove the poster and create\n\t\t\t// the inline video\n\t\t\tvideo.on( 'click.' + NS, function( event ) {\n\n\t\t\t\t// If the video is being dragged, don't start the video\n\t\t\t\tif ( that.$slider.hasClass( 'sp-swiping' ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tvar href = video.attr( 'href' ),\n\t\t\t\t\tiframe,\n\t\t\t\t\tprovider,\n\t\t\t\t\tregExp,\n\t\t\t\t\tmatch,\n\t\t\t\t\tid,\n\t\t\t\t\tsrc,\n\t\t\t\t\tvideoAttributes,\n\t\t\t\t\tvideoWidth = video.children( 'img' ).attr( 'width' ) || video.children( 'img' ).width(),\n\t\t\t\t\tvideoHeight = video.children( 'img' ).attr( 'height') || video.children( 'img' ).height();\n\n\t\t\t\t// Check if it's a youtube or vimeo video\n\t\t\t\tif ( href.indexOf( 'youtube' ) !== -1 || href.indexOf( 'youtu.be' ) !== -1 ) {\n\t\t\t\t\tprovider = 'youtube';\n\t\t\t\t} else if ( href.indexOf( 'vimeo' ) !== -1 ) {\n\t\t\t\t\tprovider = 'vimeo';\n\t\t\t\t}\n\n\t\t\t\t// Get the id of the video\n\t\t\t\tregExp = provider === 'youtube' ? /^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|\\&v=)([^#\\&\\?]*).*/ : /http:\\/\\/(www\\.)?vimeo.com\\/(\\d+)/;\n\t\t\t\tmatch = href.match( regExp );\n\t\t\t\tid = match[2];\n\n\t\t\t\t// Get the source of the iframe that will be created\n\t\t\t\tsrc = provider === 'youtube' ? '//www.youtube.com/embed/' + id + '?enablejsapi=1&wmode=opaque' : '//player.vimeo.com/video/'+ id;\n\t\t\t\t\n\t\t\t\t// Get the attributes passed to the video link and then pass them to the iframe's src\n\t\t\t\tvideoAttributes = href.split( '?' )[ 1 ];\n\n\t\t\t\tif ( typeof videoAttributes !== 'undefined' ) {\n\t\t\t\t\tvideoAttributes = videoAttributes.split( '&' );\n\n\t\t\t\t\t$.each( videoAttributes, function( index, value ) {\n\t\t\t\t\t\tif ( value.indexOf( id ) === -1 ) {\n\t\t\t\t\t\t\tsrc += '&' + value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Create the iframe\n\t\t\t\tiframe = $( '<iframe></iframe>' )\n\t\t\t\t\t.attr({\n\t\t\t\t\t\t'src': src,\n\t\t\t\t\t\t'width': videoWidth,\n\t\t\t\t\t\t'height': videoHeight,\n\t\t\t\t\t\t'class': video.attr( 'class' ),\n\t\t\t\t\t\t'frameborder': 0,\n\t\t\t\t\t\t'allowfullscreen': 'allowfullscreen'\n\t\t\t\t\t}).insertBefore( video );\n\n\t\t\t\t// Initialize the video and play it\n\t\t\t\tthat._initVideo( iframe );\n\t\t\t\tiframe.videoController( 'play' );\n\n\t\t\t\t// Hide the video poster\n\t\t\t\tvideo.css( 'display', 'none' );\n\t\t\t});\n\t\t},\n\n\t\t// Called when a new slide is selected\n\t\t_videoOnGotoSlide: function( event ) {\n\n\t\t\t// Get the video from the previous slide\n\t\t\tvar previousVideo = this.$slides.find( '.sp-slide' ).eq( event.previousIndex ).find( '.sp-video[data-video-init]' );\n\n\t\t\t// Handle the video from the previous slide by stopping it, or pausing it,\n\t\t\t// or remove it, depending on the value of the 'leaveVideoAction' option.\n\t\t\tif ( event.previousIndex !== -1 && previousVideo.length !== 0 ) {\n\t\t\t\tif ( this.settings.leaveVideoAction === 'stopVideo' ) {\n\t\t\t\t\tpreviousVideo.videoController( 'stop' );\n\t\t\t\t} else if ( this.settings.leaveVideoAction === 'pauseVideo' ) {\n\t\t\t\t\tpreviousVideo.videoController( 'pause' );\n\t\t\t\t} else if ( this.settings.leaveVideoAction === 'removeVideo'  ) {\n\t\t\t\t\t// If the video was lazy-loaded, remove it and show the poster again. If the video\n\t\t\t\t\t// was not lazy-loaded, but inline, stop the video.\n\t\t\t\t\tif ( previousVideo.siblings( 'a.sp-video' ).length !== 0 ) {\n\t\t\t\t\t\tpreviousVideo.siblings( 'a.sp-video' ).css( 'display', '' );\n\t\t\t\t\t\tpreviousVideo.videoController( 'destroy' );\n\t\t\t\t\t\tpreviousVideo.remove();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpreviousVideo.videoController( 'stop' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Called when a new slide is selected, \n\t\t// after the transition animation is complete.\n\t\t_videoOnGotoSlideComplete: function( event ) {\n\n\t\t\t// Handle the video from the selected slide\n\t\t\tif ( this.settings.reachVideoAction === 'playVideo' && event.index === this.selectedSlideIndex ) {\n\t\t\t\tvar loadedVideo = this.$slides.find( '.sp-slide' ).eq( event.index ).find( '.sp-video[data-video-init]' ),\n\t\t\t\t\tunloadedVideo = this.$slides.find( '.sp-slide' ).eq( event.index ).find( '.sp-video[data-video-preinit]' );\n\n\t\t\t\t// If the video was already initialized, play it. If it's not initialized (because\n\t\t\t\t// it's lazy loaded) initialize it and play it.\n\t\t\t\tif ( loadedVideo.length !== 0 ) {\n\t\t\t\t\tloadedVideo.videoController( 'play' );\n\t\t\t\t} else if ( unloadedVideo.length !== 0 ) {\n\t\t\t\t\tunloadedVideo.trigger( 'click.' + NS );\n\t\t\t\t}\n\n\t\t\t\t// Autoplay is stopped when the video starts playing\n\t\t\t\t// and the video's 'play' event is fired, but on slower connections,\n\t\t\t\t// the video's playing will be delayed and the 'play' event\n\t\t\t\t// will not fire in time to stop the autoplay, so we'll\n\t\t\t\t// stop it here as well.\n\t\t\t\tif ( ( loadedVideo.length !== 0 || unloadedVideo.length !== 0 ) && this.settings.playVideoAction === 'stopAutoplay' && typeof this.stopAutoplay !== 'undefined' ) {\n\t\t\t\t\tthis.stopAutoplay();\n\t\t\t\t\tthis.settings.autoplay = false;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Destroy the module\n\t\tdestroyVideo: function() {\n\t\t\tthis.$slider.find( '.sp-video[ data-video-preinit ]' ).each(function() {\n\t\t\t\tvar video = $( this );\n\t\t\t\tvideo.removeAttr( 'data-video-preinit' );\n\t\t\t\tvideo.off( 'click.' + NS );\n\t\t\t});\n\n\t\t\t// Loop through the all the videos and destroy them\n\t\t\tthis.$slider.find( '.sp-video[ data-video-init ]' ).each(function() {\n\t\t\t\tvar video = $( this );\n\t\t\t\tvideo.removeAttr( 'data-video-init' );\n\t\t\t\tvideo.off( 'Video' );\n\t\t\t\tvideo.videoController( 'destroy' );\n\t\t\t});\n\n\t\t\tthis.off( 'update.' + NS );\n\t\t\tthis.off( 'gotoSlide.' + NS );\n\t\t\tthis.off( 'gotoSlideComplete.' + NS );\n\t\t},\n\n\t\tvideoDefaults: {\n\n\t\t\t// Sets the action that the video will perform when its slide container is selected\n\t\t\t// ( 'playVideo' and 'none' )\n\t\t\treachVideoAction: 'none',\n\n\t\t\t// Sets the action that the video will perform when another slide is selected\n\t\t\t// ( 'stopVideo', 'pauseVideo', 'removeVideo' and 'none' )\n\t\t\tleaveVideoAction: 'pauseVideo',\n\n\t\t\t// Sets the action that the slider will perform when the video starts playing\n\t\t\t// ( 'stopAutoplay' and 'none' )\n\t\t\tplayVideoAction: 'stopAutoplay',\n\n\t\t\t// Sets the action that the slider will perform when the video is paused\n\t\t\t// ( 'startAutoplay' and 'none' )\n\t\t\tpauseVideoAction: 'none',\n\n\t\t\t// Sets the action that the slider will perform when the video ends\n\t\t\t// ( 'startAutoplay', 'nextSlide', 'replayVideo' and 'none' )\n\t\t\tendVideoAction: 'none',\n\n\t\t\t// Called when the video starts playing\n\t\t\tvideoPlay: function() {},\n\n\t\t\t// Called when the video is paused\n\t\t\tvideoPause: function() {},\n\n\t\t\t// Called when the video ends\n\t\t\tvideoEnd: function() {}\n\t\t}\n\t};\n\n\t$.SliderPro.addModule( 'Video', Video );\n\t\n})( window, jQuery );\n\n// Video Controller jQuery plugin\n// Creates a universal controller for multiple video types and providers\n;(function( $ ) {\n\n\t\"use strict\";\n\n// Check if an iOS device is used.\n// This information is important because a video can not be\n// controlled programmatically unless the user has started the video manually.\nvar\tisIOS = window.navigator.userAgent.match( /(iPad|iPhone|iPod)/g ) ? true : false;\n\nvar VideoController = function( instance, options ) {\n\tthis.$video = $( instance );\n\tthis.options = options;\n\tthis.settings = {};\n\tthis.player = null;\n\n\tthis._init();\n};\n\nVideoController.prototype = {\n\n\t_init: function() {\n\t\tthis.settings = $.extend( {}, this.defaults, this.options );\n\n\t\tvar that = this,\n\t\t\tplayers = $.VideoController.players,\n\t\t\tvideoID = this.$video.attr( 'id' );\n\n\t\t// Loop through the available video players\n\t\t// and check if the targeted video element is supported by one of the players.\n\t\t// If a compatible type is found, store the video type.\n\t\tfor ( var name in players ) {\n\t\t\tif ( typeof players[ name ] !== 'undefined' && players[ name ].isType( this.$video ) ) {\n\t\t\t\tthis.player = new players[ name ]( this.$video );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Return if the player could not be instantiated\n\t\tif ( this.player === null ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Add event listeners\n\t\tvar events = [ 'ready', 'start', 'play', 'pause', 'ended' ];\n\t\t\n\t\t$.each( events, function( index, element ) {\n\t\t\tvar event = 'video' + element.charAt( 0 ).toUpperCase() + element.slice( 1 );\n\n\t\t\tthat.player.on( element, function() {\n\t\t\t\tthat.trigger({ type: event, video: videoID });\n\t\t\t\tif ( $.isFunction( that.settings[ event ] ) ) {\n\t\t\t\t\tthat.settings[ event ].call( that, { type: event, video: videoID } );\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\t\n\tplay: function() {\n\t\tif ( isIOS === true && this.player.isStarted() === false || this.player.getState() === 'playing' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.player.play();\n\t},\n\t\n\tstop: function() {\n\t\tif ( isIOS === true && this.player.isStarted() === false || this.player.getState() === 'stopped' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.player.stop();\n\t},\n\t\n\tpause: function() {\n\t\tif ( isIOS === true && this.player.isStarted() === false || this.player.getState() === 'paused' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.player.pause();\n\t},\n\n\treplay: function() {\n\t\tif ( isIOS === true && this.player.isStarted() === false ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthis.player.replay();\n\t},\n\n\ton: function( type, callback ) {\n\t\treturn this.$video.on( type, callback );\n\t},\n\t\n\toff: function( type ) {\n\t\treturn this.$video.off( type );\n\t},\n\n\ttrigger: function( data ) {\n\t\treturn this.$video.triggerHandler( data );\n\t},\n\n\tdestroy: function() {\n\t\tif ( this.player.isStarted() === true ) {\n\t\t\tthis.stop();\n\t\t}\n\n\t\tthis.player.off( 'ready' );\n\t\tthis.player.off( 'start' );\n\t\tthis.player.off( 'play' );\n\t\tthis.player.off( 'pause' );\n\t\tthis.player.off( 'ended' );\n\n\t\tthis.$video.removeData( 'videoController' );\n\t},\n\n\tdefaults: {\n\t\tvideoReady: function() {},\n\t\tvideoStart: function() {},\n\t\tvideoPlay: function() {},\n\t\tvideoPause: function() {},\n\t\tvideoEnded: function() {}\n\t}\n};\n\n$.VideoController = {\n\tplayers: {},\n\n\taddPlayer: function( name, player ) {\n\t\tthis.players[ name ] = player;\n\t}\n};\n\n$.fn.videoController = function( options ) {\n\tvar args = Array.prototype.slice.call( arguments, 1 );\n\n\treturn this.each(function() {\n\t\t// Instantiate the video controller or call a function on the current instance\n\t\tif ( typeof $( this ).data( 'videoController' ) === 'undefined' ) {\n\t\t\tvar newInstance = new VideoController( this, options );\n\n\t\t\t// Store a reference to the instance created\n\t\t\t$( this ).data( 'videoController', newInstance );\n\t\t} else if ( typeof options !== 'undefined' ) {\n\t\t\tvar\tcurrentInstance = $( this ).data( 'videoController' );\n\n\t\t\t// Check the type of argument passed\n\t\t\tif ( typeof currentInstance[ options ] === 'function' ) {\n\t\t\t\tcurrentInstance[ options ].apply( currentInstance, args );\n\t\t\t} else {\n\t\t\t\t$.error( options + ' does not exist in videoController.' );\n\t\t\t}\n\t\t}\n\t});\n};\n\n// Base object for the video players\nvar Video = function( video ) {\n\tthis.$video = video;\n\tthis.player = null;\n\tthis.ready = false;\n\tthis.started = false;\n\tthis.state = '';\n\tthis.events = $({});\n\n\tthis._init();\n};\n\nVideo.prototype = {\n\t_init: function() {},\n\n\tplay: function() {},\n\n\tpause: function() {},\n\n\tstop: function() {},\n\n\treplay: function() {},\n\n\tisType: function() {},\n\n\tisReady: function() {\n\t\treturn this.ready;\n\t},\n\n\tisStarted: function() {\n\t\treturn this.started;\n\t},\n\n\tgetState: function() {\n\t\treturn this.state;\n\t},\n\n\ton: function( type, callback ) {\n\t\treturn this.events.on( type, callback );\n\t},\n\t\n\toff: function( type ) {\n\t\treturn this.events.off( type );\n\t},\n\n\ttrigger: function( data ) {\n\t\treturn this.events.triggerHandler( data );\n\t}\n};\n\n// YouTube video\nvar YoutubeVideoHelper = {\n\tyoutubeAPIAdded: false,\n\tyoutubeVideos: []\n};\n\nvar YoutubeVideo = function( video ) {\n\tthis.init = false;\n\tvar youtubeAPILoaded = window.YT && window.YT.Player;\n\n\tif ( typeof youtubeAPILoaded !== 'undefined' ) {\n\t\tVideo.call( this, video );\n\t} else {\n\t\tYoutubeVideoHelper.youtubeVideos.push({ 'video': video, 'scope': this });\n\t\t\n\t\tif ( YoutubeVideoHelper.youtubeAPIAdded === false ) {\n\t\t\tYoutubeVideoHelper.youtubeAPIAdded = true;\n\n\t\t\tvar tag = document.createElement( 'script' );\n\t\t\ttag.src = \"//www.youtube.com/player_api\";\n\t\t\tvar firstScriptTag = document.getElementsByTagName( 'script' )[0];\n\t\t\tfirstScriptTag.parentNode.insertBefore( tag, firstScriptTag );\n\n\t\t\twindow.onYouTubePlayerAPIReady = function() {\n\t\t\t\t$.each( YoutubeVideoHelper.youtubeVideos, function( index, element ) {\n\t\t\t\t\tVideo.call( element.scope, element.video );\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t}\n};\n\nYoutubeVideo.prototype = new Video();\nYoutubeVideo.prototype.constructor = YoutubeVideo;\n$.VideoController.addPlayer( 'YoutubeVideo', YoutubeVideo );\n\nYoutubeVideo.isType = function( video ) {\n\tif ( video.is( 'iframe' ) ) {\n\t\tvar src = video.attr( 'src' );\n\n\t\tif ( src.indexOf( 'youtube.com' ) !== -1 || src.indexOf( 'youtu.be' ) !== -1 ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nYoutubeVideo.prototype._init = function() {\n\tthis.init = true;\n\tthis._setup();\n};\n\t\nYoutubeVideo.prototype._setup = function() {\n\tvar that = this;\n\n\t// Get a reference to the player\n\tthis.player = new YT.Player( this.$video[0], {\n\t\tevents: {\n\t\t\t'onReady': function() {\n\t\t\t\tthat.trigger({ type: 'ready' });\n\t\t\t\tthat.ready = true;\n\t\t\t},\n\t\t\t\n\t\t\t'onStateChange': function( event ) {\n\t\t\t\tswitch ( event.data ) {\n\t\t\t\t\tcase YT.PlayerState.PLAYING:\n\t\t\t\t\t\tif (that.started === false) {\n\t\t\t\t\t\t\tthat.started = true;\n\t\t\t\t\t\t\tthat.trigger({ type: 'start' });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthat.state = 'playing';\n\t\t\t\t\t\tthat.trigger({ type: 'play' });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase YT.PlayerState.PAUSED:\n\t\t\t\t\t\tthat.state = 'paused';\n\t\t\t\t\t\tthat.trigger({ type: 'pause' });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase YT.PlayerState.ENDED:\n\t\t\t\t\t\tthat.state = 'ended';\n\t\t\t\t\t\tthat.trigger({ type: 'ended' });\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n};\n\nYoutubeVideo.prototype.play = function() {\n\tvar that = this;\n\n\tif ( this.ready === true ) {\n\t\tthis.player.playVideo();\n\t} else {\n\t\tvar timer = setInterval(function() {\n\t\t\tif ( that.ready === true ) {\n\t\t\t\tclearInterval( timer );\n\t\t\t\tthat.player.playVideo();\n\t\t\t}\n\t\t}, 100 );\n\t}\n};\n\nYoutubeVideo.prototype.pause = function() {\n\t// On iOS, simply pausing the video can make other videos unresponsive\n\t// so we stop the video instead.\n\tif ( isIOS === true ) {\n\t\tthis.stop();\n\t} else {\n\t\tthis.player.pauseVideo();\n\t}\n};\n\nYoutubeVideo.prototype.stop = function() {\n\tthis.player.seekTo( 1 );\n\tthis.player.stopVideo();\n\tthis.state = 'stopped';\n};\n\nYoutubeVideo.prototype.replay = function() {\n\tthis.player.seekTo( 1 );\n\tthis.player.playVideo();\n};\n\nYoutubeVideo.prototype.on = function( type, callback ) {\n\tvar that = this;\n\n\tif ( this.init === true ) {\n\t\tVideo.prototype.on.call( this, type, callback );\n\t} else {\n\t\tvar timer = setInterval(function() {\n\t\t\tif ( that.init === true ) {\n\t\t\t\tclearInterval( timer );\n\t\t\t\tVideo.prototype.on.call( that, type, callback );\n\t\t\t}\n\t\t}, 100 );\n\t}\n};\n\n// Vimeo video\nvar VimeoVideoHelper = {\n\tvimeoAPIAdded: false,\n\tvimeoVideos: []\n};\n\nvar VimeoVideo = function( video ) {\n\tthis.init = false;\n\n\tif ( typeof window.Vimeo !== 'undefined' ) {\n\t\tVideo.call( this, video );\n\t} else {\n\t\tVimeoVideoHelper.vimeoVideos.push({ 'video': video, 'scope': this });\n\n\t\tif ( VimeoVideoHelper.vimeoAPIAdded === false ) {\n\t\t\tVimeoVideoHelper.vimeoAPIAdded = true;\n\n\t\t\tvar tag = document.createElement('script');\n\t\t\ttag.src = \"//player.vimeo.com/api/player.js\";\n\t\t\tvar firstScriptTag = document.getElementsByTagName( 'script' )[0];\n\t\t\tfirstScriptTag.parentNode.insertBefore( tag, firstScriptTag );\n\t\t\n\t\t\tvar checkVimeoAPITimer = setInterval(function() {\n\t\t\t\tif ( typeof window.Vimeo !== 'undefined' ) {\n\t\t\t\t\tclearInterval( checkVimeoAPITimer );\n\t\t\t\t\t\n\t\t\t\t\t$.each( VimeoVideoHelper.vimeoVideos, function( index, element ) {\n\t\t\t\t\t\tVideo.call( element.scope, element.video );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, 100 );\n\t\t}\n\t}\n};\n\nVimeoVideo.prototype = new Video();\nVimeoVideo.prototype.constructor = VimeoVideo;\n$.VideoController.addPlayer( 'VimeoVideo', VimeoVideo );\n\nVimeoVideo.isType = function( video ) {\n\tif ( video.is( 'iframe' ) ) {\n\t\tvar src = video.attr('src');\n\n\t\tif ( src.indexOf( 'vimeo.com' ) !== -1 ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nVimeoVideo.prototype._init = function() {\n\tthis.init = true;\n\tthis._setup();\n};\n\nVimeoVideo.prototype._setup = function() {\n\tvar that = this;\n\n\t// Get a reference to the player\n\tthis.player = new Vimeo.Player( this.$video[0] );\n\t\n\tthat.ready = true;\n\tthat.trigger({ type: 'ready' });\n\t\t\n\tthat.player.on( 'play', function() {\n\t\tif ( that.started === false ) {\n\t\t\tthat.started = true;\n\t\t\tthat.trigger({ type: 'start' });\n\t\t}\n\n\t\tthat.state = 'playing';\n\t\tthat.trigger({ type: 'play' });\n\t});\n\t\t\n\tthat.player.on( 'pause', function() {\n\t\tthat.state = 'paused';\n\t\tthat.trigger({ type: 'pause' });\n\t});\n\t\t\n\tthat.player.on( 'ended', function() {\n\t\tthat.state = 'ended';\n\t\tthat.trigger({ type: 'ended' });\n\t});\n};\n\nVimeoVideo.prototype.play = function() {\n\tvar that = this;\n \n    if ( this.ready === true ) {\n        this.player.play();\n    } else {\n        var timer = setInterval(function() {\n            if ( that.ready === true ) {\n                clearInterval( timer );\n                that.player.play();\n            }\n        }, 100 );\n    }\n};\n\nVimeoVideo.prototype.pause = function() {\n\tthis.player.pause();\n};\n\nVimeoVideo.prototype.stop = function() {\n\tvar that = this;\n\n\tthis.player.setCurrentTime( 0 ).then( function() {\n\t\tthat.player.pause();\n\t\tthat.state = 'stopped';\n\t} );\n};\n\nVimeoVideo.prototype.replay = function() {\n\tvar that = this;\n\n\tthis.player.setCurrentTime( 0 ).then( function() {\n\t\tthat.player.play();\n\t} );\n};\n\nVimeoVideo.prototype.on = function( type, callback ) {\n\tvar that = this;\n\n\tif ( this.init === true ) {\n\t\tVideo.prototype.on.call( this, type, callback );\n\t} else {\n\t\tvar timer = setInterval(function() {\n\t\t\tif ( that.init === true ) {\n\t\t\t\tclearInterval( timer );\n\t\t\t\tVideo.prototype.on.call( that, type, callback );\n\t\t\t}\n\t\t}, 100 );\n\t}\n};\n\n// HTML5 video\nvar HTML5Video = function( video ) {\n\tVideo.call( this, video );\n};\n\nHTML5Video.prototype = new Video();\nHTML5Video.prototype.constructor = HTML5Video;\n$.VideoController.addPlayer( 'HTML5Video', HTML5Video );\n\nHTML5Video.isType = function( video ) {\n\tif ( video.is( 'video' ) && video.hasClass( 'video-js' ) === false && video.hasClass( 'sublime' ) === false ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nHTML5Video.prototype._init = function() {\n\tvar that = this;\n\n\t// Get a reference to the player\n\tthis.player = this.$video[0];\n\t\n\tvar checkVideoReady = setInterval(function() {\n\t\tif ( that.player.readyState === 4 ) {\n\t\t\tclearInterval( checkVideoReady );\n\n\t\t\tthat.ready = true;\n\t\t\tthat.trigger({ type: 'ready' });\n\n\t\t\tthat.player.addEventListener( 'play', function() {\n\t\t\t\tif ( that.started === false ) {\n\t\t\t\t\tthat.started = true;\n\t\t\t\t\tthat.trigger({ type: 'start' });\n\t\t\t\t}\n\n\t\t\t\tthat.state = 'playing';\n\t\t\t\tthat.trigger({ type: 'play' });\n\t\t\t});\n\t\t\t\n\t\t\tthat.player.addEventListener( 'pause', function() {\n\t\t\t\tthat.state = 'paused';\n\t\t\t\tthat.trigger({ type: 'pause' });\n\t\t\t});\n\t\t\t\n\t\t\tthat.player.addEventListener( 'ended', function() {\n\t\t\t\tthat.state = 'ended';\n\t\t\t\tthat.trigger({ type: 'ended' });\n\t\t\t});\n\t\t}\n\t}, 100 );\n};\n\nHTML5Video.prototype.play = function() {\n\tvar that = this;\n\n\tif ( this.ready === true ) {\n\t\tthis.player.play();\n\t} else {\n\t\tvar timer = setInterval(function() {\n\t\t\tif ( that.ready === true ) {\n\t\t\t\tclearInterval( timer );\n\t\t\t\tthat.player.play();\n\t\t\t}\n\t\t}, 100 );\n\t}\n};\n\nHTML5Video.prototype.pause = function() {\n\tthis.player.pause();\n};\n\nHTML5Video.prototype.stop = function() {\n\tthis.player.currentTime = 0;\n\tthis.player.pause();\n\tthis.state = 'stopped';\n};\n\nHTML5Video.prototype.replay = function() {\n\tthis.player.currentTime = 0;\n\tthis.player.play();\n};\n\n// VideoJS video\nvar VideoJSVideo = function( video ) {\n\tVideo.call( this, video );\n};\n\nVideoJSVideo.prototype = new Video();\nVideoJSVideo.prototype.constructor = VideoJSVideo;\n$.VideoController.addPlayer( 'VideoJSVideo', VideoJSVideo );\n\nVideoJSVideo.isType = function( video ) {\n\tif ( ( typeof video.attr( 'data-videojs-id' ) !== 'undefined' || video.hasClass( 'video-js' ) ) && typeof videojs !== 'undefined' ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nVideoJSVideo.prototype._init = function() {\n\tvar that = this,\n\t\tvideoID = this.$video.hasClass( 'video-js' ) ? this.$video.attr( 'id' ) : this.$video.attr( 'data-videojs-id' );\n\t\n\tthis.player = videojs( videoID );\n\n\tthis.player.ready(function() {\n\t\tthat.ready = true;\n\t\tthat.trigger({ type: 'ready' });\n\n\t\tthat.player.on( 'play', function() {\n\t\t\tif ( that.started === false ) {\n\t\t\t\tthat.started = true;\n\t\t\t\tthat.trigger({ type: 'start' });\n\t\t\t}\n\n\t\t\tthat.state = 'playing';\n\t\t\tthat.trigger({ type: 'play' });\n\t\t});\n\t\t\n\t\tthat.player.on( 'pause', function() {\n\t\t\tthat.state = 'paused';\n\t\t\tthat.trigger({ type: 'pause' });\n\t\t});\n\t\t\n\t\tthat.player.on( 'ended', function() {\n\t\t\tthat.state = 'ended';\n\t\t\tthat.trigger({ type: 'ended' });\n\t\t});\n\t});\n};\n\nVideoJSVideo.prototype.play = function() {\n\tthis.player.play();\n};\n\nVideoJSVideo.prototype.pause = function() {\n\tthis.player.pause();\n};\n\nVideoJSVideo.prototype.stop = function() {\n\tthis.player.currentTime( 0 );\n\tthis.player.pause();\n\tthis.state = 'stopped';\n};\n\nVideoJSVideo.prototype.replay = function() {\n\tthis.player.currentTime( 0 );\n\tthis.player.play();\n};\n\n// Sublime video\nvar SublimeVideo = function( video ) {\n\tVideo.call( this, video );\n};\n\nSublimeVideo.prototype = new Video();\nSublimeVideo.prototype.constructor = SublimeVideo;\n$.VideoController.addPlayer( 'SublimeVideo', SublimeVideo );\n\nSublimeVideo.isType = function( video ) {\n\tif ( video.hasClass( 'sublime' ) && typeof sublime !== 'undefined' ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nSublimeVideo.prototype._init = function() {\n\tvar that = this;\n\n\tsublime.ready(function() {\n\t\t// Get a reference to the player\n\t\tthat.player = sublime.player( that.$video.attr( 'id' ) );\n\n\t\tthat.ready = true;\n\t\tthat.trigger({ type: 'ready' });\n\n\t\tthat.player.on( 'play', function() {\n\t\t\tif ( that.started === false ) {\n\t\t\t\tthat.started = true;\n\t\t\t\tthat.trigger({ type: 'start' });\n\t\t\t}\n\n\t\t\tthat.state = 'playing';\n\t\t\tthat.trigger({ type: 'play' });\n\t\t});\n\n\t\tthat.player.on( 'pause', function() {\n\t\t\tthat.state = 'paused';\n\t\t\tthat.trigger({ type: 'pause' });\n\t\t});\n\n\t\tthat.player.on( 'stop', function() {\n\t\t\tthat.state = 'stopped';\n\t\t\tthat.trigger({ type: 'stop' });\n\t\t});\n\n\t\tthat.player.on( 'end', function() {\n\t\t\tthat.state = 'ended';\n\t\t\tthat.trigger({ type: 'ended' });\n\t\t});\n\t});\n};\n\nSublimeVideo.prototype.play = function() {\n\tthis.player.play();\n};\n\nSublimeVideo.prototype.pause = function() {\n\tthis.player.pause();\n};\n\nSublimeVideo.prototype.stop = function() {\n\tthis.player.stop();\n};\n\nSublimeVideo.prototype.replay = function() {\n\tthis.player.stop();\n\tthis.player.play();\n};\n\n// JWPlayer video\nvar JWPlayerVideo = function( video ) {\n\tVideo.call( this, video );\n};\n\nJWPlayerVideo.prototype = new Video();\nJWPlayerVideo.prototype.constructor = JWPlayerVideo;\n$.VideoController.addPlayer( 'JWPlayerVideo', JWPlayerVideo );\n\nJWPlayerVideo.isType = function( video ) {\n\tif ( ( typeof video.attr( 'data-jwplayer-id' ) !== 'undefined' || video.hasClass( 'jwplayer' ) || video.find( \"object[data*='jwplayer']\" ).length !== 0 ) &&\n\t\ttypeof jwplayer !== 'undefined') {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nJWPlayerVideo.prototype._init = function() {\n\tvar that = this,\n\t\tvideoID;\n\n\tif ( this.$video.hasClass( 'jwplayer' ) ) {\n\t\tvideoID = this.$video.attr( 'id' );\n\t} else if ( typeof this.$video.attr( 'data-jwplayer-id' ) !== 'undefined' ) {\n\t\tvideoID = this.$video.attr( 'data-jwplayer-id');\n\t} else if ( this.$video.find( \"object[data*='jwplayer']\" ).length !== 0 ) {\n\t\tvideoID = this.$video.find( 'object' ).attr( 'id' );\n\t}\n\n\t// Get a reference to the player\n\tthis.player = jwplayer( videoID );\n\n\tthis.player.onReady(function() {\n\t\tthat.ready = true;\n\t\tthat.trigger({ type: 'ready' });\n\t\n\t\tthat.player.onPlay(function() {\n\t\t\tif ( that.started === false ) {\n\t\t\t\tthat.started = true;\n\t\t\t\tthat.trigger({ type: 'start' });\n\t\t\t}\n\n\t\t\tthat.state = 'playing';\n\t\t\tthat.trigger({ type: 'play' });\n\t\t});\n\n\t\tthat.player.onPause(function() {\n\t\t\tthat.state = 'paused';\n\t\t\tthat.trigger({ type: 'pause' });\n\t\t});\n\t\t\n\t\tthat.player.onComplete(function() {\n\t\t\tthat.state = 'ended';\n\t\t\tthat.trigger({ type: 'ended' });\n\t\t});\n\t});\n};\n\nJWPlayerVideo.prototype.play = function() {\n\tthis.player.play( true );\n};\n\nJWPlayerVideo.prototype.pause = function() {\n\tthis.player.pause( true );\n};\n\nJWPlayerVideo.prototype.stop = function() {\n\tthis.player.stop();\n\tthis.state = 'stopped';\n};\n\nJWPlayerVideo.prototype.replay = function() {\n\tthis.player.seek( 0 );\n\tthis.player.play( true );\n};\n\n})( jQuery );\n","/*!\n * jQuery Magnify Plugin v2.3.3 by T. H. Doan (https://thdoan.github.io/magnify/)\n * Based on http://thecodeplayer.com/walkthrough/magnifying-glass-for-images-using-jquery-and-css3\n *\n * jQuery Magnify by T. H. Doan is licensed under the MIT License.\n * Read a copy of the license in the LICENSE file or at https://choosealicense.com/licenses/mit/\n */\n\n(function($) {\n  $.fn.magnify = function(oOptions) {\n    // Default options\n    oOptions = $.extend({\n      'src': '',\n      'speed': 100,\n      'timeout': -1,\n      'touchBottomOffset': 0,\n      'finalWidth': null,\n      'finalHeight': null,\n      'magnifiedWidth': null,\n      'magnifiedHeight': null,\n      'limitBounds': false,\n      'mobileCloseEvent': 'touchstart',\n      'afterLoad': function(){}\n    }, oOptions);\n\n    var $that = this, // Preserve scope\n      $html = $('html'),\n\n      // Initiate\n      init = function(el) {\n        var $image = $(el),\n          $anchor = $image.closest('a'),\n          oDataAttr = {};\n\n        // Get data attributes\n        for (var i in oOptions) {\n          oDataAttr[i] = $image.attr('data-magnify-' + i.toLowerCase());\n        }\n\n        // Disable zooming if no valid large image source\n        var sZoomSrc = oDataAttr['src'] || oOptions['src'] || $anchor.attr('href') || '';\n        if (!sZoomSrc) return;\n\n        var $container,\n          $lens,\n          nImageWidth,\n          nImageHeight,\n          nMagnifiedWidth,\n          nMagnifiedHeight,\n          nLensWidth,\n          nLensHeight,\n          nBoundX = 0,\n          nBoundY = 0,\n          nPosX, nPosY,     // Absolute cursor position\n          nX, nY,           // Relative cursor position\n          oContainerOffset, // Relative to document\n          oImageOffset,     // Relative to container\n          // Get true offsets\n          getOffset = function() {\n            var o = $container.offset();\n            // Store offsets from container border to image inside\n            // NOTE: .offset() does NOT take into consideration image border and padding.\n            oImageOffset = {\n              'top': ($image.offset().top-o.top) + parseInt($image.css('border-top-width')) + parseInt($image.css('padding-top')),\n              'left': ($image.offset().left-o.left) + parseInt($image.css('border-left-width')) + parseInt($image.css('padding-left'))\n            };\n            o.top += oImageOffset['top'];\n            o.left += oImageOffset['left'];\n            return o;\n          },\n          // Hide the lens\n          hideLens = function() {\n            if ($lens.is(':visible')) $lens.fadeOut(oOptions['speed'], function() {\n              $html.removeClass('magnifying').trigger('magnifyend'); // Reset overflow-x\n            });\n          },\n          moveLens = function(e) {\n            // Reinitialize if image initially hidden\n            if (!nImageHeight) {\n              refresh();\n              return;\n            }\n            if (e) {\n              e.preventDefault();\n              // Save last coordinates in case we need to call this function directly (required when\n              // updating magnifiedWidth/magnifiedHeight while the lens is visible).\n              nPosX = e.pageX || e.originalEvent.touches[0].pageX;\n              nPosY = e.pageY || e.originalEvent.touches[0].pageY;\n              $image.data('lastPos', {\n                'x': nPosX,\n                'y': nPosY\n              });\n            } else {\n              nPosX = $image.data('lastPos').x;\n              nPosY = $image.data('lastPos').y;\n            }\n            // x/y coordinates of the mouse pointer or touch point. This is the position of\n            // .magnify relative to the document.\n            //\n            // We deduct the positions of .magnify from the mouse or touch positions relative to\n            // the document to get the mouse or touch positions relative to the container.\n            nX = nPosX - oContainerOffset['left'],\n            nY = (nPosY - oContainerOffset['top']) - oOptions['touchBottomOffset'];\n            // Toggle magnifying lens\n            if (!$lens.is(':animated')) {\n              if (nX>nBoundX && nX<nImageWidth-nBoundX && nY>nBoundY && nY<nImageHeight-nBoundY) {\n                if ($lens.is(':hidden')) {\n                  $html.addClass('magnifying').trigger('magnifystart'); // Hide overflow-x while zooming\n                  $lens.fadeIn(oOptions['speed']);\n                }\n              } else {\n                hideLens();\n              }\n            }\n            if ($lens.is(':visible')) {\n              // Move the magnifying lens with the mouse\n              var sBgPos = '';\n              if (nMagnifiedWidth && nMagnifiedHeight) {\n                // Change the background position of .magnify-lens according to the position of\n                // the mouse over the .magnify-image image. This allows us to get the ratio of\n                // the pixel under the mouse pointer with respect to the image and use that to\n                // position the large image inside the magnifying lens.\n                var nRatioX = -Math.round(nX/nImageWidth*nMagnifiedWidth-nLensWidth/2),\n                  nRatioY = -Math.round(nY/nImageHeight*nMagnifiedHeight-nLensHeight/2);\n                if (oOptions['limitBounds']) {\n                  // Enforce bounds to ensure only image is visible in lens\n                  var nBoundRight = -Math.round((nImageWidth-nBoundX)/nImageWidth*nMagnifiedWidth-nLensWidth/2),\n                    nBoundBottom = -Math.round((nImageHeight-nBoundY)/nImageHeight*nMagnifiedHeight-nLensHeight/2);\n                  // Left and right edges\n                  if (nRatioX>0) nRatioX = 0;\n                  else if (nRatioX<nBoundRight) nRatioX = nBoundRight;\n                  // Top and bottom edges\n                  if (nRatioY>0) nRatioY = 0;\n                  else if (nRatioY<nBoundBottom) nRatioY = nBoundBottom;\n                }\n                sBgPos = nRatioX + 'px ' + nRatioY + 'px';\n              }\n              // Now the lens moves with the mouse. The logic is to deduct half of the lens's\n              // width and height from the mouse coordinates to place it with its center at the\n              // mouse coordinates. If you hover on the image now, you should see the magnifying\n              // lens in action.\n              $lens.css({\n                'top': Math.round(nY-nLensHeight/2) + oImageOffset['top'] + 'px',\n                'left': Math.round(nX-nLensWidth/2) + oImageOffset['left'] + 'px',\n                'background-position': sBgPos\n              });\n            }\n          };\n\n        // Data attributes have precedence over options object\n        if (!isNaN(+oDataAttr['speed'])) oOptions['speed'] = +oDataAttr['speed'];\n        if (!isNaN(+oDataAttr['timeout'])) oOptions['timeout'] = +oDataAttr['timeout'];\n        if (!isNaN(+oDataAttr['finalWidth'])) oOptions['finalWidth'] = +oDataAttr['finalWidth'];\n        if (!isNaN(+oDataAttr['finalHeight'])) oOptions['finalHeight'] = +oDataAttr['finalHeight'];\n        if (!isNaN(+oDataAttr['magnifiedWidth'])) oOptions['magnifiedWidth'] = +oDataAttr['magnifiedWidth'];\n        if (!isNaN(+oDataAttr['magnifiedHeight'])) oOptions['magnifiedHeight'] = +oDataAttr['magnifiedHeight'];\n        if (oDataAttr['limitBounds']==='true') oOptions['limitBounds'] = true;\n        if (typeof window[oDataAttr['afterLoad']]==='function') oOptions.afterLoad = window[oDataAttr['afterLoad']];\n\n        // Implement touch point bottom offset only on mobile devices\n        if (/\\b(Android|BlackBerry|IEMobile|iPad|iPhone|Mobile|Opera Mini)\\b/.test(navigator.userAgent)) {\n          if (!isNaN(+oDataAttr['touchBottomOffset'])) oOptions['touchBottomOffset'] = +oDataAttr['touchBottomOffset'];\n        } else {\n          oOptions['touchBottomOffset'] = 0;\n        }\n\n        // Save any inline styles for resetting\n        $image.data('originalStyle', $image.attr('style'));\n\n        // Activate magnification:\n        // 1. Try to get large image dimensions\n        // 2. Proceed only if able to get large image dimensions OK\n\n        // [1] Calculate the native (magnified) image dimensions. The zoomed version is only shown\n        // after the native dimensions are available. To get the actual dimensions we have to create\n        // this image object.\n        var elZoomImage = new Image();\n        $(elZoomImage).on({\n          'load': function() {\n            // [2] Got image dimensions OK.\n\n            // Fix overlap bug at the edges during magnification\n            $image.css('display', 'block');\n            // Create container div if necessary\n            if (!$image.parent('.magnify').length) {\n              $image.wrap('<div class=\"magnify\"></div>');\n            }\n            $container = $image.parent('.magnify');\n            // Create the magnifying lens div if necessary\n            if ($image.prev('.magnify-lens').length) {\n              $container.children('.magnify-lens').css('background-image', 'url(\\'' + sZoomSrc + '\\')');\n            } else {\n              $image.before('<div class=\"magnify-lens loading\" style=\"background:url(\\'' + sZoomSrc + '\\') 0 0 no-repeat\"></div>');\n            }\n            $lens = $container.children('.magnify-lens');\n            // Remove the \"Loading...\" text\n            $lens.removeClass('loading');\n            // Cache dimensions and offsets for improved performance\n            // NOTE: This code is inside the load() function, which is important. The width and\n            // height of the object would return 0 if accessed before the image is fully loaded.\n            nImageWidth = oOptions['finalWidth'] || $image.width();\n            nImageHeight = oOptions['finalHeight'] || $image.height();\n            nMagnifiedWidth = oOptions['magnifiedWidth'] || elZoomImage.width;\n            nMagnifiedHeight = oOptions['magnifiedHeight'] || elZoomImage.height;\n            nLensWidth = $lens.width();\n            nLensHeight = $lens.height();\n            oContainerOffset = getOffset(); // Required by refresh()\n            // Set zoom boundaries\n            if (oOptions['limitBounds']) {\n              nBoundX = (nLensWidth/2) / (nMagnifiedWidth/nImageWidth);\n              nBoundY = (nLensHeight/2) / (nMagnifiedHeight/nImageHeight);\n            }\n            // Enforce non-native large image size?\n            if (nMagnifiedWidth!==elZoomImage.width || nMagnifiedHeight!==elZoomImage.height) {\n              $lens.css('background-size', nMagnifiedWidth + 'px ' + nMagnifiedHeight + 'px');\n            }\n            // Store zoom dimensions for mobile plugin\n            $image.data('zoomSize', {\n              'width': nMagnifiedWidth,\n              'height': nMagnifiedHeight\n            });\n            // Store mobile close event for mobile plugin\n            $container.data('mobileCloseEvent', oDataAttr['mobileCloseEvent'] || oOptions['mobileCloseEvent']);\n            // Clean up\n            elZoomImage = null;\n            // Execute callback\n            oOptions.afterLoad();\n            // Simulate a lens move to update positioning if magnifiedWidth/magnifiedHeight is\n            // updated while the lens is visible\n            if ($lens.is(':visible')) moveLens();\n            // Handle mouse movements\n            $container.off().on({\n              'mousemove touchmove': moveLens,\n              'mouseenter': function() {\n                // Need to update offsets here to support accordions\n                oContainerOffset = getOffset();\n              },\n              'mouseleave': hideLens\n            });\n\n            // Prevent magnifying lens from getting \"stuck\"\n            if (oOptions['timeout']>=0) {\n              $container.on('touchend', function() {\n                setTimeout(hideLens, oOptions['timeout']);\n              });\n            }\n            // Ensure lens is closed when tapping outside of it\n            $('body').not($container).on('touchstart', hideLens);\n\n            // Support image map click-throughs while zooming\n            var sUsemap = $image.attr('usemap');\n            if (sUsemap) {\n              var $map = $('map[name=' + sUsemap.slice(1) + ']');\n              // Image map needs to be on the same DOM level as image source\n              $image.after($map);\n              $container.click(function(e) {\n                // Trigger click on image below lens at current cursor position\n                if (e.clientX || e.clientY) {\n                  $lens.hide();\n                  var elPoint = document.elementFromPoint(\n                      e.clientX || e.originalEvent.touches[0].clientX,\n                      e.clientY || e.originalEvent.touches[0].clientY\n                    );\n                  if (elPoint.nodeName==='AREA') {\n                    elPoint.click();\n                  } else {\n                    // Workaround for buggy implementation of elementFromPoint()\n                    // See https://bugzilla.mozilla.org/show_bug.cgi?id=1227469\n                    $('area', $map).each(function() {\n                      var a = $(this).attr('coords').split(',');\n                      if (nX>=a[0] && nX<=a[2] && nY>=a[1] && nY<=a[3]) {\n                        this.click();\n                        return false;\n                      }\n                    });\n                  }\n                }\n              });\n            }\n\n            if ($anchor.length) {\n              // Make parent anchor inline-block to have correct dimensions\n              $anchor.css('display', 'inline-block');\n              // Disable parent anchor if it's sourcing the large image\n              if ($anchor.attr('href') && !(oDataAttr['src'] || oOptions['src'])) {\n                $anchor.click(function(e) {\n                  e.preventDefault();\n                });\n              }\n            }\n\n          },\n          'error': function() {\n            // Clean up\n            elZoomImage = null;\n          }\n        });\n\n        elZoomImage.src = sZoomSrc;\n      }, // END init()\n\n      // Simple debounce\n      nTimer = 0,\n      refresh = function() {\n        clearTimeout(nTimer);\n        nTimer = setTimeout(function() {\n          $that.destroy();\n          $that.magnify(oOptions);\n        }, 100);\n      };\n\n    /**\n     * Public Methods\n     */\n\n    // Turn off zoom and reset to original state\n    this.destroy = function() {\n      this.each(function() {\n        var $this = $(this),\n          $lens = $this.prev('div.magnify-lens'),\n          sStyle = $this.data('originalStyle');\n        if ($this.parent('div.magnify').length && $lens.length) {\n          if (sStyle) $this.attr('style', sStyle);\n          else $this.removeAttr('style');\n          $this.unwrap();\n          $lens.remove();\n        }\n      });\n      // Unregister event handler\n      $(window).off('resize', refresh);\n      return $that;\n    }\n\n    // Handle window resizing\n    $(window).resize(refresh);\n\n    return this.each(function() {\n      // Initiate magnification powers\n      init(this);\n    });\n\n  };\n}(jQuery));\n"],"sourceRoot":"/source/"}